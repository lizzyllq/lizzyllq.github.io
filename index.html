<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Forward">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Forward">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Forward">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Forward</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Forward</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/12/算法基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lizzy llq">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Forward">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/12/算法基础/" itemprop="url">Algorithm & Data Structure</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-12T16:10:30+08:00">
                2019-11-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="C-语法基础知识"><a href="#C-语法基础知识" class="headerlink" title="C++语法基础知识"></a>C++语法基础知识</h1><h2 id="0-语法基础"><a href="#0-语法基础" class="headerlink" title="0. 语法基础"></a>0. 语法基础</h2><h3 id="指针-amp-引用"><a href="#指针-amp-引用" class="headerlink" title="指针 &amp; 引用"></a>指针 &amp; 引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>; </span><br><span class="line"><span class="keyword">int</span> j = <span class="number">6</span>; </span><br><span class="line"><span class="keyword">int</span> &amp;k = i; </span><br><span class="line">k = j; <span class="comment">// k 和 i 的值都变成了 6;</span></span><br></pre></td></tr></table></figure>
<p><strong>&amp; 用于创建引用变量以及取变量的地址，*用于创建指针变量以及解引用</strong></p>
<p>指针和引用的区别：<a href="https://geekplux.com/2013/01/02/pointer_references" target="_blank" rel="noopener">https://geekplux.com/2013/01/02/pointer_references</a></p>
<ul>
<li><p><strong>一、指针是一个实体（本质上就是存放变量地址的一个变量），而引用只是个别名。</strong></p>
<p>这句话从内存分配的角度很好理解，程序会为指针变量分配内存区域，而引用不分配内存区域。</p>
</li>
<li><p><strong>二、指针可变，引用不可变。</strong></p>
<p>指针在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。</p>
</li>
</ul>
<p>引用在逻辑上不独立，具有依附性，所以引用<strong>必须在一开始就被初始化</strong>，而且引用一旦和某个对象绑定后就不能再改变（从一而终）。</p>
<ul>
<li><p><strong>三、指针可以为空，引用不能为空。</strong></p>
<p> 即指针可以为 NULL，而引用必须与合法的存储单元关联。（指针则可以是 NULL，因此相对于指针，它不用检查它所指对象是否为空，这增加了效率）</p>
</li>
<li><p><strong>四、「sizeof 引用」得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小（</strong>由当前CPU运行模式的寻址位数决定,64位处理器上64位操作系统的64位编译器，指针大小8字节。8个字节）</p>
<p>指针通过*操作被指变量，引用直接操作被引变量，如指针和引用的自增(++)运算意义不一样</p>
</li>
<li><p><strong>五、引用不能 const，指针能 const，const 的指针不可变。</strong> </p>
<p>对于引用，具体指没有 int&amp;const a 这种形式，而 const int&amp; a 是有的， 前者指引用本身（即别名）不可以改变，这是理所当然的，所以不需要这种形式，后者指引用所指的值不可以改变）</p>
</li>
</ul>
<p>Tips: <strong>用适当的工具做恰如其分的工作</strong>  </p>
<p>指针能够毫无约束地操作内存中的任何东西，尽管指针功能强大，但是非常危险。</p>
<p>如果的确只需要借用一下某个对象的”别名”，那么就用”引用”，而不要用”指针”，以免发生意外</p>
<h3 id="for循环（范围循环）"><a href="#for循环（范围循环）" class="headerlink" title="for循环（范围循环）"></a>for循环（范围循环）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> my_array[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 每个数组元素乘于 2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : my_array)</span><br><span class="line">&#123;</span><br><span class="line">    x *= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// auto 类型也是 C++11 新标准中的，用来自动获取变量的类型</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : my_array) &#123;</span><br><span class="line">    x *= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="STL综述"><a href="#STL综述" class="headerlink" title="STL综述"></a>STL综述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1) vector  变长数组，倍增的思想 (系统为某一程序分配空间时所需要的时间和空间大小无关，和申请次数有关)</span></span><br><span class="line"><span class="comment">    size()  返回元素个数</span></span><br><span class="line"><span class="comment">    empty()  返回是否为空</span></span><br><span class="line"><span class="comment">    clear()  清空</span></span><br><span class="line"><span class="comment">    front()/back()</span></span><br><span class="line"><span class="comment">    push_back()/pop_back()</span></span><br><span class="line"><span class="comment">    begin()/end()</span></span><br><span class="line"><span class="comment">    []</span></span><br><span class="line"><span class="comment">    支持比较运算，按字典序</span></span><br><span class="line"><span class="comment"> 2) pair&lt;int, int&gt;</span></span><br><span class="line"><span class="comment">     first, 第一个元素</span></span><br><span class="line"><span class="comment">     second, 第二个元素</span></span><br><span class="line"><span class="comment">     支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span></span><br><span class="line"><span class="comment"> 3) string 字符串</span></span><br><span class="line"><span class="comment">     size()/length()  返回字符串长度</span></span><br><span class="line"><span class="comment">     empty()</span></span><br><span class="line"><span class="comment">     clear()</span></span><br><span class="line"><span class="comment">     substr(起始下标，(子串长度))  返回子串</span></span><br><span class="line"><span class="comment">     c_str()  返回字符串所在字符数组的起始地址</span></span><br><span class="line"><span class="comment">4) queue, 队列</span></span><br><span class="line"><span class="comment">	size()</span></span><br><span class="line"><span class="comment">    empty()</span></span><br><span class="line"><span class="comment">    push()  向队尾插入一个元素</span></span><br><span class="line"><span class="comment">    front()  返回队头元素</span></span><br><span class="line"><span class="comment">    back()  返回队尾元素</span></span><br><span class="line"><span class="comment">    pop()  弹出队头元素</span></span><br><span class="line"><span class="comment">5) priority_queue, 优先队列，默认是大根堆</span></span><br><span class="line"><span class="comment">	push()  插入一个元素</span></span><br><span class="line"><span class="comment">    top()  返回堆顶元素</span></span><br><span class="line"><span class="comment">    pop()  弹出堆顶元素</span></span><br><span class="line"><span class="comment">    定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;</span></span><br><span class="line"><span class="comment">6) stack, 栈</span></span><br><span class="line"><span class="comment">    size()</span></span><br><span class="line"><span class="comment">    empty()</span></span><br><span class="line"><span class="comment">    push()  向栈顶插入一个元素</span></span><br><span class="line"><span class="comment">    top()  返回栈顶元素</span></span><br><span class="line"><span class="comment">    pop()  弹出栈顶元素</span></span><br><span class="line"><span class="comment">7) deque, 双端队列</span></span><br><span class="line"><span class="comment">    size()</span></span><br><span class="line"><span class="comment">    empty()</span></span><br><span class="line"><span class="comment">    clear()</span></span><br><span class="line"><span class="comment">    front()/back()</span></span><br><span class="line"><span class="comment">    push_back()/pop_back()</span></span><br><span class="line"><span class="comment">    push_front()/pop_front()</span></span><br><span class="line"><span class="comment">    begin()/end()</span></span><br><span class="line"><span class="comment">    []</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">8) set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</span></span><br><span class="line"><span class="comment">    size()</span></span><br><span class="line"><span class="comment">    empty()</span></span><br><span class="line"><span class="comment">    clear()</span></span><br><span class="line"><span class="comment">    begin()/end()</span></span><br><span class="line"><span class="comment">    ++, -- 返回前驱和后继，时间复杂度 O(logn)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    set/multiset</span></span><br><span class="line"><span class="comment">        insert()  插入一个数</span></span><br><span class="line"><span class="comment">        find()  查找一个数</span></span><br><span class="line"><span class="comment">        count()  返回某一个数的个数</span></span><br><span class="line"><span class="comment">        erase()</span></span><br><span class="line"><span class="comment">            (1) 输入是一个数x，删除所有x   O(k + logn)</span></span><br><span class="line"><span class="comment">            (2) 输入一个迭代器，删除这个迭代器</span></span><br><span class="line"><span class="comment">        lower_bound()/upper_bound()</span></span><br><span class="line"><span class="comment">            lower_bound(x)  返回大于等于x的最小的数的迭代器</span></span><br><span class="line"><span class="comment">            upper_bound(x)  返回大于x的最小的数的迭代器</span></span><br><span class="line"><span class="comment">    map/multimap</span></span><br><span class="line"><span class="comment">        insert()  插入的数是一个pair</span></span><br><span class="line"><span class="comment">        erase()  输入的参数是pair或者迭代器</span></span><br><span class="line"><span class="comment">        find()</span></span><br><span class="line"><span class="comment">        []  注意multimap不支持此操作。 时间复杂度是 O(logn)</span></span><br><span class="line"><span class="comment">        lower_bound()/upper_bound()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">9) unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</span></span><br><span class="line"><span class="comment">    和上面类似，增删改查的时间复杂度是 O(1)</span></span><br><span class="line"><span class="comment">    不支持 lower_bound()/upper_bound()， 迭代器的++，--</span></span><br><span class="line"><span class="comment">10) bitset, 圧位</span></span><br><span class="line"><span class="comment">    bitset&lt;10000&gt; s;</span></span><br><span class="line"><span class="comment">    ~, &amp;, |, ^</span></span><br><span class="line"><span class="comment">    &gt;&gt;, &lt;&lt;</span></span><br><span class="line"><span class="comment">    ==, !=</span></span><br><span class="line"><span class="comment">    []</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    count()  返回有多少个1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    any()  判断是否至少有一个1</span></span><br><span class="line"><span class="comment">    none()  判断是否全为0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    set()  把所有位置成1</span></span><br><span class="line"><span class="comment">    set(k, v)  将第k位变成v</span></span><br><span class="line"><span class="comment">    reset()  把所有位变成0</span></span><br><span class="line"><span class="comment">    flip()  等价于~</span></span><br><span class="line"><span class="comment">    flip(k) 把第k位取反</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><blockquote>
<p>Vectors are sequence containers representing arrays that can change in size.</p>
</blockquote>
<p><a href="http://www.cplusplus.com/reference/vector/vector/?kw=vector" target="_blank" rel="noopener">http://www.cplusplus.com/reference/vector/vector/?kw=vector</a></p>
<p><strong>vector的创建</strong></p>
<p>(1) empty container constructor (default constructor)</p>
<ul>
<li>Constructs an <a href="http://www.cplusplus.com/vector::empty" target="_blank" rel="noopener">empty</a> container, with no elements.</li>
</ul>
<p>(2) fill constructor</p>
<ul>
<li>Constructs a container with <em>n</em> elements. Each element is a copy of <em>val</em>(<strong>默认为0</strong>).</li>
</ul>
<p>(3) range constructor （<strong>from vector or array</strong>）</p>
<ul>
<li>Constructs a container with as many elements as the range <code>[first,last)</code>, with each element constructed from its corresponding element in that range, in the same order.</li>
</ul>
<p>(4) copy constructor （<strong>copy from another vector只能从vector复制，不能从array复制</strong>）</p>
<ul>
<li>Constructs a container with a copy of each of the elements in <em>x</em>, in the same order.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constructin vectors</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// constructors used in the same order as described above:</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; first;                                <span class="comment">// empty vector of ints</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; second (<span class="number">4</span>,<span class="number">100</span>);                       <span class="comment">// four ints with value 100</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; third (second.begin(),second.end());  <span class="comment">// iterating through second</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fourth (third);                       <span class="comment">// a copy of third</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// the iterator constructor can also be used to construct from arrays:</span></span><br><span class="line">  <span class="keyword">int</span> myints[] = &#123;<span class="number">16</span>,<span class="number">2</span>,<span class="number">77</span>,<span class="number">29</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fifth (myints, myints + <span class="keyword">sizeof</span>(myints) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">  <span class="comment">//也可以直接赋值</span></span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sixth = &#123;<span class="number">16</span>,<span class="number">2</span>,<span class="number">77</span>,<span class="number">29</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The contents of fifth are:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = fifth.begin(); it != fifth.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>数字转string: to_string()</p>
<p>string转int   </p>
<ul>
<li><p>atoi()用于c风格字符串    </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="built_in">std</span>::atoi( s.c_str() );</span><br></pre></td></tr></table></figure>
</li>
<li><p>stoi()用于string</p>
<ul>
<li>atoi()的参数是 const char<em> ,因此对于一个字符串str我们必须调用 c_str()的方法把这个string转换成 const char</em>类型的,而stoi()的参数是const string<em>,不需要转化为 const char</em>；</li>
<li>stoi()会做范围检查，默认范围是在int的范围内的，如果超出范围的话则会runtime error！而atoi()不会做范围检查，如果超出范围的话，超出上界，则输出上界，超出下界，则输出下界；</li>
</ul>
</li>
<li><p>stringstream  </p>
</li>
</ul>
<p>string类的大小写转换： transform(str.begin(),str.end(),str.begin(),::tolower)</p>
<h3 id="set-map"><a href="#set-map" class="headerlink" title="set map"></a>set map</h3><p>set  unordered_set仅存key （(each value is itself also the element’s key).）</p>
<p>map unordered_map存key和value</p>
<p>set map unordered_set unordered_map中key唯一</p>
<p>set  map 由红黑树实现</p>
<p>unordered_set unordered_map 由哈希表实现</p>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p><strong>Associative, Ordered, Set, Unique keys, Allocator-aware</strong></p>
<p>set 创建</p>
<p>(1) empty container constructor (default constructor)</p>
<ul>
<li>Constructs an <a href="http://www.cplusplus.com/set::empty" target="_blank" rel="noopener">empty</a> container, with no elements.</li>
</ul>
<p>(2) range constructor</p>
<ul>
<li>Constructs a container with as many elements as the range <code>[first,last)</code>, with each element constructed from its corresponding element in that range.</li>
</ul>
<p>(3) copy constructor</p>
<ul>
<li>Constructs a container with a copy of each of the elements in <em>x</em>.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constructing sets</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fncomp</span> <span class="params">(<span class="keyword">int</span> lhs, <span class="keyword">int</span> rhs)</span> </span>&#123;<span class="keyword">return</span> lhs&lt;rhs;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">classcomp</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; lhs, <span class="keyword">const</span> <span class="keyword">int</span>&amp; rhs)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;<span class="keyword">return</span> lhs&lt;rhs;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; first;                           <span class="comment">// empty set of ints</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> myints[]= &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; second (myints,myints+<span class="number">5</span>);        <span class="comment">// range</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; third (second);                  <span class="comment">// a copy of second</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; fourth (second.begin(), second.end());  <span class="comment">// iterator ctor.</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>,classcomp&gt; fifth;                 <span class="comment">// class as Compare</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span>(*fn_pt)(<span class="keyword">int</span>,<span class="keyword">int</span>) = fncomp;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>(*)(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; sixth (fn_pt);  <span class="comment">// function pointer as Compare</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>count   </p>
<ul>
<li><p>return 1 if an element with a value equivalent to <em>k</em> is found, or zero otherwise.</p>
</li>
<li><p>时间复杂度 Logarithmic in size</p>
</li>
</ul>
</li>
<li><p>find </p>
<ul>
<li>An iterator to the element, if <em>val</em> is found, or <a href="http://www.cplusplus.com/set::end" target="_blank" rel="noopener">set::end</a> otherwise.</li>
<li>时间复杂度  Logarithmic in size</li>
</ul>
</li>
</ul>
<p><a href="https://blog.csdn.net/yas12345678/article/details/52601454" target="_blank" rel="noopener">https://blog.csdn.net/yas12345678/article/details/52601454</a></p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p><strong>Associative, Ordered, Map, Unique keys, Allocator-aware</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unordered_map::operator[]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="built_in">std</span>::<span class="built_in">string</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">"Bakery"</span>]=<span class="string">"Barbara"</span>;  <span class="comment">// new element inserted</span></span><br><span class="line">  mymap[<span class="string">"Seafood"</span>]=<span class="string">"Lisa"</span>;    <span class="comment">// new element inserted</span></span><br><span class="line">  mymap[<span class="string">"Produce"</span>]=<span class="string">"John"</span>;    <span class="comment">// new element inserted</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name = mymap[<span class="string">"Bakery"</span>];   <span class="comment">// existing element accessed (read)</span></span><br><span class="line">  mymap[<span class="string">"Seafood"</span>] = name;              <span class="comment">// existing element accessed (written)</span></span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">"Bakery"</span>] = mymap[<span class="string">"Produce"</span>];   <span class="comment">// existing elements accessed (read/written)</span></span><br><span class="line"></span><br><span class="line">  name = mymap[<span class="string">"Deli"</span>];      <span class="comment">// non-existing element: new element "Deli" inserted!</span></span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">"Produce"</span>] = mymap[<span class="string">"Gifts"</span>];    <span class="comment">// new element "Gifts" inserted, "Produce" written</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: mymap) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x.first &lt;&lt; <span class="string">": "</span> &lt;&lt; x.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h4><ul>
<li><p>创建</p>
<p>(1) empty container constructor (default constructor)</p>
<ul>
<li>Constructs an empty <a href="http://www.cplusplus.com/unordered_set" target="_blank" rel="noopener">unordered_set</a> object, containing no elements and with a <a href="http://www.cplusplus.com/unordered_set::size" target="_blank" rel="noopener">size</a> of zero.</li>
<li>It can construct the container with specific <em>hasher</em>, <em>key_equal</em> and <em>allocator</em> objects, along with a minimum number of hash buckets.</li>
</ul>
<p>(2) range constructor</p>
<ul>
<li>Constructs an <a href="http://www.cplusplus.com/unordered_set" target="_blank" rel="noopener">unordered_set</a> object containing copies of each of the elements in the range <code>[first,last)</code>.</li>
</ul>
<p>(3) copy constructor (and copying with allocator)</p>
<ul>
<li>The object is initialized to have the same contents and properties as the <em>ust</em> <a href="http://www.cplusplus.com/unordered_set" target="_blank" rel="noopener">unordered_set</a> object.</li>
</ul>
<p>(4) move constructor (and moving with allocator)</p>
<ul>
<li>The object acquires the contents of the rvalue <em>ust</em>.</li>
</ul>
<p>(5) initializer list</p>
<ul>
<li>Initializes the container with the contents of the list.</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constructing unordered_sets</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">cmerge</span> (<span class="title">T</span> <span class="title">a</span>, <span class="title">T</span> <span class="title">b</span>) &#123;</span> <span class="function">T <span class="title">t</span><span class="params">(a)</span></span>; t.insert(b.begin(),b.end()); <span class="keyword">return</span> t; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; first;                                <span class="comment">// empty</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; second ( &#123;<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>&#125; );    <span class="comment">// init list</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; third ( &#123;<span class="string">"orange"</span>,<span class="string">"pink"</span>,<span class="string">"yellow"</span>&#125; ); <span class="comment">// init list</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; fourth ( second );                    <span class="comment">// copy</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; fifth ( cmerge(third,fourth) );       <span class="comment">// move</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; sixth ( fifth.begin(), fifth.end() ); <span class="comment">// range</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sixth contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; x: sixth) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>insert</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unordered_set::insert</span></span><br><span class="line">include &lt;iostream&gt;</span><br><span class="line">include &lt;<span class="built_in">string</span>&gt;</span><br><span class="line">include &lt;<span class="built_in">array</span>&gt;</span><br><span class="line">include &lt;<span class="built_in">unordered_set</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::unordered_setstd::<span class="built_in">string</span> myset = &#123;<span class="string">"yellow"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::arraystd::<span class="built_in">string</span>,<span class="number">2</span> myarray = &#123;<span class="string">"black"</span>,<span class="string">"white"</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> mystring = <span class="string">"red"</span>;</span><br><span class="line">  myset.insert (mystring);                        <span class="comment">// copy insertion</span></span><br><span class="line">  myset.insert (mystring+<span class="string">"dish"</span>);                 <span class="comment">// move insertion</span></span><br><span class="line">  myset.insert (myarray.begin(), myarray.end());  <span class="comment">// range insertion</span></span><br><span class="line">  myset.insert ( &#123;<span class="string">"purple"</span>,<span class="string">"orange"</span>&#125; );           <span class="comment">// initializer list insertion</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myset contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; x: myset) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>count   </p>
<ul>
<li>return 1 if an element with a value equivalent to <em>k</em> is found, or zero otherwise.</li>
<li>时间复杂度  Average case: constant  | Worst case: linear in container size</li>
</ul>
</li>
<li><p>find </p>
<ul>
<li>An iterator to the element, if the specified value is found, or <a href="http://www.cplusplus.com/unordered_set::end" target="_blank" rel="noopener">unordered_set::end</a> if it is not found in the container.</li>
<li>时间复杂度  Average case: constant  | Worst case: linear in container size</li>
</ul>
</li>
</ul>
<h4 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h4><p><strong>Associative, Unordered, Map, Unique keys, Allocator-aware</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;Key,T&gt;::iterator it;</span><br><span class="line">(*it).first;             <span class="comment">// the key value (of type Key)</span></span><br><span class="line">(*it).second;            <span class="comment">// the mapped value (of type T)</span></span><br><span class="line">(*it);                   <span class="comment">// the "element value" (of type pair&lt;const Key,T&gt;)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">it-&gt;first;               <span class="comment">// same as (*it).first   (the key value)</span></span><br><span class="line">it-&gt;second;              <span class="comment">// same as (*it).second  (the mapped value)</span></span><br></pre></td></tr></table></figure>
<h3 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h3><p><a href="http://c.biancheng.net/view/481.html" target="_blank" rel="noopener">http://c.biancheng.net/view/481.html</a></p>
<p>priority_queue默认为大顶堆，即堆顶元素为堆中最大元素。</p>
<blockquote>
<p>priority_queue<int> q;</int></p>
<p>等价于：priority_queue<int, vector<int>, less<int> &gt; q;     // 大顶堆</int></int,></p>
</blockquote>
<p>如果我们想要用小顶堆的话需要增加使用两个参数：</p>
<blockquote>
<p> priority_queue<int, vector<int>, greater<int> &gt; q;  // 小顶堆</int></int,></p>
</blockquote>
<ul>
<li>pari的比较，先比较第一个元素，第一个相等比较第二个</li>
</ul>
<p>尽管提供了大小顶堆的模板，但是我们在实际应用过程中往往会使用更加复杂的数据结构构建堆，这时候我们就需要自定义数据结构的比较方式了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cell</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    Cell() &#123;&#125;</span><br><span class="line">    Cell(<span class="keyword">int</span> x,<span class="keyword">int</span> y, <span class="keyword">int</span> h): x(x),y(y),h(h) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Cell &amp; c1, <span class="keyword">const</span> Cell &amp; c2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c1.h &lt; c2.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Cell, <span class="built_in">vector</span>&lt;Cell&gt;, cmp&gt; q; <span class="comment">//template&lt;class_tp, class_sequence, class_cmp&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><h4 id="sort函数"><a href="#sort函数" class="headerlink" title="sort函数"></a>sort函数</h4><p><a href="http://www.cplusplus.com/reference/algorithm/sort/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/algorithm/sort/</a></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// sort algorithm example</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;    // std::sort</span></span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;       // std::vector</span></span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">bool</span> <span class="title">myfunction</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j); &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="class"><span class="keyword">struct</span> <span class="title">myclass</span> &#123;</span></span><br><span class="line">&gt;   <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j);&#125;</span><br><span class="line">&gt; &#125; myobject;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;   <span class="keyword">int</span> myints[] = &#123;<span class="number">32</span>,<span class="number">71</span>,<span class="number">12</span>,<span class="number">45</span>,<span class="number">26</span>,<span class="number">80</span>,<span class="number">53</span>,<span class="number">33</span>&#125;;</span><br><span class="line">&gt;   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints, myints+<span class="number">8</span>);             <span class="comment">// 32 71 12 45 26 80 53 33</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="comment">// using default comparison (operator &lt;):</span></span><br><span class="line">&gt;   <span class="built_in">std</span>::sort (myvector.begin(), myvector.begin()+<span class="number">4</span>);         <span class="comment">//(12 32 45 71)26 80 53 33</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="comment">// using function as comp</span></span><br><span class="line">&gt;   <span class="built_in">std</span>::sort (myvector.begin()+<span class="number">4</span>, myvector.end(), myfunction); <span class="comment">// 12 32 45 71(26 33 53 80)</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="comment">// using object as comp</span></span><br><span class="line">&gt;   <span class="built_in">std</span>::sort (myvector.begin(), myvector.end(), myobject); <span class="comment">//(12 26 32 33 45 53 71 80)</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="comment">// print out content:</span></span><br><span class="line">&gt;   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">&gt;   <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)</span><br><span class="line">&gt;     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">&gt;   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="n-th-element"><a href="#n-th-element" class="headerlink" title="n-th element"></a>n-th element</h4><div class="table-container">
<table>
<thead>
<tr>
<th>default (1)</th>
<th><code>template &lt;class RandomAccessIterator&gt;   void nth_element (RandomAccessIterator first, RandomAccessIterator nth,                     RandomAccessIterator last);</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>custom (2)</td>
<td><code>template &lt;class RandomAccessIterator, class Compare&gt;   void nth_element (RandomAccessIterator first, RandomAccessIterator nth,                     RandomAccessIterator last, Compare comp);</code></td>
</tr>
</tbody>
</table>
</div>
<p>Rearranges the elements in the range <code>[first,last)</code>, in such a way that the element at the nth position is the element that would be in that position in a sorted sequence.<br>The other elements are left without any specific order, except that none of the elements preceding nth are greater than it, and none of the elements following it are less.<br>The elements are compared using <code>operator&lt;</code> for the first version, and comp for the second.</p>
<h4 id="transform-函数"><a href="#transform-函数" class="headerlink" title="transform 函数"></a>transform 函数</h4><p> transform() 可以将函数应用到序列(单个或一对)的元素上，并将这个函数返回的值保存到另一个序列中，它返回的迭代器指向输出序列所保存的最后一个元素的下一个位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">UnaryOperator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">OutputIterator</span> <span class="title">transform</span> (<span class="title">InputIterator</span> <span class="title">first1</span>, <span class="title">InputIterator</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">UnaryOperator</span> <span class="title">op</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (first1 != last1) &#123;</span><br><span class="line">    *result = op(*first1);  <span class="comment">// or: *result=binary_op(*first1,*first2++);</span></span><br><span class="line">    ++result; ++first1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">BinaryOperation</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">OutputIterator</span> <span class="title">transform</span> (<span class="title">InputIterator1</span> <span class="title">first1</span>, <span class="title">InputIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">InputIterator2</span> <span class="title">first2</span>, <span class="title">OutputIterator</span> <span class="title">result</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">BinaryOperation</span> <span class="title">binary_op</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (first1 != last1) &#123;</span><br><span class="line">    *result=binary_op(*first1,*first2);</span><br><span class="line">    ++result; ++first1; ++first2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transform algorithm example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;    // std::transform</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;       // std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;   // std::plus</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op_increase</span> <span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> ++i; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; foo;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bar;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set some values:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; i++)</span><br><span class="line">    foo.push_back (i*<span class="number">10</span>);                         <span class="comment">// foo: 10 20 30 40 50</span></span><br><span class="line"></span><br><span class="line">  bar.resize(foo.size());                         <span class="comment">// allocate space</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::transform (foo.begin(), foo.end(), bar.begin(), op_increase);</span><br><span class="line">                                                  <span class="comment">// bar: 11 21 31 41 51</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// std::plus adds together its two arguments:</span></span><br><span class="line">  <span class="built_in">std</span>::transform (foo.begin(), foo.end(), bar.begin(), foo.begin(), <span class="built_in">std</span>::plus&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">                                                  <span class="comment">// foo: 21 41 61 81 101</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=foo.begin(); it!=foo.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><p><a href="https://stackoverflow.com/questions/17484354/why-cant-i-do-stdmap-begin-1" target="_blank" rel="noopener">https://stackoverflow.com/questions/17484354/why-cant-i-do-stdmap-begin-1</a></p>
<blockquote>
<p><code>std::map&lt;T&gt;::iterator</code> is of the iterator-class <em>bidirectional iterator</em>. Those only have <code>++</code> and <code>--</code>operators. <code>+N</code> and <code>[]</code> is only available for <em>random access iterators</em> (which can be found in e.g. <code>std::vector&lt;T&gt;</code>).</p>
<p>The reason behind this is that adding <code>N</code> to a <em>random access iterator</em> is constant time (e.g. add <code>N*sizeof(T)</code> to a <code>T*</code>), whereas doing the same thing for a <em>bidirectional iterator</em> would require applying <code>++</code> <code>N</code> times.</p>
<p>What you can do though (if you have C++11) is:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::const_iterator pIterTwo = <span class="built_in">std</span>::next(pSomeMap.begin(),<span class="number">1</span>);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><p>无序array</p>
<ul>
<li>无序查找：find</li>
</ul>
<p>有序array</p>
<ul>
<li>无序变有序： sort</li>
<li>有序查找： search</li>
</ul>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p><a href="https://www.jianshu.com/p/6365818c10ad" target="_blank" rel="noopener">https://www.jianshu.com/p/6365818c10ad</a></p>
<p>插入排序</p>
<ul>
<li>稳定排序，输入敏感（最好情况顺序：O(n),最坏情况逆序：O(n^2), 平均时间复杂度：O(n^2)）</li>
</ul>
<p>选择排序</p>
<ul>
<li>不稳定排序（交换位置的时候可能使得重复元素相互跨越），输入不敏感（O(n^2)）</li>
</ul>
<p>冒泡排序</p>
<ul>
<li>稳定排序，输入敏感（最好情况顺序：O(n),最坏情况逆序：O(n^2), 平均时间复杂度：O(n^2)）</li>
</ul>
<p>归并排序</p>
<ul>
<li>稳定，输入不敏感（O(nlogn)）</li>
</ul>
<p>快速排序</p>
<ul>
<li>不稳定,输入敏感（最好情况：O(nlogn) 最坏情况：顺序或逆序O(n^2), 平均时间复杂度：O(nlogn)）</li>
<li>随机快排 </li>
</ul>
<p>堆排序: 不稳定，输入不敏感（O(nlogn)）</p>
<p>数字范围：[0,M)   eg:荷兰国旗问题</p>
<p>桶排序: 链表数组  </p>
<ul>
<li>稳定排序   时间复杂度：O(n+M)  空间复杂度：O(n)</li>
</ul>
<p>应用：MaxGap</p>
<p>计数排序：通过数组记录每个数字的count[],accun[]  </p>
<ul>
<li>稳定排序  时间复杂度：O(n+M)  空间复杂度：O(n)</li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; q, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> <span class="comment">// [lo, hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hi - lo &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mi = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">    merge_sort(q, lo, mi);</span><br><span class="line">    merge_sort(q, mi, hi);</span><br><span class="line">    merge(q, lo, mi, hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; q, <span class="keyword">int</span> lo, <span class="keyword">int</span> mi, <span class="keyword">int</span> hi)</span></span>&#123; <span class="comment">// [lo, mi) [mi, hi)</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = lo, j = mi;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(hi - lo, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; mi &amp;&amp; j &lt; hi)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = lo, j = <span class="number">0</span>; i &lt; hi; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mergeSort(q, 0, n);</span></span><br></pre></td></tr></table></figure>
<h4 id="逆序对的数量"><a href="#逆序对的数量" class="headerlink" title="逆序对的数量"></a>逆序对的数量</h4><blockquote>
<p>two element a[i] and a[j] form an inversion if a[i]&gt;a[j] and i&lt;j</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; q, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> <span class="comment">// [lo, hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hi - lo &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mi = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = merge_sort(q, lo, mi) + merge_sort(q, mi, hi);</span><br><span class="line">    merge(q, lo, mi, hi, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; q, <span class="keyword">int</span> lo, <span class="keyword">int</span> mi, <span class="keyword">int</span> hi, <span class="keyword">int</span> &amp; res)</span></span>&#123; <span class="comment">// [lo, mi) [mi, hi)</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = lo, j = mi;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(hi - lo, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; mi &amp;&amp; j &lt; hi)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res += (mi - i + <span class="number">1</span>); <span class="comment">// 逆序对</span></span><br><span class="line">            tmp[k ++ ] = q[j ++ ];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = lo, j = <span class="number">0</span>; i &lt; hi; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; q, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = q[lo];</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = lo; <span class="comment">// [0,i) [i,j) </span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[j] &lt;= pivot)</span><br><span class="line">            swap(q[i++], q[j++]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j++;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(q[i], q[lo]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------</span></span><br><span class="line"><span class="comment">// 1. 确定分界点x    随机</span></span><br><span class="line"><span class="comment">// 2. 调整区间   &lt;=x  pivot &gt;=x  </span></span><br><span class="line"><span class="comment">// 3. 递归处理左边和右边两段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 勤于拓展，懒于交换  [lo, hi]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; q, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    swap (q[lo], q[lo + rand() % (hi - lo + <span class="number">1</span>)])</span><br><span class="line">    <span class="keyword">int</span> pivot = q[lo];</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( (lo &lt; hi) <span class="keyword">and</span> (pivot &lt;= q[hi])) hi--;</span><br><span class="line">        q[lo] = q[hi]; <span class="comment">// if(lo &lt; hi) q[lo++] = q[hi]; </span></span><br><span class="line">        <span class="keyword">while</span>( (lo &lt; hi) <span class="keyword">and</span> (q[lo] &lt;= pivot)) lo++;</span><br><span class="line">        q[hi] = q[lo]; <span class="comment">// if( lo &lt; hi) q[hi--] = q[lo];</span></span><br><span class="line">    &#125;</span><br><span class="line">    q[lo] = pivot;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有(几乎所有)元素均重复，上述版本快排时间复杂度退化</span></span><br><span class="line"><span class="comment">// 懒于拓展， 勤于交换 [lo, hi]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; q, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    swap (q[lo], q[lo + rand() % (hi - lo + <span class="number">1</span>)]);</span><br><span class="line">    <span class="keyword">int</span> pivot = q[lo];</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( (lo &lt; hi) <span class="keyword">and</span> (pivot &lt; q[hi])) hi--;</span><br><span class="line">        <span class="keyword">if</span>(lo &lt; hi) q[lo++] = q[hi]; <span class="comment">// 保证挑出循环时 lo==hi</span></span><br><span class="line">        <span class="keyword">while</span>( (lo &lt; hi) <span class="keyword">and</span> (q[lo] &lt; pivot)) lo++;</span><br><span class="line">        <span class="keyword">if</span>( lo &lt; hi) q[hi--] = q[lo];</span><br><span class="line">    &#125;</span><br><span class="line">    q[lo] = pivot;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[lo, hi)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; q, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( hi - lo &lt; <span class="number">2</span> ) <span class="keyword">return</span>; <span class="comment">// 单元素区间自然有序</span></span><br><span class="line">    <span class="keyword">int</span> mi = partition(lo, hi - <span class="number">1</span>); <span class="comment">// 在[lo, hi-1]内构造轴点</span></span><br><span class="line">    quickSort(lo, mi);</span><br><span class="line">    quickSort(mi+<span class="number">1</span>, hi);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// quickSort(q, 0, n-1); // 调用快排接口</span></span><br><span class="line"><span class="comment">// 快排稳定的方法 对 pair &#123;qi,i&#125;排序</span></span><br></pre></td></tr></table></figure>
<h4 id="Patrition"><a href="#Patrition" class="headerlink" title="Patrition"></a>Patrition</h4><h5 id="位序为k的元素"><a href="#位序为k的元素" class="headerlink" title="位序为k的元素"></a>位序为k的元素</h5><ul>
<li>快排，归并排序 $O(nlogn)$</li>
<li>冒泡排序，选择排序 $O(kn)$</li>
<li>小顶堆  $O(n+klogn)$  // n个元素建小顶堆，pop k次</li>
<li>大顶堆  $O(k+2(n-k)logk)$  // 任取k个元素建大顶堆，然后将剩余的n-k个元素依次插入，并随即删除堆顶，使得堆的规模维持为k.</li>
<li>将全体元素分为两组，分别构建规模为n-k的小顶堆G和规模为k的大顶堆H，接下来反复比较它们的堆顶g和h,只要g&lt;h，则将二者交换并重新调整两个堆，如此则g将持续增大，h将持续减小，当g&lt;=h, 则h即为所求元素，$O(n-k)+O(k)+min(k,n-k)<em>2</em>(O(logk)+O(log(n-k))$</li>
<li>基于快速划分的选取</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSelect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; q, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> lo = <span class="number">0</span>, hi = q.size() <span class="number">-1</span>; lo &lt; hi; )&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi;</span><br><span class="line">        swap (q[i], q[i + rand() % (j - i + <span class="number">1</span>)])</span><br><span class="line">        <span class="keyword">int</span> pivot = q[i];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>( (i &lt; j) <span class="keyword">and</span> (pivot &lt;= q[j])) j--;</span><br><span class="line">            q[i] = q[j];</span><br><span class="line">            <span class="keyword">while</span>( (i&lt;j) <span class="keyword">and</span> (q[i] &lt;= pivot)) i++;</span><br><span class="line">            q[j] = q[i];</span><br><span class="line">        &#125;</span><br><span class="line">        q[i] = pivot;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= i) hi = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= k) lo = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// q[k];</span></span><br></pre></td></tr></table></figure>
<h5 id="sort-colors"><a href="#sort-colors" class="headerlink" title="sort colors"></a>sort colors</h5><p><a href="https://leetcode.com/problems/sort-colors/" target="_blank" rel="noopener">https://leetcode.com/problems/sort-colors/</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;<span class="comment">// [0,i) [i,j) [j,k]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;nums.size();k++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=nums[k];</span><br><span class="line">        nums[k]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(v&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            nums[j]=<span class="number">1</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v==<span class="number">0</span>)&#123;</span><br><span class="line">            nums[i]=<span class="number">0</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Wiggle-Sort-II"><a href="#Wiggle-Sort-II" class="headerlink" title="Wiggle Sort II"></a>Wiggle Sort II</h5><p>Given an unsorted array <code>nums</code>, reorder it such that <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>.</p>
<p><strong>Note:</strong><br>You may assume all input has valid answer.</p>
<p><strong>Follow Up:</strong><br>Can you do it in O(n) time and/or in-place with O(1) extra space?</p>
<p><a href="https://leetcode.com/problems/wiggle-sort-ii/discuss/77678/3-lines-Python-with-Explanation-Proof" target="_blank" rel="noopener">https://leetcode.com/problems/wiggle-sort-ii/discuss/77678/3-lines-Python-with-Explanation-Proof</a></p>
<p><a href="https://leetcode.com/problems/wiggle-sort-ii/discuss/77677/O(n)%2BO(1)-after-median-Virtual-Indexing" target="_blank" rel="noopener">https://leetcode.com/problems/wiggle-sort-ii/discuss/77677/O(n)%2BO(1)-after-median-Virtual-Indexing</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Find a median.</span></span><br><span class="line">    <span class="keyword">auto</span> midptr = nums.begin() + n / <span class="number">2</span>;</span><br><span class="line">    nth_element(nums.begin(), midptr, nums.end());</span><br><span class="line">    <span class="keyword">int</span> mid = *midptr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 偶数位局部小 偶数位填数组中较小的一半 </span></span><br><span class="line">    <span class="comment">// 边界情况 中位数挨在一起 -&gt; 尽量使得中位数离得远</span></span><br><span class="line">    <span class="comment">//  偶数位： 中    小</span></span><br><span class="line">    <span class="comment">//  奇数位：    大     中</span></span><br><span class="line">    <span class="comment">//大 中 小 按  13579....02468....排列</span></span><br><span class="line">    <span class="comment">// Index-rewiring.</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> A(i) nums[(1+2*(i)) % (n|1)]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3-way-partition-to-wiggly in O(n) time with O(1) space.</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = n - <span class="number">1</span>; <span class="comment">// [0,i) [i,j) (k,n-1]</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A(j) &gt; mid)</span><br><span class="line">            swap(A(i++), A(j++));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A(j) &lt; mid)</span><br><span class="line">            swap(A(j), A(k--));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Accessing <code>A(0)</code> actually accesses <code>nums[1]</code>. </p>
<p>Accessing <code>A(1)</code> actually accesses <code>nums[3]</code>.</p>
<p> Accessing <code>A(2)</code> actually accesses <code>nums[5]</code>.</p>
<p> Accessing <code>A(3)</code> actually accesses <code>nums[7]</code>. </p>
<p>Accessing <code>A(4)</code> actually accesses <code>nums[9]</code>. </p>
<p>Accessing <code>A(5)</code> actually accesses <code>nums[0]</code>. </p>
<p>Accessing <code>A(6)</code> actually accesses <code>nums[2]</code>. </p>
<p>Accessing <code>A(7)</code> actually accesses <code>nums[4]</code>. </p>
<p>Accessing <code>A(8)</code> actually accesses <code>nums[6]</code>. </p>
<p>Accessing <code>A(9)</code> actually accesses <code>nums[8]</code>.</p>
</blockquote>
<h2 id="Majority-Element-众数"><a href="#Majority-Element-众数" class="headerlink" title="Majority Element 众数"></a>Majority Element 众数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash  时间复杂度O(n)  空间复杂度O(n) </span></span><br><span class="line"><span class="comment">// Count the number of appearances for each distinct number in nums, once we see a number appear more than n / 2 times, it is the majority element.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; counter;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++counter[num] &gt; nums.size() / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序  时间复杂度：期望O(nlogn)  空间复杂度O(1)</span></span><br><span class="line"><span class="comment">// 中位数   时间复杂度：期望O(n)  空间复杂度O(1)</span></span><br><span class="line"><span class="comment">// Since the majority element appears more than n / 2 times, the n / 2-th element in the sorted nums must be the majority element. In this case, a partial sort by nth_element is enough.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    nth_element(nums.begin(), nums.begin() + nums.size() / <span class="number">2</span>, nums.end());</span><br><span class="line">    <span class="keyword">return</span> nums[nums.size() / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Randomization  时间复杂度：期望为O(n) , 空间复杂度为O(1)</span></span><br><span class="line"><span class="comment">// Pick an element randomly and check whether it is the majority one.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size(), candidate, counter;</span><br><span class="line">    srand(<span class="keyword">unsigned</span>(time(<span class="literal">NULL</span>)));</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        candidate = nums[rand() % n], counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == candidate) &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Divide and Conquer 时间复杂度O(nlogn) 空间复杂度O(logn) (系统栈)</span></span><br><span class="line"><span class="comment">//Recursively find the majority in the two halves of nums and combine the results. The base case is that the majority element of a single-element array is just that element.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> majority(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majority</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>, lm = majority(nums, l, m), rm = majority(nums, m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">if</span> (lm == rm) &#123;</span><br><span class="line">        <span class="keyword">return</span> lm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count(nums.begin() + l, nums.begin() + r + <span class="number">1</span>, lm) &gt; count(nums.begin() + l, nums.begin() + r + <span class="number">1</span>, rm) ? lm : rm;</span><br><span class="line">    <span class="comment">// std::count() returns number of occurrences of an element in a given range. Returns the number of elements in the range [first,last) that compare equal to val.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Moore Voting Algorithm  时间复杂度为O(n) 空间复杂度为O(1)</span></span><br><span class="line"><span class="comment">// 每次都找出一对不同的元素，从数组中删掉，直到数组为空或只有一种元素。 不难证明，如果存在元素e出现频率超过半数，那么数组中最后剩下的就只有e</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>, majority;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!counter) &#123;</span><br><span class="line">            majority = num;</span><br><span class="line">        &#125;</span><br><span class="line">        counter += num == majority ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> majority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bit Manipulation 时间复杂度为O(n) 空间复杂度为O(1)</span></span><br><span class="line"><span class="comment">// The bits in the majority are just the majority bits of all numbers.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> majority = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>, mask = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++, mask &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> bits = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &amp; mask) &#123;</span><br><span class="line">                bits++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bits &gt; nums.size() / <span class="number">2</span>) &#123;</span><br><span class="line">            majority |= mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> majority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.com/problems/majority-element/discuss/51612/6-Suggested-Solutions-in-C%2B%2B-with-Explanations" target="_blank" rel="noopener">https://leetcode.com/problems/majority-element/discuss/51612/6-Suggested-Solutions-in-C%2B%2B-with-Explanations</a></p>
<h2 id="shuffle算法"><a href="#shuffle算法" class="headerlink" title="shuffle算法"></a>shuffle算法</h2><h3 id="Brute-force-不断取出抽样"><a href="#Brute-force-不断取出抽样" class="headerlink" title="Brute force(不断取出抽样)"></a>Brute force(不断取出抽样)</h3><blockquote>
<p>The brute force algorithm essentially puts each number in the aforementioned “hat”, and draws them at random (without replacement) until there are none left. Mechanically, this is performed by copying the contents of <code>array</code> into a second auxiliary array named <code>aux</code> before overwriting each element of <code>array</code> with a randomly selected one from <code>aux</code>. After selecting each random element, it is removed from <code>aux</code> to prevent duplicate draws. </p>
<p>证明： the probability of a particular element ee being chosen on the kth iteration为</p>
<p>$\frac{n-1}{n}<em>\frac{n-2}{n-1}…..</em>\frac{1}{n-k}=\frac{1}{n}$</p>
</blockquote>
<h3 id="Fisher-Yates-Algorithm-洗牌算法"><a href="#Fisher-Yates-Algorithm-洗牌算法" class="headerlink" title="Fisher-Yates Algorithm(洗牌算法)"></a>Fisher-Yates Algorithm(洗牌算法)</h3><p>//每次交换当前元素和（包含当前之后的所有元素中的任意一个）</p>
<p><a href="https://www.cnblogs.com/zichi/p/Fisher-Yates-shuffle.html" target="_blank" rel="noopener">https://www.cnblogs.com/zichi/p/Fisher-Yates-shuffle.html</a></p>
<blockquote>
<p><strong>随机性的数学归纳法证明</strong></p>
<p>对 n 个数进行随机：</p>
<ol>
<li>首先我们考虑 n = 2 的情况，根据算法，显然有 1/2 的概率两个数交换，有 1/2 的概率两个数不交换，因此对 n = 2 的情况，元素出现在每个位置的概率都是 1/2，满足随机性要求。</li>
<li>假设有 i 个数， i &gt;= 2 时，算法随机性符合要求，即每个数出现在 i 个位置上每个位置的概率都是 1/i。</li>
<li>对于 i + 1 个数，按照我们的算法，在第一次循环时，每个数都有 1/(i+1) 的概率被交换到最末尾，所以每个元素出现在最末一位的概率都是 1/(i+1) 。而每个数也都有 i/(i+1) 的概率不被交换到最末尾，如果不被交换，从第二次循环开始还原成 i 个数随机，根据 2. 的假设，它们出现在 i 个位置的概率是 1/i。因此每个数出现在前 i 位任意一位的概率是 (i/(i+1)) * (1/i) = 1/(i+1)，也是 1/(i+1)。</li>
<li>综合 1. 2. 3. 得出，对于任意 n &gt;= 2，经过这个算法，每个元素出现在 n 个位置任意一个位置的概率都是 1/n。</li>
</ol>
</blockquote>
<h2 id="Ksum问题"><a href="#Ksum问题" class="headerlink" title="Ksum问题"></a>Ksum问题</h2><p>2sum   3sum  4sum</p>
<h3 id="2sum"><a href="#2sum" class="headerlink" title="2sum"></a>2sum</h3><p><strong>array中的值只能用一次 从中选出两个数  |   仅要求返回一个答案,没有遗漏的搜索即可，组合内部允许值的重复性</strong></p>
<ul>
<li>无序数组</li>
</ul>
<p>​      $O(n^2 )$ runtime, $O(1)$ space – Brute force</p>
<p>​      $O(n)$ runtime, $O(n)$ space – Hash table</p>
<ul>
<li><p>有序数组</p>
<p>O(n log n) runtime, O(1) space – Binary search</p>
<p>O(n) runtime, O(1) space – Two pointers</p>
</li>
</ul>
<h3 id="3-sum"><a href="#3-sum" class="headerlink" title="3 sum"></a>3 sum</h3><p>语义不同：</p>
<ol>
<li><blockquote>
<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.(仅要求返回一个答案)</p>
<p>————&gt;排序， 退化为2sum问题解决  $O(N^2)$</p>
<p>该语义下的ksum问题时间复杂度为 $O(N^{k-1})$ (k&gt;=3)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       sort(nums.begin(),nums.end());</span><br><span class="line">       <span class="keyword">int</span> result = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-2</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">int</span> k = nums.size()<span class="number">-1</span>;</span><br><span class="line">           <span class="keyword">while</span>(j&lt;k)&#123;</span><br><span class="line">               <span class="keyword">int</span> temp = nums[i] + nums[j] + nums[k];</span><br><span class="line">               <span class="keyword">if</span>(<span class="built_in">abs</span>(temp-target)&lt;<span class="built_in">abs</span>(result-target)) result = temp;</span><br><span class="line">               <span class="keyword">if</span>(temp &lt; target) j++;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(temp &gt; target) k--;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">return</span> target;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><blockquote>
<p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <code>nums</code> such that <em>a</em> + <em>b</em>+ <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.（找出所有不同的组合）</p>
</blockquote>
<p><strong>array中每个元素只能用一次 从中选出3个数| 不重不漏，返回值的组合种数（按递增排序相同的序列算一种 i&lt;=j&lt;=k）</strong></p>
</li>
</ol>
<blockquote>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate triplets.</p>
</blockquote>
<p>方法一：</p>
<p>哈希表不适合k很大的情况，很难判断array中是否存在 (i j k) 这样的组合</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">       <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; c;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> a : nums) c[a]++;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">auto</span> it : c)</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">auto</span> it2 : c) &#123;</span><br><span class="line">               <span class="keyword">int</span> i = it.first, j = it2.first, k = <span class="number">0</span> - i - j;</span><br><span class="line">               <span class="keyword">if</span> (!c.count(k)) <span class="keyword">continue</span>;</span><br><span class="line">               <span class="keyword">if</span> ((i == j &amp;&amp; j == k &amp;&amp; c[i]&gt;=<span class="number">3</span>) <span class="keyword">or</span> (i == j &amp;&amp; j != k &amp;&amp; c[i]&gt;=<span class="number">2</span>) <span class="keyword">or</span> (i &lt; j &amp;&amp; j &lt; k))&#123;</span><br><span class="line">                   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">                   tmp.push_back(i);</span><br><span class="line">                   tmp.push_back(j);</span><br><span class="line">                   tmp.push_back(k);</span><br><span class="line">                   result.push_back(tmp);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>方法2：</p>
<p>The idea is to sort an input array and then run through all indices of a possible first element of a triplet. For each possible first element we make a standard bi-directional 2Sum sweep of the remaining part of the array. Also we want to skip equal elements to avoid duplicates in the answer without making a set or smth like that.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">    <span class="comment">//三元组的顺序单调递增</span></span><br><span class="line">    Arrays.sort(num);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;(); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length-<span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//保证第一个数字（最小的数字）各异</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || (i &gt; <span class="number">0</span> &amp;&amp; num[i] != num[i-<span class="number">1</span>])) &#123;</span><br><span class="line">            <span class="keyword">int</span> lo = i+<span class="number">1</span>, hi = num.length-<span class="number">1</span>, sum = <span class="number">0</span> - num[i];</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num[lo] + num[hi] == sum) &#123;</span><br><span class="line">                    res.add(Arrays.asList(num[i], num[lo], num[hi]));</span><br><span class="line">                    <span class="comment">//保证后两个数字（最大和次大的数字）的组合各异</span></span><br><span class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; num[lo] == num[lo+<span class="number">1</span>]) lo++;</span><br><span class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; num[hi] == num[hi-<span class="number">1</span>]) hi--;</span><br><span class="line">                    lo++; hi--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num[lo] + num[hi] &lt; sum) lo++;</span><br><span class="line">                <span class="keyword">else</span> hi--;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><blockquote>
<p>3Sum With Multiplicity:Given an integer array A, and an integer target, return the number of tuples i, j, k  such that i &lt; j &lt; k and A[i] + A[j] + A[k] == target.（找出所有不同的排列）</p>
</blockquote>
</li>
</ol>
<blockquote>
<p><strong>As the answer can be very large, return it modulo 10^9 + 7</strong>.</p>
</blockquote>
<p><strong>array中每个元素只能用一次 从中选出3个数| 不重不漏，返回值的排列种数（k较小时，可以先组合再排列）</strong></p>
<p>Count the occurrence of each number.<br>using hashmap or array up to you.</p>
<p>Loop <code>i</code> on all numbers,<br>loop <code>j</code> on all numbers,<br>check if <code>k = target - i - j</code> is valid.</p>
<p>Add the number of this combination to result.<br>3 cases covers all possible combination(确定顺序 防止重复):</p>
<ol>
<li><code>i == j == k</code></li>
<li><code>i == j != k</code></li>
<li><code>i &lt; j &amp;&amp; j &lt; k</code></li>
</ol>
<p><strong>Time Complexity</strong>:<br><code>3 &lt;= A.length &lt;= 3000</code>, so N = 3000<br>But <code>0 &lt;= A[i] &lt;= 100</code><br>So my solution is <code>O(101^2)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threeSumMulti</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">long</span>&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a : A) c[a]++;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : c)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it2 : c) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = it.first, j = it2.first, k = target - i - j;</span><br><span class="line">            <span class="keyword">if</span> (!c.count(k)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == j &amp;&amp; j == k)</span><br><span class="line">                res += c[i] * (c[i] - <span class="number">1</span>) * (c[i] - <span class="number">2</span>) / <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == j &amp;&amp; j != k)</span><br><span class="line">                res += c[i] * (c[i] - <span class="number">1</span>) / <span class="number">2</span> * c[k];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; j &amp;&amp; j &lt; k)</span><br><span class="line">                res += c[i] * c[j] * c[k];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res % <span class="keyword">int</span>(<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ksum问题-降解为2sum问题"><a href="#ksum问题-降解为2sum问题" class="headerlink" title="ksum问题(降解为2sum问题)"></a>ksum问题(降解为2sum问题)</h3><p>4sum</p>
<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.</p>
<p><strong>array中每个元素只能用一次 从中选出k个数| 不重不漏，返回所有组合</strong></p>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate quadruplets.</p>
<p><a href="https://leetcode.com/problems/4sum/discuss/8545/Python-140ms-beats-100-and-works-for-N-sum-(Ngreater2)" target="_blank" rel="noopener">https://leetcode.com/problems/4sum/discuss/8545/Python-140ms-beats-100-and-works-for-N-sum-(Ngreater2)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    results = []</span><br><span class="line">    self.findNsum(nums, target, <span class="number">4</span>, [], results)</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findNsum</span><span class="params">(self, nums, target, N, result, results)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt; N <span class="keyword">or</span> N &lt; <span class="number">2</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># solve 2-sum</span></span><br><span class="line">    <span class="keyword">if</span> N == <span class="number">2</span>:</span><br><span class="line">        l,r = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span> nums[l] + nums[r] == target:</span><br><span class="line">                results.append(result + [nums[l], nums[r]])</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l - <span class="number">1</span>]:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> r &gt; l <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[l] + nums[r] &lt; target:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(nums)-N+<span class="number">1</span>):   <span class="comment"># careful about range</span></span><br><span class="line">            <span class="keyword">if</span> target &lt; nums[i]*N <span class="keyword">or</span> target &gt; nums[<span class="number">-1</span>]*N:  <span class="comment"># take advantages of sorted list</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i<span class="number">-1</span>] != nums[i]:  <span class="comment"># recursively reduce N</span></span><br><span class="line">                self.findNsum(nums[i+<span class="number">1</span>:], target-nums[i], N<span class="number">-1</span>, result+[nums[i]], results)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(n^{k-1})$</p>
<h3 id="Combination-Sum-II"><a href="#Combination-Sum-II" class="headerlink" title="Combination Sum II"></a>Combination Sum II</h3><p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p>
<p>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including <code>target</code>) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p><strong>array中每个元素只能用一次 从中选出任意个数 | 不重不漏，返回所有组合</strong></p>
<h3 id="Combination-Sum-III"><a href="#Combination-Sum-III" class="headerlink" title="Combination Sum III"></a>Combination Sum III</h3><p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p><strong>array中元素的值互异，每个元素只能用一次 从中选出k个数|  返回所有组合</strong></p>
<h3 id="Combination-Sum"><a href="#Combination-Sum" class="headerlink" title="Combination Sum"></a>Combination Sum</h3><p>Given a <strong>set</strong> of candidate numbers (<code>candidates</code>) <strong>(without duplicates)</strong> and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p>
<p>The <strong>same</strong> repeated number may be chosen from <code>candidates</code> unlimited number of times.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including <code>target</code>) will be positive integers.(防止正数+负数=0,产生无数组合)</li>
<li><p>The solution set must not contain duplicate combinations.</p>
<p><strong>array中元素的值互异，每个元素可无限次取  从中选出任意个数|  返回所有组合</strong></p>
</li>
</ul>
<p>-&gt; 回溯 </p>
<p><strong>array中元素的值互异，每个元素可无限次取  从中选出任意个数|  返回组合种数</strong></p>
<p><strong>array中元素的值互异，每个元素可无限次取 从中选出任意个数|  返回排列的种数</strong></p>
<p>-&gt; 完全背包</p>
<p>总结：</p>
<p>组合：先排序，保证取值的顺序递增，</p>
<p>array中每个元素只能用一次： index递增</p>
<p>元素不互异：回溯过程中每取一个数字，保证该位互异</p>
<h3 id="Path-sum3"><a href="#Path-sum3" class="headerlink" title="Path sum3"></a>Path sum3</h3><p>You are given a binary tree in which each node contains an integer value.</p>
<p>Find the number of paths that sum to a given value.</p>
<p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p>
<p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p>
<p>//固定起始点，将问题分解   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> pathFromSource(root,sum)+pathSum(root-&gt;left,sum)+pathSum(root-&gt;right,sum);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//固定起始点，将问题分解</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathFromSource</span><span class="params">(TreeNode* root,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> path;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (root-&gt;val==sum) +  pathFromSource(root-&gt;left,sum-root-&gt;val)</span><br><span class="line">            + pathFromSource(root-&gt;right,sum-root-&gt;val);</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>//用哈希表保存路径的所有前缀和，以及保存当前sum(从根节点到当前节点的路径sum)，若哈希表中存在前缀和==当前sum-target,说明存在以当前节点结束节点的路径和为target   $O(n)$</p>
<p>So the idea is similar as Two sum, using HashMap to store ( key : the prefix sum, value : how many ways get to this prefix sum) , and whenever reach a node, we check if prefix sum - target exists in hashmap or not, if it does, we added up the ways of prefix sum - target into res. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; sum, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; counter, <span class="keyword">int</span> currentSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        currentSum += root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, target = currentSum - sum;</span><br><span class="line">        <span class="keyword">if</span> (counter.count(target)) res  +=counter[target];</span><br><span class="line">        counter[currentSum]++;</span><br><span class="line"></span><br><span class="line">        res +=countPathSum(root-&gt;left, sum, counter, currentSum);</span><br><span class="line">        res +=countPathSum(root-&gt;right, sum, counter, currentSum);</span><br><span class="line">        counter[currentSum]--;  <span class="comment">//记得要回溯</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; counter;</span><br><span class="line">        counter[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> countPathSum(root, sum, counter, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><blockquote>
<p>$A+B;    A-B;   A*\alpha;   A/\alpha;        len(A) = 10^6;    \alpha&lt;= 10000$</p>
</blockquote>
<p>将大整数的每一位存在数组里, 第0位存个位</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高精度存储</span></span><br><span class="line"><span class="built_in">string</span> a, b;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = b.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定两个正整数，计算它们的和</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; add(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size() <span class="keyword">or</span> i &lt; B.size(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.size()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------------------------------</span></span><br><span class="line"><span class="comment">// 减法</span></span><br><span class="line"><span class="comment">// 判断是否有A&gt;=B</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size() != B.size()) <span class="keyword">return</span> A.size() &gt; B.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// A==B</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if Ai-Bi-t &gt;= 0 =&gt; Ai-Bi-t; t=0;</span></span><br><span class="line"><span class="comment">// else Ai-Bi-t+10; t=1 // 借位</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sub(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.size(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t -= B[i];</span><br><span class="line">        C.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back(); <span class="comment">// 去掉高位无效的0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给定两个正整数，计算它们的差</span></span><br><span class="line"><span class="keyword">if</span> (cmp(A, B)) C = sub(A, B);</span><br><span class="line"><span class="keyword">else</span> C = sub(B, A), <span class="built_in">cout</span> &lt;&lt; <span class="string">'-'</span>;</span><br><span class="line"><span class="comment">//----------------------------------------</span></span><br><span class="line"><span class="comment">// 乘法 把b看做一个整体</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mul(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.size()) t += A[i] * b;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------</span></span><br><span class="line"><span class="comment">// 除法 商是C，余数是r</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; div(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.push_back(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(C.begin(), C.end());</span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h2><h3 id="子区间的和-子矩阵的和"><a href="#子区间的和-子矩阵的和" class="headerlink" title="子区间的和/ 子矩阵的和"></a>子区间的和/ 子矩阵的和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子区间的和</span></span><br><span class="line"><span class="keyword">for</span> i : <span class="number">1</span>~n</span><br><span class="line">    s[i] = s[i<span class="number">-1</span>] + a[i]</span><br><span class="line"><span class="comment">// 给定左右端点l,r 子区间的和</span></span><br><span class="line">s[r] - s[l<span class="number">-1</span>]</span><br><span class="line"><span class="comment">// -----------------------</span></span><br><span class="line"><span class="comment">// 子矩阵的和</span></span><br><span class="line"><span class="keyword">for</span> i : <span class="number">1</span>~n</span><br><span class="line">    <span class="keyword">for</span> j : <span class="number">1</span>~m</span><br><span class="line">        S[i][j] = S[i<span class="number">-1</span>][j] + S[i][j<span class="number">-1</span>] - S[i<span class="number">-1</span>][j<span class="number">-1</span>] + a[i][j];</span><br><span class="line"><span class="comment">// 左上角(x1,y1) 右下角(x2,y2)的子矩阵和  闭区间</span></span><br><span class="line">S[x2][y2] - S[x2][y1<span class="number">-1</span>] - S[x1<span class="number">-1</span>][y2] + S[x1<span class="number">-1</span>][y1<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="差分-差分矩阵"><a href="#差分-差分矩阵" class="headerlink" title="差分/ 差分矩阵"></a>差分/ 差分矩阵</h3><p>前缀和与差分是逆运算**</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a1 a2 a3 ... an  前缀和</span></span><br><span class="line"><span class="comment">// b1 b2 b3 ... bn  差分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a[l~r] += c                   O(n)</span></span><br><span class="line"><span class="comment">// b[l] += c; b[r+1] -= c;       O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差分</span></span><br><span class="line"><span class="comment">// 输入一个长度为n的整数序列。接下来输入m个操作，每个操作包含三个整数l, r, c，表示将序列中[l, r]之间的每个数加上c。请你输出进行完所有操作后的序列。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="comment">// 无需考虑构造，假定初始化 a[i],b[i]均为0； 只需考虑如何更新</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) insert(i, i, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">        insert(l, r, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) b[i] += b[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">printf</span>(<span class="string">"%d "</span>, b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------</span></span><br><span class="line"><span class="comment">// 差分矩阵</span></span><br><span class="line"><span class="comment">// aij   前缀和</span></span><br><span class="line"><span class="comment">// bij   差分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Two-pointers-双指针"><a href="#Two-pointers-双指针" class="headerlink" title="Two pointers  双指针"></a>Two pointers  双指针</h2><blockquote>
<p>用两个指针维护一段区间</p>
<p>用两个指针维护某种次序（如归并排序）</p>
</blockquote>
<h3 id="Reverse-Words-in-a-String"><a href="#Reverse-Words-in-a-String" class="headerlink" title="Reverse Words in a String"></a>Reverse Words in a String</h3><blockquote>
<p>Q: What constitutes a word?</p>
<p>A: A sequence of non-space characters constitutes a word.</p>
<p>Q: Does tab or newline character count as space characters?</p>
<p>A: Assume the input does not contain any tabs or newline characters.</p>
<p>Q: Could the input string contain leading or trailing spaces?</p>
<p>A: Yes. However, your reversed string should not contain leading or trailing spaces.</p>
<p>Q: How about multiple spaces between two words?</p>
<p>A: Reduce them to a single space in the reversed string.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Given an input string s, reverse the string word by word.</span></span><br><span class="line"><span class="comment">// For example, given s = "the sky is blue", return "blue is sky the".</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuilder reversed = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> j = s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">        	j = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span> || s.charAt(i - <span class="number">1</span>) == <span class="string">' '</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reversed.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            	reversed.append(<span class="string">' '</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            reversed.append(s.substring(i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reversed.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -----------------------------------------------------</span></span><br><span class="line"><span class="comment">// The input string does not contain leading or trailing spaces and the words are always separated by a single space.</span></span><br><span class="line"><span class="comment">// in place</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">	reverse(s, <span class="number">0</span>, s.length); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt;= s.length; j++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (j == s.length || s[j] == <span class="string">' '</span>) &#123; </span><br><span class="line">            reverse(s, i, j); </span><br><span class="line">            i = j + <span class="number">1</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (end - begin) / <span class="number">2</span>; i++) &#123; </span><br><span class="line">        <span class="keyword">char</span> temp = s[begin + i]; </span><br><span class="line">        s[begin + i] = s[end - i - <span class="number">1</span>]; </span><br><span class="line">        s[end - i - <span class="number">1</span>] = temp; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note: j记录当前单词之后紧邻的空格位置</p>
<h3 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a>Longest Substring Without Repeating Characters</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length_of_longest_substring</span><span class="params">(<span class="built_in">string</span> &amp; s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; table;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;s.size(); j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(table[s[j]]&gt;=i)&#123;</span><br><span class="line">            max_len = max(max_len,j-i);</span><br><span class="line">            i = table[s[j]]+<span class="number">1</span>; <span class="comment">// all substrings that start before or at index table[s[j]] would be less than your current maximum</span></span><br><span class="line">        &#125;</span><br><span class="line">        table[s[j]] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(max_len,j-i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><p>保序的离散化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假定有一个无限长的数轴，数轴上每个坐标上的数都是0。现在，我们首先进行 n 次操作，每次操作将某一位置x上的数加c。近下来，进行 m 次询问，每个询问包含两个整数l和r，你需要求出在区间[l, r]之间的所有数的和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序 去重  (所有的坐标：插入的坐标和查询的坐标)</span></span><br><span class="line"><span class="comment">// 二分查找x对应的离散化后的值  &gt;=x的最小的位置</span></span><br></pre></td></tr></table></figure>
<h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><h3 id="蓄水池采样"><a href="#蓄水池采样" class="headerlink" title="蓄水池采样"></a>蓄水池采样</h3><p>1）从 100000 份调查报告中抽取 1000 份进行统计</p>
<p>2） 从 Google 搜索 “Ken Thompson”，从中抽取 100 个结果查看哪些是今年的</p>
<ul>
<li>确定数据的整体规模： 随机打乱数据，取前k个</li>
<li>流数据，不确定数据整体规模，蓄水池采样</li>
</ul>
<p>​      假设需要采样的数量为k, 首先构建一个可容纳k个元素的数组，将序列的前k个元素放入数组中,然后从第k+1个元素开始，假设当前元素为序列中第M+1个元素，以k/(M+1)的概率来决定该元素是否被替换到数组中（数组中的元素被替换的概率是相同的）。 当遍历完所有元素之后，数组中剩下的元素即为所需采取的样本  <strong>数学归纳法可证明</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] sampling(<span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[K];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i++) &#123; <span class="comment">// 前 K 个元素直接放入数组中</span></span><br><span class="line">            result[i] = pool[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = K; i &lt; N; i++) &#123; <span class="comment">// K + 1 个元素开始进行概率采样</span></span><br><span class="line">            <span class="keyword">int</span> r = random.nextInt(i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (r &lt; K) &#123;</span><br><span class="line">                result[r] = pool[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/snowInPluto/p/5996269.html" target="_blank" rel="noopener">https://www.cnblogs.com/snowInPluto/p/5996269.html</a></p>
<h3 id="加权随机采样"><a href="#加权随机采样" class="headerlink" title="加权随机采样"></a>加权随机采样</h3><blockquote>
<p>一个集合里有 <code>n</code> 个元素，每个元素有不同的权重，现在要不放回地随机抽取 <code>m</code> 个元素，每个元素被抽中的概率为元素的权重占总权重的比例。要怎么做呢？</p>
</blockquote>
<p><a href="https://lotabout.me/2018/Weighted-Random-Sampling/" target="_blank" rel="noopener">https://lotabout.me/2018/Weighted-Random-Sampling/</a></p>
<h2 id="In-place"><a href="#In-place" class="headerlink" title="In place"></a>In place</h2><h3 id="First-Missing-Positive"><a href="#First-Missing-Positive" class="headerlink" title="First Missing Positive"></a>First Missing Positive</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 除去负数及零的干扰</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;nums.size(); j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums[i]=nums[j];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[j])&lt;=i &amp;&amp; nums[<span class="built_in">abs</span>(nums[j])<span class="number">-1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums[<span class="built_in">abs</span>(nums[j])<span class="number">-1</span>] *=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j]&gt;<span class="number">0</span>) <span class="keyword">return</span> j+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rotate-array"><a href="#rotate-array" class="headerlink" title="rotate array"></a>rotate array</h3><blockquote>
<p>Given an array, rotate the array to the right by <em>k</em> steps, where <em>k</em> is non-negative.</p>
</blockquote>
<p>leetcode 189</p>
<p>方法一：首先对整个数组逆序，然后分别对前k个数字和后n-k个数字逆序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.size();</span><br><span class="line">    k%=n;</span><br><span class="line">    reverse(nums,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    reverse(nums,<span class="number">0</span>,k<span class="number">-1</span>);</span><br><span class="line">    reverse(nums,k,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j) swap(nums[i++],nums[j--]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：依次处理被占位的数字  Using Cyclic Replacements</p>
<blockquote>
<p>We can directly place every number of the array at its required correct position. But if we do that, we will destroy the original element. Thus, we need to store the number being replaced in a temp variable. Then, we can place the replaced number(temp) at its correct position and so on, n times, where n is the length of array. We have chosen n to be the number of replacements since we have to shift all the elements of the array(which is n). But, there could be a problem with this method, if n%k=0. In this case, while picking up numbers to be placed at the correct position, we will eventually reach the number from which we originally started. Thus, in such a case, when we hit the original number’s index again, we start the same process with the number following it.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n和k互质，最小公倍数为nk,循环替换n次才会reach the number from which we originally started</span></span><br><span class="line"><span class="comment">// n和k不互质，中间会reach the number from which we originally started</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.size();</span><br><span class="line">    k=k%n;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(start=<span class="number">0</span>;count&lt;n;start++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cur_index=start;</span><br><span class="line">        <span class="keyword">int</span> cur_val=nums[start];</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> next_index=(cur_index+k)%n;<span class="comment">//下一个下标</span></span><br><span class="line">            <span class="keyword">int</span> tmp=nums[next_index];</span><br><span class="line">            nums[next_index]=cur_val;<span class="comment">//将上一个元素放到这个位置</span></span><br><span class="line">            <span class="comment">//更新pre,count,cur</span></span><br><span class="line">            cur_val=tmp;</span><br><span class="line">            cur_index=next_index;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">while</span>(start!=cur_index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rotate-image"><a href="#rotate-image" class="headerlink" title="rotate image"></a>rotate image</h3><p>You are given an <em>n</em> x <em>n</em> 2D matrix representing an image. Rotate the image by 90 degrees (clockwise).</p>
<p><strong>Note:</strong>  You have to rotate the image <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p>
<p><a href="https://leetcode.com/problems/rotate-image/" target="_blank" rel="noopener">https://leetcode.com/problems/rotate-image/</a></p>
<ul>
<li>not in place </li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; first row of source ------&gt; last column of destination</span><br><span class="line">&gt; second row of source ------&gt; last but-one column of destination</span><br><span class="line">&gt; so ... on</span><br><span class="line">&gt; last row of source ------&gt; first column of destination</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>in place</li>
</ul>
<blockquote>
<ol>
<li>Clockwise 90<ul>
<li>方法一  Find transpose of matrix. then reverse left to right</li>
<li>方法二 first reverse up to down, then transpose</li>
</ul>
</li>
<li>Anti clockwise 90<ul>
<li>方法一  Find transpose of matrix. then reverse up to down</li>
<li>方法二  first reverse left to right, then transpose</li>
</ul>
</li>
</ol>
<p>clockwise 180</p>
<ul>
<li>方法一  repeat clockwise 90 twice</li>
<li>方法二 first reverse up to down,  then reverse left to right</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * clockwise rotate</span></span><br><span class="line"><span class="comment"> * first reverse up to down, then swap the symmetry </span></span><br><span class="line"><span class="comment"> * 1 2 3     7 8 9     7 4 1</span></span><br><span class="line"><span class="comment"> * 4 5 6  =&gt; 4 5 6  =&gt; 8 5 2</span></span><br><span class="line"><span class="comment"> * 7 8 9     1 2 3     9 6 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">    reverse(matrix.begin(), matrix.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; matrix[i].size(); ++j)</span><br><span class="line">            swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * anticlockwise rotate</span></span><br><span class="line"><span class="comment"> * first reverse left to right, then swap the symmetry</span></span><br><span class="line"><span class="comment"> * 1 2 3     3 2 1     3 6 9</span></span><br><span class="line"><span class="comment"> * 4 5 6  =&gt; 6 5 4  =&gt; 2 5 8</span></span><br><span class="line"><span class="comment"> * 7 8 9     9 8 7     1 4 7</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">anti_rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> vi : matrix) reverse(vi.begin(), vi.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; matrix[i].size(); ++j)</span><br><span class="line">            swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h1><p><strong>二分的本质：性质的边界</strong></p>
<p>邓俊辉  数据结构</p>
<p>处置特殊情况应有语义约定（为了被其他部件调用），如有序向量的查找至少应该便于有序向量自身的维护</p>
<p>( v.insert(1+v.search(e),e) )</p>
<p>Search: 确定不大于e的最后一个元素</p>
<ul>
<li>[lo, hi)  e  尽量减少比较次数  保证base情况(1，2，3)问题能递减下去</li>
</ul>
<p>语义一： 若存在返回index, 若不存在返回-1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(hi-lo&gt;<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (hi+lo)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(e&lt;nums[mid])&#123; <span class="comment">// 判断条件要保证两种情况在数组长度为2，3时都能递减范围</span></span><br><span class="line">        hi = mid;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        lo = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[lo]==e? lo:<span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>语义二：确定不大于e的最后一个元素              lo) &lt;=e       [hi   &gt;e</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case 1 given k, find max(i,a[i]&lt;k)</span></span><br><span class="line"><span class="comment">// case 2 given k, find max(i,a[i]&lt;=k)</span></span><br><span class="line"><span class="comment">// case 3 given k, find min(i,a[i]&gt;k)</span></span><br><span class="line"><span class="comment">// case 4 given k, find min(i,a[i]&gt;=k)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.size();</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = n;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;h)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (h-l)/<span class="number">2</span> + l;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;k)&#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            h = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.size();</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = n;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;h)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (h-l)/<span class="number">2</span> + l;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;=k)&#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            h = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch3</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.size();</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = n;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;h)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (h-l)/<span class="number">2</span> + l;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;=k)&#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            h = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.size();</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = n;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;h)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (h-l)/<span class="number">2</span> + l;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;k)&#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            h = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分数二分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到x的三次方根, 注意，结果保留6位小数。</span></span><br><span class="line"><span class="keyword">double</span> lo = <span class="number">0</span>; hi = x;</span><br><span class="line"><span class="keyword">while</span>(hi - lo &gt; <span class="number">1e-8</span>)&#123;</span><br><span class="line">    <span class="keyword">double</span> mid = (hi+lo)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(mmid * mid * mid &gt;= x)&#123; </span><br><span class="line">        hi = mid;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        lo = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, lo);</span><br></pre></td></tr></table></figure>
<h2 id="二分搜索位置-单调"><a href="#二分搜索位置-单调" class="headerlink" title="二分搜索位置 (单调)"></a>二分搜索位置 (单调)</h2><h2 id="二分答案-（满足-不满足）"><a href="#二分答案-（满足-不满足）" class="headerlink" title="二分答案  （满足|不满足）"></a>二分答案  （满足|不满足）</h2><ul>
<li>二分答案的主要思想<ul>
<li>就是在答案的可能范围（区间）内二分枚举</li>
<li>并检查所穷举的答案是否符合题意。</li>
<li>可以将最优性问题（直接求解相对较难）</li>
<li>转化为可行性问题（答案是否符合题意相对容易）</li>
</ul>
</li>
<li>二分答案的适用范围（条件）<ul>
<li>二分答案当且仅当答案区间上下限确定且可行解满足区间单调性（若x是可行解，则在答案区间内x+1（也可能是x-1）也可行的时候）才可以使用。</li>
<li>一般也是求最优值问题</li>
<li>更多、更明显的标志是： “最大值最小化” 或者 “最小值最大化”</li>
</ul>
</li>
<li>如何检验当前的答案是否符合题目的要求（限制条件）？<ul>
<li>常见的方法：穷举、贪心、搜索、动态规划、图论、数据结构等</li>
</ul>
</li>
</ul>
<h3 id="最大值最小化-最小值最大化"><a href="#最大值最小化-最小值最大化" class="headerlink" title="最大值最小化/最小值最大化"></a>最大值最小化/最小值最大化</h3><p>Leetcode410</p>
<blockquote>
<p>Given an array which consists of non-negative integers and an integer <em>m</em>, you can split the array into <em>m</em> non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these <em>m</em> subarrays.</p>
<p><strong>Note:</strong><br>If <em>n</em> is the length of array, assume the following constraints are satisfied:</p>
<ul>
<li>1 ≤ <em>n</em> ≤ 1000</li>
<li>1 ≤ <em>m</em> ≤ min(50, <em>n</em>)</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minimize the largest sum among these m subarrays. </span></span><br><span class="line"><span class="comment">// 区间和的最大值 尽量小   </span></span><br><span class="line"><span class="comment">// 存在任何一种划分使得所有的区间和&lt;=k </span></span><br><span class="line"><span class="comment">// 区间和的范围 1, 2, 3, ..... ans-1, ans, ans+1, ..., sum </span></span><br><span class="line"><span class="comment">//            0  0  0          0     1     1           1 </span></span><br><span class="line"><span class="comment">// 找到&gt;0的最小值</span></span><br><span class="line"><span class="comment">// check 是否存在一种划分使得所有区间和&lt;=k</span></span><br><span class="line"><span class="comment">// 贪心，从左到右，每个区间和尽量接近k,且&lt;=k</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> m, <span class="keyword">long</span> <span class="keyword">long</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> curSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        curSum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(curSum &gt; k)&#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            curSum = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt ++;</span><br><span class="line">    <span class="keyword">return</span> cnt &lt;= m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i ++)&#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 二分答案 &lt;=0 &gt;0</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> lo = <span class="number">1</span>, hi = sum+<span class="number">1</span>; <span class="comment">// [lo,hi)</span></span><br><span class="line">    <span class="keyword">while</span>(lo&lt;hi)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mid = (hi + lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(!check(nums, m, mid))&#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(lo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Largest-Sum-of-Averages"><a href="#Largest-Sum-of-Averages" class="headerlink" title="Largest Sum of Averages"></a>Largest Sum of Averages</h3><p>Leetcode 813</p>
<blockquote>
<p>We partition a row of numbers <code>A</code> into at most <code>K</code> adjacent (non-empty) groups, then our score is the sum of the average of each group. What is the largest score we can achieve?</p>
<p>Note that our partition must use every number in A, and that scores are not necessarily integers.</p>
<p><strong>Note:</strong></p>
<ul>
<li><code>1 &lt;= A.length &lt;= 100</code>.</li>
<li><code>1 &lt;= A[i] &lt;= 10000</code>.</li>
<li><code>1 &lt;= K &lt;= A.length</code>.</li>
<li>Answers within <code>10^-6</code> of the correct answer will be accepted as correct.</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Median-of-two-sorted-arrays"><a href="#Median-of-two-sorted-arrays" class="headerlink" title="Median of two sorted arrays"></a>Median of two sorted arrays</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力 归并 O(n+m) </span></span><br><span class="line"><span class="comment">// 二分 O(log(n+m))</span></span><br><span class="line"><span class="comment">//  ----------++++++++            x            n-x   </span></span><br><span class="line"><span class="comment">//  --------++++++++++++++        half-x       m-(half-x)</span></span><br><span class="line"><span class="comment">// x: [0，n+1) 个数</span></span><br><span class="line"><span class="comment">// ------------------</span></span><br><span class="line"><span class="comment">// -+++++++++++++++++++</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// ---------------+++++++</span></span><br><span class="line"><span class="comment">// ----++++++++++++++++++++</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// +++++++++++++++++++++</span></span><br><span class="line"><span class="comment">// ---------------------</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// +++++++++++++++++++++</span></span><br><span class="line"><span class="comment">// -----------------------+++</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums1.size();</span><br><span class="line">    <span class="keyword">int</span> m = nums2.size();</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m) <span class="keyword">return</span> findMedianSortedArrays(nums2,nums1); <span class="comment">// 保证 n&lt;=m</span></span><br><span class="line">    <span class="keyword">int</span> half = (n+m+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo&lt;hi)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo+hi)/<span class="number">2</span>; <span class="comment">// len(left part of x)</span></span><br><span class="line">        <span class="keyword">int</span> leftx = mid<span class="number">-1</span>&lt;<span class="number">0</span>? INT_MIN:nums1[mid<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> lefty = half-mid<span class="number">-1</span>&lt;<span class="number">0</span> ? INT_MIN:nums2[half-mid<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> rightx = mid&gt;=n? INT_MAX:nums1[mid];</span><br><span class="line">        <span class="keyword">int</span> righty = half-mid&gt;=m? INT_MAX:nums2[half-mid];</span><br><span class="line">        <span class="comment">//cout&lt;&lt;mid&lt;&lt;" "&lt;&lt;leftx&lt;&lt;" "&lt;&lt;lefty&lt;&lt;" "&lt;&lt;rightx&lt;&lt;" "&lt;&lt;righty&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(max(leftx,lefty)&lt;=min(rightx,righty))&#123;</span><br><span class="line">            <span class="keyword">if</span>((n+m)%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">double</span>(max(leftx,lefty)+min(rightx,righty))/<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> max(leftx,lefty);</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(leftx&lt;righty)&#123;</span><br><span class="line">            lo = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            hi = mid; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="perfect-square"><a href="#perfect-square" class="headerlink" title="perfect square"></a>perfect square</h3><ul>
<li>A square number is 1+3+5+7+…,</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         num -= i;</span><br><span class="line">         i += <span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> num == <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>One thing to note is that we have to use <strong>long</strong> for mid to avoid <strong>mid*mid</strong> from overflow.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如何防止大数溢出</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> lo = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">long</span> hi = <span class="keyword">long</span>(num)+<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(hi-lo&gt;<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">long</span> mid = (lo+hi)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span>(num&lt;mid*mid) hi=mid;</span><br><span class="line">           <span class="keyword">else</span> lo=mid;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> (lo*lo==num)? <span class="literal">true</span>:<span class="literal">false</span>; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>And a third way is to use <strong>Newton Method</strong> to calculate the square root or num, refer to <a href="https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division" target="_blank" rel="noopener">Newton Method</a> for details.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> x = num;</span><br><span class="line">        <span class="keyword">while</span> (x * x &gt; num) &#123;</span><br><span class="line">            x = (x + num / x) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x * x == num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Smallest-good-base"><a href="#Smallest-good-base" class="headerlink" title="Smallest good base"></a>Smallest good base</h3><blockquote>
<p>For an integer n, we call k&gt;=2 a  <strong>good base</strong> of n, if all digits of n base k are 1.</p>
<p>Now given a string representing n, you should return the smallest good base of n in string format.</p>
<p><strong>Note:</strong></p>
<ol>
<li>The range of n is [3, 10^18].</li>
<li>The string representing n is always valid and will not have leading zeros.</li>
</ol>
</blockquote>
<p>按数学公式缩小搜索空间   注意整数存储类型   防止溢出</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6620351.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/6620351.html</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 + k + k^2 +... + k^(m-1) = (k^m -1)/(k-1) = n  </span></span><br><span class="line"><span class="comment">// 当n恒定时，k越小，m越大</span></span><br><span class="line"><span class="comment">// 由于k至少为2，n至少为3，那么肯定至少有两项，则 m&gt;=2。再来看m的上限该如何求？其实也不难，想要m最大，k就要最小，k最小是2，那么m最大只能为 log2(n + 1)</span></span><br><span class="line"><span class="comment">// n = 1 + k + k^2 + k^3 + ... + k^(m-1) &gt; k^(m-1) =&gt; k &lt; n^(1 / (m-1))</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">smallestGoodBase</span><span class="params">(<span class="built_in">string</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> num = stoll(n);</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">log</span>(num+<span class="number">1</span>)/<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m; i&gt;=<span class="number">2</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> left = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> right = <span class="built_in">pow</span>(num, <span class="number">1.0</span> / (i - <span class="number">1</span>))+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123; <span class="comment">//左闭右开</span></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                sum = sum * mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum == num) <span class="keyword">return</span> to_string(mid);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; num)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> to_string(num<span class="number">-1</span>);<span class="comment">// 当 k=n-1 时，一定能变成 11，所以实在找不到更小的情况下就返回 n-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a>Linked List</h1><h2 id="用数组模拟链表"><a href="#用数组模拟链表" class="headerlink" title="用数组模拟链表"></a>用数组模拟链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针+结构体  动态创建链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// new Node() 操作很慢</span></span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="comment">// 用数组模拟单链表：邻接表（存储树和图）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="comment">// dummyhead 表示头结点的下标:0</span></span><br><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针是多少 </span></span><br><span class="line"><span class="comment">// idx 存储当前已经用到了哪个点 </span></span><br><span class="line"><span class="keyword">int</span> dummyHead, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[<span class="number">0</span>]=<span class="number">0</span>; ne[<span class="number">0</span>]=<span class="number">-1</span>; dummyHead=<span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到头结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_head</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add(<span class="number">0</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_head_node</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    remove(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到下标是k的点后面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将下标是k的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"><span class="comment">// 用数组模拟双链表：用来优化某些问题</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"><span class="comment">// 0： dummyHead  1:dummyTail</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[<span class="number">0</span>]=<span class="number">0</span>, e[<span class="number">1</span>]=<span class="number">0</span>;  </span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>; </span><br><span class="line">    r[<span class="number">1</span>] = <span class="number">-1</span>, l[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a, r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x : insert(l[a],x)</span></span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链表总结：<a href="http://data2art.com/LinkedList.html" target="_blank" rel="noopener">http://data2art.com/LinkedList.html</a></p>
<h2 id="Floyd-Cycle-detection-algorithm"><a href="#Floyd-Cycle-detection-algorithm" class="headerlink" title="Floyd Cycle detection algorithm"></a>Floyd Cycle detection algorithm</h2><p><a href="https://cs.stackexchange.com/questions/10360/floyds-cycle-detection-algorithm-determining-the-starting-point-of-cycle" target="_blank" rel="noopener">https://cs.stackexchange.com/questions/10360/floyds-cycle-detection-algorithm-determining-the-starting-point-of-cycle</a></p>
<ul>
<li>Detecting start of a loop in singly linked list</li>
</ul>
<p>Meeting point, $𝑀=𝑥+𝑦+mL$</p>
<p>$2(𝑥+𝑦+mL)=𝑀+n𝐿$</p>
<p>Basically, distance travelled by the fast pointer is $𝑥+𝑦 $plus some multiple of loop length, 𝐿</p>
<p>$𝑥+𝑦=𝑘𝐿                        (k=n-m)$</p>
<p>$y=𝑘𝐿−x$ 必定有解</p>
<p>The above equation proves that  is the same as some multiple of loop length, 𝐿 minus 𝑦 So, if the fast pointer starts at the meeting point, 𝑀 or at 𝑥+𝑦(slow从head开始走，fast从meeting point开始走，速度均为1，因为meeting point和head到start of the loop的距离均为x), then it will end up at the start of the loop.</p>
<h3 id="Find-the-Duplicate-Number"><a href="#Find-the-Duplicate-Number" class="headerlink" title="Find the Duplicate Number"></a>Find the Duplicate Number</h3><p>leetcode 287</p>
<blockquote>
<p>Given an array <em>nums</em> containing <em>n</em> + 1 integers where each integer is between 1 and <em>n</em> (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<p><strong>Note:</strong></p>
<ol>
<li>You <strong>must not</strong> modify the array (assume the array is read only).</li>
<li>You must use only constant, <em>O</em>(1) extra space.</li>
<li>Your runtime complexity should be less than <em>O</em>(<em>n</em>^2).</li>
<li>There is only one duplicate number in the array, but it could be repeated more than once.</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组模拟链表</span></span><br><span class="line"><span class="comment">// Because each number in nums is between 1 and n, it will necessarily point to an index that exists. Therefore, the list can be traversed infinitely, which implies that there is a cycle. Additionally, because 00 cannot appear as a value in nums, nums[0] cannot be part of the cycle. Therefore, traversing the array in this manner from nums[0] is equivalent to traversing a cyclic linked list</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> fast=nums[nums[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">        slow=nums[slow];</span><br><span class="line">        fast=nums[nums[fast]];</span><br><span class="line">    &#125;</span><br><span class="line">    slow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">        slow=nums[slow];</span><br><span class="line">        fast=nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reverse-Linked-List-In-Place"><a href="#Reverse-Linked-List-In-Place" class="headerlink" title="Reverse Linked List  (In Place)"></a>Reverse Linked List  (In Place)</h2><p><a href="https://leetcode.com/problems/reverse-linked-list/discuss/58130/C%2B%2B-Iterative-and-Recursive" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/discuss/58130/C%2B%2B-Iterative-and-Recursive</a></p>
<p>先创建p节点,后创建p-&gt;next所指向的节点</p>
<p>先创建p-&gt;next所指向的节点，后创建p节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iterative</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode* next = head -&gt; next;</span><br><span class="line">            head -&gt; next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//recursice</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !(head -&gt; next)) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* node = reverseList(head -&gt; next);</span><br><span class="line">        head -&gt; next -&gt; next = head;</span><br><span class="line">        head -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="栈-和-队列"><a href="#栈-和-队列" class="headerlink" title="栈 和 队列"></a>栈 和 队列</h1><h2 id="用数组模拟栈和队列"><a href="#用数组模拟栈和队列" class="headerlink" title="用数组模拟栈和队列"></a>用数组模拟栈和队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用STL容器实现</span></span><br><span class="line">----------------------------</span><br><span class="line"><span class="comment">// 用数组模拟栈</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[N], tt;</span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"><span class="comment">//弹出</span></span><br><span class="line">tt--;</span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span>(tt&gt;<span class="number">0</span>)  <span class="keyword">not</span> empty</span><br><span class="line"><span class="keyword">else</span> empty</span><br><span class="line"><span class="comment">//栈顶</span></span><br><span class="line">stk[tt];</span><br><span class="line">--------------------------------</span><br><span class="line"><span class="comment">// 用数组模拟队列</span></span><br><span class="line"><span class="comment">// 在队尾插入元素，在队头弹出元素</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">q[++ tt] = x;</span><br><span class="line"><span class="comment">// 弹出</span></span><br><span class="line">hh ++;</span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span>(hh&lt;=tt) <span class="keyword">not</span> empty</span><br><span class="line"><span class="keyword">else</span> empty</span><br><span class="line"><span class="comment">// 取出队头元素</span></span><br><span class="line">q[hh];</span><br></pre></td></tr></table></figure>
<h2 id="单调栈和单调队列"><a href="#单调栈和单调队列" class="headerlink" title="单调栈和单调队列"></a>单调栈和单调队列</h2><p><strong>单调栈解决的是以某个值为最小（最大）值的最大区间</strong></p>
<p><strong>单调队列解决的是区间最小（最大）值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调栈： 给定一个序列，找到这个序列中每一个数的左边离它最近的且比它小(大)的数-&gt; 找当前元素即将入栈时的栈顶元素; </span></span><br><span class="line"><span class="comment">// 给定一个序列，找到这个序列中每一个数的左边离它最近的且比它小(大)的数和右边离他最最近的且比它小(大)的数 -&gt; 栈顶元素出栈时，可确定栈顶下面一个元素一定是它左边第一个比栈顶小的元素，当前元素一定是右边第一个小于等于栈顶的元素。</span></span><br><span class="line"><span class="comment">// 序列： 3  4  2 7 5</span></span><br><span class="line"><span class="comment">//      -1  3 -1 2 2</span></span><br><span class="line"><span class="comment">// 暴力 循环  对每一个元素向左遍历之前的元素 (0,1,2,..., i-1) &lt;- i    O(N2)</span></span><br><span class="line"><span class="comment">//              若j&lt;k &amp;&amp; a[j]&gt;=a[k] 则肯定不会是第j个元素，把这些没用的元素删掉会得到单调性</span></span><br><span class="line"><span class="comment">// 单调递增栈：从栈底到栈顶单调递增，当新来一个元素比栈顶元素大or栈为空，则直接将该元素入栈；当新来一个元素比栈顶元素的小，则递归的将栈顶元素出栈直到栈顶元素小于该元素或栈为空，再将该元素入栈</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[N], tt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// 若循环内用cin读取输入，可开启ios::sync_stdio(false);加速</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        <span class="keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= x) tt -- ;</span><br><span class="line">        <span class="keyword">if</span> (!tt) <span class="built_in">printf</span>(<span class="string">"-1 "</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>, stk[tt]);</span><br><span class="line">        stk[ ++ tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单调队列  </span></span><br><span class="line"><span class="comment">// 求滑动窗口中的最小值(最大值)</span></span><br><span class="line"><span class="comment">// 1 3 -1 -3 5 3 6 7</span></span><br><span class="line"><span class="comment">// 3 -1 -3 </span></span><br><span class="line"><span class="comment">//  暴力  维护队列 每次计算队列内部最值     O(NK)</span></span><br><span class="line"><span class="comment">// 只要当-3进入队列，队列中的3，-1一定没用，因此可以删除，把这些没用的元素删掉会得到单调性</span></span><br><span class="line"><span class="comment">// 单调队列队头对应的即为窗口的最小值  (存储下标)</span></span><br><span class="line"><span class="comment">// 出队时，判断单调队列队头是否被弹出</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], q[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh ++ ; <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt -- ;</span><br><span class="line">        q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><h4 id="Largest-Rectangle-in-Histogram"><a href="#Largest-Rectangle-in-Histogram" class="headerlink" title="Largest Rectangle in Histogram"></a>Largest Rectangle in Histogram</h4><p>Given <em>n</em> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p>方法一： 暴力枚举起始点  one by one consider all bars as starting points and calculate area of all rectangles starting with every bar. Finally return maximum of all possible areas. Time complexity of this solution would be O(n^2).</p>
<p>方法二：<a href="https://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/</a></p>
<p> 分治 We can use <strong>Divide and Conquer</strong> to solve this in O(nLogn) time. The idea is to find the minimum value in the given array. Once we have index of the minimum value, the max area is maximum of following three values. <strong>a)</strong> Maximum area in left side of minimum value (Not including the min value) <strong>b)</strong> Maximum area in right side of minimum value (Not including the min value) <strong>c)</strong> Number of bars multiplied by minimum value.</p>
<p>The areas in left and right of minimum value bar can be calculated recursively. If we use linear search to find the minimum value, then the worst case time complexity of this algorithm becomes O(n^2). In worst case, we always have (n-1) elements in one side and 0 elements in other side and if the finding minimum takes O(n) time, we get the recurrence similar to worst case of Quick Sort. How to find the minimum efficiently? <a href="https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/" target="_blank" rel="noopener">Range Minimum Query using Segment Tree</a> can be used for this. We build segment tree of the given histogram heights. Once the segment tree is built, all <a href="https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/" target="_blank" rel="noopener">range minimum queries take O(Logn) time</a>. So over all complexity of the algorithm becomes.</p>
<p>Overall Time = Time to build Segment Tree + Time to recursively find maximum area</p>
<p><a href="https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/" target="_blank" rel="noopener">Time to build segment tree is O(n)</a>. Let the time to recursively find max area be T(n). It can be written as following.<br>T(n) = O(Logn) + T(n-1)<br>The solution of above recurrence is O(nLogn). So overall time is O(n) + O(nLogn) which is O(nLogn).</p>
<p>方法三： <a href="https://www.geeksforgeeks.org/largest-rectangle-under-histogram/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/largest-rectangle-under-histogram/</a>  单调栈</p>
<p>For every bar ‘x’, we calculate the area with ‘x’ as the smallest bar in the rectangle. If we calculate such area for every bar ‘x’ and find the maximum of all areas, our task is done. How to calculate area with ‘x’ as smallest bar? We need to know index of the first smaller (smaller than ‘x’) bar on left of ‘x’ and index of first smaller bar on right of ‘x’. Let us call these indexes as ‘left index’ and ‘right index’ respectively.</p>
<p>We traverse all bars from left to right, maintain a stack of bars. Every bar is pushed to stack once. A bar is popped from stack when a bar of smaller height is seen. When a bar is popped, we calculate the area with the popped bar as smallest bar. How do we get left and right indexes of the popped bar – the current index tells us the ‘right index’ and index of previous item in stack is the ‘left index’. Following is the complete algorithm.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前点作为区间最小值能扩展的矩形</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(heights.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        heights.push_back(<span class="number">0</span>); <span class="comment">// to pop all th bars</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st; <span class="comment">// 需要知道左右边界的位置-&gt;存储坐标</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;heights.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.empty() <span class="keyword">and</span> heights[st.top()]&gt;=heights[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> top = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">int</span> leftIndex = st.empty()? <span class="number">0</span>: st.top()+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> rightIndex = i<span class="number">-1</span>;</span><br><span class="line">                res = max(res,(rightIndex-leftIndex+<span class="number">1</span>)*heights[top]);</span><br><span class="line">                <span class="comment">//cout&lt;&lt;top&lt;&lt;" "&lt;&lt;res&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Trapping-Rain-Water"><a href="#Trapping-Rain-Water" class="headerlink" title="Trapping Rain Water"></a>Trapping Rain Water</h4><p>Given <em>n</em> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p> <a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">https://leetcode.com/problems/trapping-rain-water/</a></p>
<p>方法一: 动态规划求出当前点的左边最大值和右边最大值</p>
<p>方法二： 单调栈</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前点作为区间最大值能装下的水</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(height.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;height.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty() <span class="keyword">and</span> height[st.top()]&lt;=height[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> top = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span>(st.empty()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> distance = i-st.top()<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;top&lt;&lt;" "&lt;&lt;height[top]&lt;&lt;endl;</span></span><br><span class="line">            res += (min(height[i],height[st.top()])-height[top])*distance;</span><br><span class="line">        &#125;</span><br><span class="line">        st.push(i);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;i&lt;&lt;" "&lt;&lt;st.size()&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Sum-of-Subarray-Minimums-Maximums"><a href="#Sum-of-Subarray-Minimums-Maximums" class="headerlink" title="Sum of Subarray Minimums/Maximums"></a>Sum of Subarray Minimums/Maximums</h4><p>Hulu码率  </p>
<blockquote>
<p>hulu 有一系列的视频文件，每个文件都有对应的码率，为整数，输入长度为n的视频码率数组arr,现在定义两个文件区段之间的最大码率为：$p[i][j] = max(arr[i], arr[i+1],…,arr[j]), 0&lt;=i&lt;=j&lt;=n-1$</p>
<p>针对所有满足条件的$ 0&lt;=i&lt;=j&lt;=n-1$的$(i,j$)对, 求$p[i][j]$的总和(%1000000000007)</p>
</blockquote>
<p><strong>考虑点：如果以当前点作为区间最大点，哪些区间符合？这些区间可以为区间的全集？</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nums.push_back(INT_MAX); <span class="comment">// 使得所有点都会被pop</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">st.push(<span class="number">-1</span>); <span class="comment">// 保证栈里至少有一个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(st.size()&gt;<span class="number">1</span> <span class="keyword">and</span> nums[st.top()]&lt;=nums[i])&#123; <span class="comment">//栈里有一个有效元素</span></span><br><span class="line">        <span class="keyword">int</span> mid = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        <span class="keyword">int</span> l = mid-st.top()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = i-mid<span class="number">-1</span>;</span><br><span class="line">        res = (res+nums[mid]*(l+r+l*r+<span class="number">1</span>))%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    st.push(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>leetcode 907 Sum of Subarray Minimums</p>
<h4 id="叶值的最小代价生成树"><a href="#叶值的最小代价生成树" class="headerlink" title="叶值的最小代价生成树"></a>叶值的最小代价生成树</h4><p>Leetcode 1130</p>
<blockquote>
<p>给你一个正整数数组 arr，考虑所有满足以下条件的二叉树：</p>
<p>每个节点都有 0 个或是 2 个子节点。<br>数组 arr 中的值与树的中序遍历中每个叶节点的值一一对应。（知识回顾：如果一个节点有 0 个子节点，那么该节点为叶节点。）<br>每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。<br>在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个 32 位整数。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果不考虑叶子节点的顺序</span></span><br><span class="line"><span class="comment">// 代价为两数乘积，合并节点为大值数  (代价为两数和，合并节点为两数和，huffman,合并果子)</span></span><br><span class="line">A.sort();</span><br><span class="line"><span class="keyword">for</span>()&#123;</span><br><span class="line">    res += A[i]*A[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">A = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">A = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span> ,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 考虑叶子节点顺序为树的中序遍历</span></span><br><span class="line"><span class="comment">// 每个节点与其最近的大值数合并  单调栈</span></span><br><span class="line"><span class="keyword">int</span> mctFromLeafValues(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr) &#123;</span><br><span class="line">    arr.push_back(INT_MAX);</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty() <span class="keyword">and</span> st.top()&lt;= arr[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> u = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">int</span> v = arr[i];</span><br><span class="line">            <span class="keyword">if</span>(!st.empty()) v = min(v, st.top());</span><br><span class="line">            <span class="keyword">if</span>(v != INT_MAX) res += v*u;</span><br><span class="line">        &#125;</span><br><span class="line">        st.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="132-pattern"><a href="#132-pattern" class="headerlink" title="132 pattern"></a>132 pattern</h4><p>Leetcode 456</p>
<blockquote>
<p>给定一个整数序列 a1,a2,…,an，132模式是a的子序列 ai,aj,ak，满足 i&lt;j&lt;k，并且 ai&lt;ak&lt;aj。设计一个算法，读入n个整数的数字序列，判断是否存在132模式。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right_min(n, INT_MAX);</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!st.empty() &amp;&amp; nums[i] &gt; nums[st.top()]) &#123;</span><br><span class="line">            right_min[i] = nums[st.top()];</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        st.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left_min = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; left_min)</span><br><span class="line">            left_min = nums[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (left_min &lt; right_min[i] &amp;&amp; right_min[i] &lt; nums[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><h3 id="max-sliding-window"><a href="#max-sliding-window" class="headerlink" title="max sliding window"></a>max sliding window</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调队列</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!q.empty() &amp;&amp; i-k+<span class="number">1</span>&gt;q.front()) q.pop_front(); <span class="comment">// 出队</span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty() &amp;&amp; nums[q.back()]&lt;nums[i]) q.pop_back();</span><br><span class="line">        q.push_back(i); <span class="comment">// 入队</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>) res.push_back(nums[q.front()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>木桶问题： 在solution空间二分      单调队列</p>
<h3 id="最大子序和-长度不超过M"><a href="#最大子序和-长度不超过M" class="headerlink" title="最大子序和(长度不超过M)"></a>最大子序和(长度不超过M)</h3><blockquote>
<p>输入一个长度为n的整数序列，从中找出一段长度不超过M的连续子序列，使得整个序列的和最大</p>
</blockquote>
<p>求区间和问题就相当于找前缀和的最大差值，在这道问题中，原问题就可以转换为找到两个位置x，y，使得sum[y]-sum[x]最大并且y-x≤m。 我们一重循环枚举右端点x，那么问题就转化为：找到左端点j，j∈[i-m,i-1]且sum[j]最小。=&gt; max sliding window</p>
<h3 id="Shortest-Subarray-with-Sum-at-Least-K"><a href="#Shortest-Subarray-with-Sum-at-Least-K" class="headerlink" title="Shortest Subarray with Sum at Least K"></a>Shortest Subarray with Sum at Least K</h3><p>leetcode 862</p>
<blockquote>
<p>Return the <strong>length</strong> of the shortest, non-empty, contiguous subarray of <code>A</code> with sum at least <code>K</code>.</p>
<p>If there is no non-empty subarray with sum at least <code>K</code>, return <code>-1</code>.</p>
</blockquote>
<p>Calculate prefix sum <code>B</code> of list <code>A</code>. <code>B[j] - B[i]</code> represents the sum of subarray <code>A[i] ~ A[j-1]</code> Deque <code>d</code> will keep indexes of increasing <code>B[i]</code>. For every <code>B[i]</code>, we will compare <code>B[i] - B[d[0]]</code> with <code>K</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shortestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = A.size(), res = N + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) B[i + <span class="number">1</span>] = B[i] + A[i];</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (d.size() &gt; <span class="number">0</span> &amp;&amp; B[i] - B[d.front()] &gt;= K)</span><br><span class="line">            res = min(res, i - d.front()), d.pop_front();</span><br><span class="line">        <span class="keyword">while</span> (d.size() &gt; <span class="number">0</span> &amp;&amp; B[i] &lt;= B[d.back()]) d.pop_back();</span><br><span class="line">        d.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res &lt;= N ? res : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="迭代与递归"><a href="#迭代与递归" class="headerlink" title="迭代与递归"></a>迭代与递归</h1><p>迭代：时间复杂度（级数求和）</p>
<p>算数级数：与末项平方同阶 $T(n)=1+2+…+n=n(n+1)/2=O(n^2)$</p>
<p>幂方级数：比幂次高出一阶（积分）</p>
<p>$T_2(n)=1^2+2^2+…n^2=O(n^3)$</p>
<p>$T_3(n)=1^3+2^3+…n^3=O(n^4)$</p>
<p>几何级数：与末项同阶 $T(n)=a_0(1+q+…+q^n)=a_0(q^n-1)/(q-1)$</p>
<p>收敛级数：O(1)</p>
<p>调和级数：$1+1/2+1/3+…+1/n=\theta(logn)$</p>
<p>对数级数：$log1+log2+…+logn=log(n!)=\theta(nlogn)$</p>
<h2 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h2><p>如下图所示，从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间只有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数</p>
<p><img src="https://images2015.cnblogs.com/blog/1026866/201610/1026866-20161016022859889-2055402664.jpg" alt="img"></p>
<p>实现这个算法可以简单分为三个步骤：</p>
<p>　　　　（1）     把n-1个盘子由A 移到 B；</p>
<p>　　　　（2）     把第n个盘子由 A移到 C；</p>
<p>　　　　（3）     把n-1个盘子由B 移到 C；</p>
<p>$H(n) = 1+2H(n-1) = 1+2+4H(n-2) = 1+2+4+8H(n-3)  = …. = 1+2+4+….+ 2^{n-1}  = 2^{n}-1$</p>
<h2 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h2><p><a href="https://cloud.tencent.com/developer/article/1164728" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1164728</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/35487124" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35487124</a></p>
<blockquote>
<p>设有编号为1，2，……，n的n(n&gt;0)个人围成一个圈，从第1个人开始报数，报到m时停止报数，报m的人出圈，再从他的下一个人起重新报数，报到m时停止报数，报m的出圈，……，如此下去，直到所有人全部出圈为止。当任意给定n和m后，复现这个过程（各成员的离席次序），或者求最后一个在座的成员编号。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列模拟</span></span><br><span class="line"><span class="comment">// 首先所有人入队，队头报数，(&lt;m)，从队头移到队尾； (==m)从队列中移除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用递归求得最后一个在座的成员编号</span></span><br><span class="line"><span class="comment">//   0     1       ... (m-2)%n,(m-1)%n,m%n,..., n-2, n-1</span></span><br><span class="line"><span class="comment">//   0     1       ... (m-2)%n,       ,m%n,..., n-2, n-1</span></span><br><span class="line"><span class="comment">//   n-m%n n-m%n+1 ...   n-2,         ,0,...,n-2-m%n,n-1-m%n</span></span><br><span class="line"><span class="comment">// F(1) = 0  |  F(n) = [F(n - 1) + m] % n      (n&gt;1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">josephus</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> <span class="comment">// 递推</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == n)</span><br><span class="line">  n<span class="number">-2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (josephus(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">josephus</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> <span class="comment">//循环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> out = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        out = (out + m) % i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表-递归-非递归"><a href="#链表-递归-非递归" class="headerlink" title="链表  递归  非递归"></a>链表  递归  非递归</h2><h2 id="树-递归-非递归"><a href="#树-递归-非递归" class="headerlink" title="树  递归  非递归"></a>树  递归  非递归</h2><h4 id="Binary-Tree-Upside-Down"><a href="#Binary-Tree-Upside-Down" class="headerlink" title="Binary Tree Upside Down"></a>Binary Tree Upside Down</h4><h4 id="Increasing-Order-Search-Tree"><a href="#Increasing-Order-Search-Tree" class="headerlink" title="Increasing Order Search Tree"></a>Increasing Order Search Tree</h4><blockquote>
<p>Given a tree, rearrange the tree in <strong>in-order</strong> so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child.</p>
</blockquote>
<p>leetcode 897</p>
<p>Straigh forward idea:<br><code>res = inorder(root.left) + root + inorder(root.right)</code></p>
<p>Several tips here:</p>
<ol>
<li>I pass a tail part to the function, so it can link it to the last node.<br>This operation takes <code>O(1)</code>, instead of <code>O(N)</code>.<br>Otherwise the whole time complexity will be <code>O(N^2)</code>.</li>
<li>Also, remember to set <code>root.left = null</code>.<br>Otherwise it will be TLE for Leetcode to traverse your tree.</li>
<li>Should arrange the old tree, not create a new tree.<br>The judgement won’t take it as wrong answer, but it is.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">increasingBST</span><span class="params">(TreeNode* root, TreeNode* tail = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> tail;</span><br><span class="line">    TreeNode* res = increasingBST(root-&gt;left, root);</span><br><span class="line">    root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    root-&gt;right = increasingBST(root-&gt;right, tail);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>哈希表的存储结构：开放寻址法，拉链法</p>
<h2 id="模拟哈希"><a href="#模拟哈希" class="headerlink" title="模拟哈希"></a>模拟哈希</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护一个集合，支持如下几种操作：</span></span><br><span class="line"><span class="comment">// “I x”，插入一个数x；</span></span><br><span class="line"><span class="comment">// “Q x”，询问数x是否在集合中出现过；</span></span><br><span class="line"><span class="comment">// 现在要进行N次操作，对于每个询问操作输出对应的结果</span></span><br><span class="line"><span class="comment">// 1≤N≤10^5  −10^9≤x≤10^9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拉链法</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100003</span>;<span class="comment">// 100003为大于100000的第一个质数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N; <span class="comment">// 防止出现负数</span></span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h); <span class="comment">// 初始化h, -1表示空指针</span></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">insert(x);</span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="keyword">if</span>(find(x))</span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line"><span class="comment">// 开放寻址法</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200003</span>, null = <span class="number">0x3f3f3f3f</span>;<span class="comment">// 根据经验开到题目数据范围的2-3倍，200003为大于200000的第一个质数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果x在哈希表中存在返回其在哈希表中的位置，否则返回x应该存储的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        t ++ ;</span><br><span class="line">        <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">h[find(x)] = x; </span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="keyword">if</span>(h[find(x)] == null)</span><br></pre></td></tr></table></figure>
<p>0x3f3f3f3f: 无穷大   0xcfcfcfcf:无穷小</p>
<blockquote>
<p>0x3f3f3f3f的十进制是1061109567，也就是10^9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。</p>
<p>另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷大”），事实上0x3f3f3f3f+0x3f3f3f3f=2122219134，这非常大但却没有超过32-bit int的表示范围，所以0x3f3f3f3f还满足了我们“无穷大加无穷大还是无穷大”的需求。</p>
<p>最后，0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的初始化），就不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），我们知道这是因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0，现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。</p>
</blockquote>
<p><a href="https://blog.csdn.net/tcherry/article/details/37606277" target="_blank" rel="noopener">https://blog.csdn.net/tcherry/article/details/37606277</a></p>
<h1 id="String-1"><a href="#String-1" class="headerlink" title="String"></a>String</h1><p><strong>如果不是一个字符一个字符的处理，采用python语言</strong></p>
<h2 id="strStr"><a href="#strStr" class="headerlink" title="strStr()"></a>strStr()</h2><h3 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h3><p>$O(NM)​$：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="built_in">string</span> &amp; p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">int</span> m = p.size();</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;=n-m; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;m <span class="keyword">and</span> s[i+j]==p[j]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j==m)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到所有下标</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; strStr2(<span class="built_in">string</span>&amp; s, <span class="built_in">string</span> &amp; p)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">int</span> m = p.size();</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;=n-m; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;m <span class="keyword">and</span> s[i+j]==p[j]) j++；</span><br><span class="line">        <span class="keyword">if</span>(j==m)&#123;</span><br><span class="line">            res.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>$O(N+M)$:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="keyword">char</span> s[M], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求nex数组  next[i]等于P[1]...P[i]最长的相同真前后缀的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i ++ ) <span class="comment">// j为ne[i-1]</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// kmp j零下标匹配的为空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">        <span class="keyword">if</span> (j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, i - n); <span class="comment">// 输出所有出现位置的起始下标（下标从0开始计数）</span></span><br><span class="line">            j = ne[j];<span class="comment">// 完成一次匹配，j指向其最长的相同真前后缀，返回所有下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sliding-window-algorithm"><a href="#Sliding-window-algorithm" class="headerlink" title="Sliding window algorithm"></a>Sliding window algorithm</h2><ul>
<li>Sliding window algorithm (substring search problem)</li>
</ul>
<p><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/description/" target="_blank" rel="noopener">https://leetcode.com/problems/find-all-anagrams-in-a-string/description/</a></p>
<p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a></p>
<p><a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-window-substring/</a></p>
<p><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/" target="_blank" rel="noopener">https://leetcode.com/problems/substring-with-concatenation-of-all-words/</a></p>
<p><a href="https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/</a></p>
<p>模板： <a href="https://www.cnblogs.com/hygeia/p/6477177.html" target="_blank" rel="noopener">https://www.cnblogs.com/hygeia/p/6477177.html</a></p>
<p>搜索的substring长度固定： iterate i </p>
<p>搜索的substring长度不固定， iterate begin、end</p>
<p>哈希key有限： 动态维护hash/数组</p>
<p>哈希key无限：动态维护hash、count</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">slidingWindowTemplateByHarryChaoyangHe</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//init a collection or int value to save the result according the question.</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(t.length()&gt; s.length()) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//create a hashmap to save the Characters of the target substring.</span></span><br><span class="line">        <span class="comment">//(K, V) = (Character, Frequence of the Characters)</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : t.toCharArray())&#123;</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//maintain a counter to check whether match the target string.</span></span><br><span class="line">        <span class="keyword">int</span> counter = map.size();<span class="comment">//must be the map size, NOT the string size because the char may be duplicate.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Two Pointers: begin - left pointer of the window; end - right pointer of the window</span></span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//the length of the substring which match the target string.</span></span><br><span class="line">        <span class="keyword">int</span> len = Integer.MAX_VALUE; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//loop at the begining of the source string</span></span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(end);<span class="comment">//get a character</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>( map.containsKey(c) )&#123;</span><br><span class="line">                map.put(c, map.get(c)-<span class="number">1</span>);<span class="comment">// plus or minus one</span></span><br><span class="line">                <span class="keyword">if</span>(map.get(c) == <span class="number">0</span>) counter--;<span class="comment">//modify the counter according the requirement(different condition).</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//increase begin pointer to make it invalid/valid again</span></span><br><span class="line">            <span class="keyword">while</span>(counter == <span class="number">0</span> <span class="comment">/* counter condition. different question may have different condition */</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">char</span> tempc = s.charAt(begin);<span class="comment">//***be careful here: choose the char at begin pointer, NOT the end pointer</span></span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(tempc))&#123;</span><br><span class="line">                    map.put(tempc, map.get(tempc) + <span class="number">1</span>);<span class="comment">//plus or minus one</span></span><br><span class="line">                    <span class="keyword">if</span>(map.get(tempc) &gt; <span class="number">0</span>) counter++;<span class="comment">//modify the counter according the requirement(different condition).</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/* save / update(min/max) the result if find a target*/</span></span><br><span class="line">                <span class="comment">// result collections or result int value</span></span><br><span class="line">                </span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="string-hash"><a href="#string-hash" class="headerlink" title="string hash"></a>string hash</h2><p>字符串前缀哈希法</p>
<p><a href="https://blog.csdn.net/pengwill97/article/details/80879387" target="_blank" rel="noopener">https://blog.csdn.net/pengwill97/article/details/80879387</a></p>
<p>给定一个字符串$S=s_1s_2s_3..s_n$，对字母x，我们规定$idx(x)=x−′a′+1$（当然也可以直接用$s_i$的ASCII值）</p>
<h3 id="自然溢出"><a href="#自然溢出" class="headerlink" title="自然溢出"></a>自然溢出</h3><p>unsigned long long Hash[n]</p>
<p>$hash[i]=hash[i−1]∗p+id(s[i])$</p>
<p>利用unsigned long long的范围自然溢出，相当于自动对$2^{64}$取模</p>
<blockquote>
<p>经验值： p = 131 or 13331  mod = 2^64</p>
</blockquote>
<h3 id="单Hash方法"><a href="#单Hash方法" class="headerlink" title="单Hash方法"></a>单Hash方法</h3><p>$hash[i]=(hash[i−1])∗p+idx(s[i])  \%  mod$<br>其中p和mod均为质数，且有p&lt;mod</p>
<p>对于此种Hash方法，将p和mod尽量取大即可，这种情况下，冲突的概率是很低的</p>
<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>若已知一个|S|=n 的字符串的hash值，hash[i],1≤i≤n，其子串$s_l..s_r,1≤l≤r≤n$对应的hash值为：</p>
<p>$hash=hash[r]−hash[l−1]∗p^{r−l+1}$</p>
<blockquote>
<p>1  2 …. l-1 l ……r</p>
<p>hash[r]   p^{r-1} </p>
<p>hash[l-1]   p^{l-2}   对齐到hash[r]  hash[l-1]*p^{r-l+1}</p>
</blockquote>
<p>考虑到hash[i]每次对p取模，进一步得到：$hash=(hash[r]−hash[l−1]∗p^{r−l+1})\%mod$</p>
<p>看起来这个式子人畜无害，但是对于取模运算要谨慎再谨慎，注意到括号里面是减法，即有可能是负数，故做如下的修正：$hash=((hash[r]−hash[l−1]∗p^{r−l+1})\%mod+mod)\%mod$</p>
<p>至此得到求子串hash值公式。</p>
<p>值得一提的是，如果需要反复对子串求解hash值，预处理p的n次方效果更佳。</p>
<h3 id="Hash素数的选取"><a href="#Hash素数的选取" class="headerlink" title="Hash素数的选取"></a>Hash素数的选取</h3><p>为了防止冲突，要选择合适的素数，像1e9+7,1e9+9的一些素数，出题人一般会卡一下下，所以尽量选择其他的素数，防止被卡。下面是一些可供选择的素数。 </p>
<p><a href="https://leetcode.com/problems/group-anagrams/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/group-anagrams/submissions/</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定一个长度为n的字符串，再给定m个询问，每个询问包含四个整数l1,r1,l2,r2，请你判断[l1,r1]和[l2,r2]这两个区间所包含的字符串子串是否完全相同。 字符串中只包含大小写英文字母和数字。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, P = <span class="number">131</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line">ULL h[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l1, r1, l2, r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (get(l1, r1) == get(l2, r2)) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串转化"><a href="#字符串转化" class="headerlink" title="字符串转化"></a>字符串转化</h2><p>Leetcode1153</p>
<blockquote>
<p>给出两个长度相同的字符串，分别是 str1 和 str2。请你帮忙判断字符串 str1 能不能在 零次 或 多次 转化后变成字符串 str2。</p>
<p>每一次转化时，将会一次性将 str1 中出现的 所有 相同字母变成其他任何小写英文字母。</p>
<p>只有在字符串 str1 能够通过上述方式顺利转化为字符串 str2 时才能返回 True，否则返回 False。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canConvert</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str1 == str2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> n1 = str1.size();</span><br><span class="line">    <span class="keyword">int</span> n2 = str2.size();</span><br><span class="line">    <span class="keyword">if</span>(n1!=n2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; table;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n2; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(table.count(str1[i]) <span class="keyword">and</span> table[str1[i]]!=str2[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        table[str1[i]] = str2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">set</span>(str2.begin(), str2.end()).size() &lt; <span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc -&gt; baa</span></span><br><span class="line"><span class="comment">// 先转换为对应模式 abc-&gt;abb (a,b-&gt;b,a问题) -&gt;cbb-&gt;caa-&gt;baa</span></span><br><span class="line"><span class="comment">// a,b -&gt; b,a (tmp=a, a=b, b=tmp)</span></span><br><span class="line"><span class="comment">// 循环移位 a,b,c-&gt;b,c,a (tmp=a, a=b, b=c, c=tmp)</span></span><br></pre></td></tr></table></figure>
<h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><p>递归！！！！ 节点和它的子树</p>
<p>递归时会有栈的空间复杂度</p>
<p>递归前对节点进行操作，并将操作的结果传给子树：自上向下</p>
<p>递归后利用子树传递的结果对节点进行操作：自下向上</p>
<p>树的分析： 完全平衡 $T(n) = aT(n/b) + f(n)$（主方法） 完全不平衡 $T(n) = T(n-1) + f(n)$（退化为array）</p>
<p>当f(n) = 1时，$T(n)=1$,即为遍历树的时间</p>
<h2 id="Balanced-Binary-Tree"><a href="#Balanced-Binary-Tree" class="headerlink" title="Balanced Binary Tree"></a>Balanced Binary Tree</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bfs</span></span><br><span class="line"><span class="comment">// 平衡二叉树的定义1：最深叶子节点和最浅叶子节点，深度差不超过1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    Node* left, right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_balance</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;Node*, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> dmin = INT_MAX, dmax = <span class="number">0</span>;</span><br><span class="line">    q.push(make_pair(root,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">auto</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        Node* u = now.first;</span><br><span class="line">        <span class="keyword">int</span> d = now.second;</span><br><span class="line">        <span class="keyword">if</span>(u-&gt;left) q.push(make_pair(u-&gt;left,d+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(u-&gt;right) q.push(make_pair(u-&gt;right,d+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(!u-&gt;left <span class="keyword">and</span> !u-&gt;right)&#123;<span class="comment">//叶子节点</span></span><br><span class="line">            dmin = min(dmin,d);</span><br><span class="line">            dmax = max(dmax,d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dmax-dmin&lt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平衡二叉树的定义2: a binary tree in which the depth of the two subtrees of every node never differ by more than 1. </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> balance(root)!=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回值包含信息：当前子树深度以及当前子树是否为平衡二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">balance</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = balance(node-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> r = balance(node-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(l!=<span class="number">-1</span> &amp;&amp; r!=<span class="number">-1</span> &amp;&amp; <span class="built_in">abs</span>(l-r)&lt;=<span class="number">1</span>) <span class="keyword">return</span> max(l,r)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCA-Lowest-Common-Ancestor"><a href="#LCA-Lowest-Common-Ancestor" class="headerlink" title="LCA(Lowest Common Ancestor)"></a>LCA(Lowest Common Ancestor)</h2><h3 id="LCA-在线算法"><a href="#LCA-在线算法" class="headerlink" title="LCA 在线算法"></a>LCA 在线算法</h3><p><a href="https://blog.csdn.net/hackbuteer1/article/details/8022138" target="_blank" rel="noopener">https://blog.csdn.net/hackbuteer1/article/details/8022138</a></p>
<blockquote>
<p> 情况一：root未知，但是每个节点都有parent指针</p>
<p>此时可以分别从两个节点开始，沿着parent指针走向根节点，得到两个链表，然后求两个链表的第一个公共节点，这个方法很简单，不需要详细解释的。</p>
<p> 情况二：节点只有左、右指针，没有parent指针，root已知</p>
<p>思路：有两种情况，一是要找的这两个节点（a, b），在要遍历的节点（root）的两侧，那么这个节点就是这两个节点的最近公共父节点；</p>
<p>二是两个节点在同一侧，则 root-&gt;left 或者 root-&gt;right 为 NULL，另一边返回a或者b。那么另一边返回的就是他们的最小公共父节点。</p>
<p>递归有两个出口，一是没有找到a或者b，则返回NULL；二是只要碰到a或者b，就立刻返回。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">findLca</span><span class="params">(TreeNode* root , TreeNode* p , TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">	TreeNode* left = findLca(root-&gt;left , p , q);</span><br><span class="line">	TreeNode* right = findLca(root-&gt;right , p , q);</span><br><span class="line">	<span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">	<span class="keyword">return</span> left ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如需N 次查询，则总体复杂度会扩大N 倍，故这种暴力解法仅适合一次查询，不适合多次查询。</p>
<p>总体来说，由于可以把LCA问题看成是询问式的，即给出一系列询问，程序对每一个询问尽快做出反应。故处理这类问题一般有两种解决方法：</p>
<ul>
<li>一种是在线算法，相当于循序渐进处理；</li>
<li>另外一种则是离线算法，如Tarjan算法，相当于一次性批量处理，一开始就知道了全部查询，只待询问。</li>
</ul>
<h3 id="二叉搜索树的最近公共父节点"><a href="#二叉搜索树的最近公共父节点" class="headerlink" title="二叉搜索树的最近公共父节点"></a>二叉搜索树的最近公共父节点</h3><p>Lowest Common Ancestor of a <strong>Binary Search Tree</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//递归</span><br><span class="line">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==NULL) <span class="keyword">return</span> NULL;</span><br><span class="line">        if((p-&gt;val-root-&gt;val)*(q-&gt;val-root-&gt;val)&lt;=0) return root;</span><br><span class="line">        else if(p-&gt;val-root-&gt;val&lt;0) return lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">        else return lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//循环</span><br><span class="line">TreeNode* findLowestCommonAncestor(TreeNode* root , TreeNode* a , TreeNode* b)</span><br><span class="line">&#123;</span><br><span class="line">	char min  , max;</span><br><span class="line">	if(a-&gt;val &lt; b-&gt;val)</span><br><span class="line">		min = a-&gt;val , max = b-&gt;val;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		min = b-&gt;val , max = a-&gt;val;</span><br><span class="line">	<span class="keyword">while</span>(root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(root-&gt;val &gt;= min &amp;&amp; root-&gt;val &lt;= max)</span><br><span class="line">			<span class="keyword">return</span> root;</span><br><span class="line">		else if(root-&gt;val &lt; min)</span><br><span class="line">			root = root-&gt;right;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			root = root-&gt;left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最深叶节点的最近公共父节点"><a href="#最深叶节点的最近公共父节点" class="headerlink" title="最深叶节点的最近公共父节点"></a>最深叶节点的最近公共父节点</h3><blockquote>
<p>给你一个有根节点的二叉树，找到它最深的叶节点的最近公共祖先</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;TreeNode*, <span class="keyword">int</span>&gt; dfs(TreeNode* root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> &#123;<span class="literal">NULL</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    pair&lt;TreeNode*, <span class="keyword">int</span>&gt; pl = dfs(root-&gt;left);</span><br><span class="line">    pair&lt;TreeNode*, <span class="keyword">int</span>&gt; pr = dfs(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(pl.second&lt;pr.second)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;pr.first,pr.second+<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pl.second&gt;pr.second)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;pl.first, pl.second+<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;root,pr.second+<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">lcaDeepestLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(root).first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完全二叉树的最近公共父节点"><a href="#完全二叉树的最近公共父节点" class="headerlink" title="完全二叉树的最近公共父节点"></a>完全二叉树的最近公共父节点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b) a&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br></pre></td></tr></table></figure>
<h1 id="堆-优先队列"><a href="#堆-优先队列" class="headerlink" title="堆 优先队列"></a>堆 优先队列</h1><h2 id="用数组模拟堆"><a href="#用数组模拟堆" class="headerlink" title="用数组模拟堆"></a>用数组模拟堆</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一个数         heap[++size] = x; up(size);</span></span><br><span class="line"><span class="comment">// 求集合中的最小值    heap[1]</span></span><br><span class="line"><span class="comment">// 删除最小值         heap[1] = heap[size]; size--; down(1);</span></span><br><span class="line"><span class="comment">// 删除任意一个元素    heap[k] = heap[size]; size--; up(k); down(k);</span></span><br><span class="line"><span class="comment">// 修改任意一个元素    heap[k] = x; up(k); down(k);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆 完全二叉树， 除最后一层节点都是满的，最后一层节点从左到右排列</span></span><br><span class="line"><span class="comment">// 小根堆： 每个节点的值都 &lt;= 其左儿子和右儿子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="keyword">int</span> h[N], ph[N], hp[N], size, idx; <span class="comment">// idx表示共插入多少个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    swap(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    swap(hp[a], hp[b]);</span><br><span class="line">    swap(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(u, t);</span><br><span class="line">        down(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;h[i]);</span><br><span class="line">size = n; idx = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i; i -- ) down(i);</span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">size ++ ;</span><br><span class="line">idx ++ ;</span><br><span class="line">ph[idx] = size, hp[size] = idx;</span><br><span class="line">h[size] = x;</span><br><span class="line">up(size);</span><br><span class="line"><span class="comment">// 删除第k个插入的元素</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">k = ph[k];</span><br><span class="line">heap_swap(k, size);</span><br><span class="line">size -- ;</span><br><span class="line">up(k);</span><br><span class="line">down(k);</span><br><span class="line"><span class="comment">//删除第k个插入的元素</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;k, &amp;x);</span><br><span class="line">k = ph[k];</span><br><span class="line">h[k] = x;</span><br><span class="line">up(k);</span><br><span class="line">down(k);</span><br></pre></td></tr></table></figure>
<h2 id="merge-k-sorted-list"><a href="#merge-k-sorted-list" class="headerlink" title="merge k sorted list"></a>merge k sorted list</h2><p>k is the number of linked lists. </p>
<p>N is the number of nodes in the final linked list.   </p>
<p><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-k-sorted-lists/</a></p>
<ul>
<li>优先队列  <ul>
<li>Time complexity : $O(Nlogk) $<ul>
<li>The comparison cost will be reduced to $O(logk)$ for every pop and insertion to priority queue. But finding the node with the smallest value just costs $O(1)$ time.</li>
</ul>
</li>
<li>Space complexity :<ul>
<li>$O(k)$ The code above present applies in-place method which cost $O(1)$ space. And the priority queue (often implemented with heaps) costs $O(k)$ space (it’s far less than N in most situations). </li>
</ul>
</li>
</ul>
</li>
<li>分治  <ul>
<li>Time complexity : $O(Nlogk)$ where <ul>
<li>We can merge two sorted linked list in $O(N)$ time where nn is the total number of nodes in two lists.</li>
<li>Sum up the merge process and we can get: $O\big(\sum_{i=1}^{log_{2}{k}}N \big)= O(N\log k)$</li>
</ul>
</li>
<li>Space complexity : $O(1)$<ul>
<li>We can merge two sorted linked lists in $O(1)$ space.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><ul>
<li>高效的存储和查找字符串集合的数据结构</li>
</ul>
<p>边上为对应字符</p>
<h3 id="字符串统计"><a href="#字符串统计" class="headerlink" title="字符串统计"></a>字符串统计</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], cnt[N], idx;<span class="comment">// 下标为0的节点既为根节点，又为空节点</span></span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="IP合并"><a href="#IP合并" class="headerlink" title="IP合并"></a>IP合并</h3><p>字典树，添加字符串，沿路节点cnt++; 记录节点深度 dfs</p>
<h2 id="Trie树-1"><a href="#Trie树-1" class="headerlink" title="Trie树"></a>Trie树</h2><p>kmp+字典树</p>
<p>判断字符串S中，是否存在字符串集合PP中任意一个字符串</p>
<p>当前节点的next指向当前节点所有应字符串的后缀与树中所有字符串的前缀中重合最大的那个前缀所对应的节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trie树   字典树+kmp</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    Node* son[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    Node* next;</span><br><span class="line">    Node()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++) son[i]=<span class="literal">NULL</span>;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">buildTrie1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; pp)</span></span>&#123;</span><br><span class="line">    Node* dummyRoot = <span class="keyword">new</span> Node();</span><br><span class="line">    Node* root = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++) dummyRoot-&gt;son[i] = root;</span><br><span class="line">    <span class="comment">//dummyRoot-&gt;next = dummyRoot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pp.size(); i++)&#123;</span><br><span class="line">        Node* p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;pp[i].size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;son[pp[i][j]-<span class="string">'a'</span>]) p-&gt;son[pp[i][j]-<span class="string">'a'</span>] = <span class="keyword">new</span> Node();</span><br><span class="line">            p = p-&gt;son[pp[i][j]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bfs get next</span></span><br><span class="line">    root-&gt;next = dummyRoot;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        Node* u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(u-&gt;son[i])&#123;</span><br><span class="line">                Node* v = u;</span><br><span class="line">                <span class="keyword">while</span>(v!=dummyRoot <span class="keyword">and</span> !v-&gt;next-&gt;son[i])&#123;</span><br><span class="line">                    v = v-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                u-&gt;son[i]-&gt;next = v-&gt;next-&gt;son[i];</span><br><span class="line">                </span><br><span class="line">                q.push(u-&gt;son[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check3</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; pp)</span></span>&#123;</span><br><span class="line">    Node* root = buildTrie1(pp);</span><br><span class="line">    Node* p = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=root <span class="keyword">and</span> !p-&gt;son[s[i]-<span class="string">'a'</span>]) p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;son[s[i]-<span class="string">'a'</span>]) p = p-&gt;son[s[i]-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;flag) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>字符串集合PP中每个字符串对应一个分值</p>
<p>问字符串S中，共包含多少分（可重叠，出现几次算几次分）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">buildTrie2</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt;&amp; pp)</span></span>&#123;</span><br><span class="line">    Node* dummyRoot = <span class="keyword">new</span> Node();</span><br><span class="line">    Node* root = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++) dummyRoot-&gt;son[i] = root;</span><br><span class="line">    <span class="comment">//dummyRoot-&gt;next = dummyRoot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pp.size(); i++)&#123;</span><br><span class="line">        Node* p = root;</span><br><span class="line">        <span class="built_in">string</span> pi = pp[i].first;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;pi.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;son[pi[j]-<span class="string">'a'</span>]) p-&gt;son[pi[j]-<span class="string">'a'</span>] = <span class="keyword">new</span> Node();</span><br><span class="line">            p = p-&gt;son[pi[j]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;flag += pp[i].second; <span class="comment">// 允许重复</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bfs get next</span></span><br><span class="line">    root-&gt;next = dummyRoot;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        Node* u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(u-&gt;son[i])&#123;</span><br><span class="line">                Node* v = u-&gt;next;</span><br><span class="line">                u-&gt;flag += v-&gt;flag; <span class="comment">// 累加next的分数</span></span><br><span class="line">                <span class="keyword">while</span>(v!=dummyRoot <span class="keyword">and</span> !v-&gt;son[i])&#123;</span><br><span class="line">                    v = v-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                u-&gt;son[i]-&gt;next = v-&gt;son[i];</span><br><span class="line">                </span><br><span class="line">                q.push(u-&gt;son[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">getScore3</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt;&amp; pp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">    Node* root = buildTrie2(pp);</span><br><span class="line">    Node* p = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=root <span class="keyword">and</span> !p-&gt;son[s[i]-<span class="string">'a'</span>]) p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;son[s[i]-<span class="string">'a'</span>]) p = p-&gt;son[s[i]-<span class="string">'a'</span>];</span><br><span class="line">        score += p-&gt;flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Trie-图（ac-自动机）"><a href="#Trie-图（ac-自动机）" class="headerlink" title="Trie 图（ac 自动机）"></a>Trie 图（ac 自动机）</h2><p>自动补全trie树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trie图 得到字符串S中包含的分数</span></span><br><span class="line"><span class="function">Node* <span class="title">buildTrieGraph</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt;&amp; pp)</span></span>&#123;</span><br><span class="line">    Node* dummyRoot = <span class="keyword">new</span> Node();</span><br><span class="line">    Node* root = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++) dummyRoot-&gt;son[i] = root;</span><br><span class="line">    <span class="comment">//dummyRoot-&gt;next = dummyRoot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pp.size(); i++)&#123;</span><br><span class="line">        Node* p = root;</span><br><span class="line">        <span class="built_in">string</span> pi = pp[i].first;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;pi.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;son[pi[j]-<span class="string">'a'</span>]) p-&gt;son[pi[j]-<span class="string">'a'</span>] = <span class="keyword">new</span> Node();</span><br><span class="line">            p = p-&gt;son[pi[j]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;flag += pp[i].second; <span class="comment">// 允许重复</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bfs get next</span></span><br><span class="line">    root-&gt;next = dummyRoot;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        Node* u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)&#123;</span><br><span class="line">            Node* v = u-&gt;next; <span class="comment">// v的所有边都已补全</span></span><br><span class="line">            u-&gt;flag += v-&gt;flag;</span><br><span class="line">            <span class="keyword">if</span>(!u-&gt;son[i])&#123;</span><br><span class="line">                u-&gt;son[i] = v-&gt;son[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                u-&gt;son[i]-&gt;next = v-&gt;son[i];</span><br><span class="line">                q.push(u-&gt;son[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getScore4</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt;&amp; pp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">    Node* root = buildTrieGraph(pp);</span><br><span class="line">    Node* p = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">        p = p-&gt;son[s[i]-<span class="string">'a'</span>];</span><br><span class="line">        score += p-&gt;flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p>整数表示范围：</p>
<p>unsigned   int   0～4294967295<br>int   2147483648～2147483647<br>unsigned long 0～4294967295<br>long   2147483648～2147483647<br>long long的最大值：9223372036854775807<br>long long的最小值：-9223372036854775808<br>unsigned long long的最大值：1844674407370955161</p>
<p><strong>int64的最大值：9223372036854775807
</strong>int64的最小值：-9223372036854775808<br>unsigned __int64的最大值：18446744073709551615</p>
<h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><h4 id="取模-取余"><a href="#取模-取余" class="headerlink" title="取模 取余"></a>取模 取余</h4><p>对于整型数a，b来说，取模运算或者求余运算的方法都是：</p>
<p>1.求 整数商： c = a/b;</p>
<p>2.计算模或者余数： r = a - c*b.</p>
<p>求模运算和求余运算在第一步不同: 取余运算在取c的值时，向0 方向舍入(fix()函数)；而取模运算在计算c的值时，向负无穷方向舍入(floor()函数)</p>
<p>例如计算：-7 Mod 4</p>
<p>那么：a = -7；b = 4；</p>
<p>第一步：求整数商c，如进行求模运算c = -2（向负无穷方向舍入），求余c = -1（向0方向舍入）；</p>
<p>第二步：计算模和余数的公式相同，但因c的值不同，求模时r = 1，求余时r = -3。</p>
<p>归纳：<strong>当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致</strong></p>
<p>当符号不一致时，结果不一样。求模运算结果的符号和b一致，求余运算结果的符号和a一致。</p>
<p>另外各个环境下%运算符的含义不同，比如c/c++，java 为取余，而python则为取模</p>
<p>$(A+B)\%p = (A\%p + B\%p)\%p$</p>
<p>$(A-B)\%p = (A\%p -B\%p+p)\%p$</p>
<p>$(A<em>B)\%p = (A\%p </em> B\%p)\%p$</p>
<p>$(A/B)\%p     !=  (A\%p / B\%p)\%p$</p>
<p>$(A/B)\%p     =  (A\%p*inv(B\%p,p)\%p$</p>
<h3 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h3><p><a href="https://www.geeksforgeeks.org/prime-numbers/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/prime-numbers/</a> </p>
<blockquote>
<p>在大于1的整数中，如果只包含1和本身这两个约数，就被称为质数，或者叫做素数</p>
</blockquote>
<h4 id="质数的判定"><a href="#质数的判定" class="headerlink" title="质数的判定"></a>质数的判定</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 试除法判定是否是质数   O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; x; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  试除法优化： 如果 d能整除n,则 d/n也能整除n;  O(sqrt(n))</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h4><p>$x = p_1^{a_1}p_2^{a_2}p_3^{a_3}…..$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 试除法   O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="comment">// x中此时不包括任何2~i-1的质因子，若i能整除x ,则i也一定不包括任何2~i-1的质因子(i为质数)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化：n中最多只包含一个大于sqrt(n)的质因子    时间复杂度： logn~sqrt(n)  </span></span><br><span class="line"><span class="comment">// n=2^k时 -&gt;复杂度为k   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定一个正整数n，请你求出1~n中质数的个数</span></span><br><span class="line"><span class="comment">// 质数定理： 1~n中有ln(n)个质数</span></span><br><span class="line"><span class="comment">// 时间复杂度为O(nloglogn) 埃氏筛法</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N= <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> primes[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            primes[cnt ++ ] = i; <span class="comment">// 2~i-1都没有把i筛掉，i一定为质数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += i) <span class="comment">// 把质数的所有倍数筛掉</span></span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性筛法 时间复杂度为O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123; </span><br><span class="line">            primes[cnt ++ ] = i; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ ) </span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>; <span class="comment">// 合数只会被其最小质因子筛掉</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;  </span><br><span class="line">            <span class="comment">//i % primes[j] == 0: primes[j]是i的最小质因子=&gt; primes[j]是primes[j]*i的最小质因子</span></span><br><span class="line">            <span class="comment">//i % primes[j] != 0: primes[j]&lt;i的最小质因子=&gt; primes[j]是primes[j]*i的最小质因子</span></span><br><span class="line">            <span class="comment">// 对于一个合数x，假设pj为其最小质因子，当i枚举到x/pj，会被筛掉</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 试除法求约数 (类似判断质数)  时间复杂度为 O(sqrt(n))</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; get_divisors(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="comment">// 约数成对出现</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.push_back(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    sort(res.begin(), res.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="约数个数-amp-约数之和"><a href="#约数个数-amp-约数之和" class="headerlink" title="约数个数 &amp; 约数之和"></a>约数个数 &amp; 约数之和</h4><p>$x = p_1^{a_1}p_2^{a_2}p_3^{a_3}…..$</p>
<p>约数个数  $(a_1+1)(a_2+1)….$<br> 约数之和  $(p_1^0+p_1^1…+p_1^{a_1})(p_2^0+p_2^1…+p_2^{a_2})…$</p>
<blockquote>
<p>给定n个正整数ai，请你输出这些数的乘积的约数个数，答案对10^9+7取模</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; primes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (n -- )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">while</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x /= i;</span><br><span class="line">            primes[i] ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) primes[x] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : primes) res = res * (p.second + <span class="number">1</span>) % mod;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>给定n个正整数ai，请你输出这些数的乘积的约数之和，答案对10^9+7取模。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; primes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (n -- )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">while</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x /= i;</span><br><span class="line">            primes[i] ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) primes[x] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : primes)</span><br><span class="line">&#123;</span><br><span class="line">    LL a = p.first, b = p.second;</span><br><span class="line">    LL t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b -- ) t = (t * a + <span class="number">1</span>) % mod;</span><br><span class="line">    res = res * t % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最大公约数-最小公倍数-欧几里得算法"><a href="#最大公约数-最小公倍数-欧几里得算法" class="headerlink" title="最大公约数 最小公倍数 (欧几里得算法)"></a>最大公约数 最小公倍数 (欧几里得算法)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 欧几里得算法</span></span><br><span class="line"><span class="comment">// 辗转相除法 最大公约数 gcd(a,b) = gcd(b,a%b) = gcd(a%b, b%(a%b))</span></span><br><span class="line"><span class="comment">// 若a%b &gt; b/2  b%(a%b) = b-a%b &lt; b/2 规模减半</span></span><br><span class="line"><span class="comment">// 若a%b == b/2 直接结束</span></span><br><span class="line"><span class="comment">// 若a%b &lt; b/2  b%(a%b) &lt; a%b &lt; b/2 规模减半</span></span><br><span class="line"><span class="comment">// 时间复杂度O(logn)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最小公倍数 gcd(a, b) * lcm(a, b) = ab</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b/gcd(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为$\phi(N)$。 若在算数基本定理中，$N = p_1^{a_1}p_2^{a_2}p_3^{a_3}…..p_m^{a_m}$，则： $\phi(N) = N <em> \frac{p_1-1}{p_1} </em> \frac{p_2-1}{p_2}…* \frac{p_m-1}{p_m}$</p>
<p>容斥原理</p>
<ol>
<li>从1~N中，把$p_1,…,p_k$ 的倍数去掉</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求x的欧拉函数 分解质因数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给定一个正整数n，求1~n中每个数的欧拉函数之和。</span></span><br><span class="line"><span class="keyword">int</span> primes[N], cnt;</span><br><span class="line"><span class="keyword">int</span> euler[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_eulers</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123; </span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            euler[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="comment">// i中包含primes[j]的因数</span></span><br><span class="line">            &#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>); <span class="comment">// i中不包含primes[j]的因数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 欧拉定理</span></span><br><span class="line"><span class="comment">// 若a与</span></span><br></pre></td></tr></table></figure>
<h4 id="欧拉定理-费马定理"><a href="#欧拉定理-费马定理" class="headerlink" title="欧拉定理 费马定理"></a>欧拉定理 费马定理</h4><p>若a与n互质，则$a^{\phi(n)} \% n = 1$</p>
<p>假设1~n中，与n互质的数为$a_1, a_2,…,a_{\phi(n)}$</p>
<p>则$a<em>a_1, a</em>a_2,…,a*a_{\phi(n)}$ 也与n互质且各不相同</p>
<p>$ (a_1<em>a_</em>…<em>a_{\phi(n)} )\%n = ((a</em>a_1)\%n <em>  (a</em>a_2)\%n <em>…</em> (a<em>a{\phi(n)})\%n = (a^{\phi(n)}(a_1</em>a_<em>…</em>a_{\phi(n)}))\%n $</p>
<p>=&gt; $a^{\phi(n)} \% n = 1$</p>
<p>若n为质数，则$a^{n-1} \% n = 1$ (费马定理)</p>
<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定a,b,p，求出(a^b)%p的值。</span></span><br><span class="line"><span class="comment">// 暴力循环 O(b)</span></span><br><span class="line"><span class="comment">// 快速幂 O(logb) </span></span><br><span class="line"><span class="comment">// 反复平方法  把b拆成2的幂次数之和=&gt; 转换为2进制</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % p;</span><br><span class="line">        a = a * (LL)a % p; <span class="comment">// 当前位为第位时，a为a^&#123;2^i&#125;</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, qmi(a, b, p));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速幂求逆元</span></span><br><span class="line"><span class="comment">// 给定a,p，其中p是质数,求a模p的乘法逆元，若逆元不存在则输出impossible</span></span><br><span class="line"><span class="keyword">if</span> (a % p == <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, qmi(a, p - <span class="number">2</span>, p));</span><br></pre></td></tr></table></figure>
<h5 id="乘法逆元的定义"><a href="#乘法逆元的定义" class="headerlink" title="乘法逆元的定义"></a>乘法逆元的定义</h5><blockquote>
<p>若整数b，m互质，并且a%b==0，则存在一个整数x，使得a/b≡a∗x(mod m)，则称x为b的模m乘法逆元，记为$b^{−1}$(mod m)。<br>b存在乘法逆元的充要条件是b与模数m互质。当模数m为质数时，$b^{m−2}$即为b的乘法逆元。</p>
</blockquote>
<p>a/b≡a∗x(mod m) =&gt; a≡a*b*x =&gt; b<em>x≡1  (mod m) (若b%m=0,则b\</em>x≡0,无解)</p>
<p>若m为质数，则$b^{m-1}$≡ 1</p>
<h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p><strong>裴署定理</strong></p>
<p>对于任意正整数a,b，一定存在非零整数x,y, 使得ax+by=gcd(a,b)</p>
<p>(a和b的最大公约数是a和b能凑出来的最小正整数) </p>
<p>(a和b能凑出来的一定是gcd(a,b)的倍数) </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ax+by=1 返回一组整数解 </span></span><br><span class="line"><span class="comment">// O(logn) </span></span><br><span class="line"><span class="comment">// ax+by = 1 = gcd(a,b) = gcd(b,a%b) = by'+(a%b)x‘</span></span><br><span class="line"><span class="comment">// ax+by = by'+(a-(a/b)b)x'</span></span><br><span class="line"><span class="comment">// ax = ax'  |   by = by'-(a/b)bx'</span></span><br><span class="line"><span class="comment">// x = x'| y = y'-(a/b)x' 不断递推可得1x'+0y'= 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ax+by=k ab 互质   解为(ax+by=1)的解的k倍</span></span><br><span class="line"><span class="comment">// ax+by=1 ab 不互质   无解</span></span><br><span class="line"><span class="comment">// ax+by=k ab 不互质  看k是否有gcd(a,b)的因数，若无则无解，否则公式两边除以gcd(a,b)转化为ab互质时的问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------</span></span><br><span class="line"><span class="comment">// 给定正整数a,b，求出一组x,y，使其满足ax+by=gcd(a,b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = exgcd(b, a % b, y, x); <span class="comment">// 得到 gcd(b,a%b) = by'+(a%b)x‘的解</span></span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通解：x0-k*(b/d)  y0+k*(a/d)</span></span><br></pre></td></tr></table></figure>
<h4 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定a,b,m，求出一个x，使其满足a∗x≡b(mod m)，如果无解则输出impossible</span></span><br><span class="line"><span class="comment">// a∗x≡b(mod m)有解 &lt;=&gt; a*x + m*k = b 有解 &lt;=&gt; b是gcd(a,m)的倍数</span></span><br><span class="line"><span class="keyword">int</span> d = exgcd(a, m, x, y);</span><br><span class="line"><span class="keyword">if</span> (b % d) <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)b / d * x % m);</span><br></pre></td></tr></table></figure>
<h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><blockquote>
<p>$x\%m_1 = a_1,   x\%m_2 = a_2,  …… ,x\%m_n = a_n$  求x</p>
<p> 若 $m_1,….m_n$两两互质，则一定有解</p>
<p> $M = m_1<em>m_2</em>…*m_n,  M_i = M/m_i,   M_i^{-1} $表示$M_i$模$m_i$的逆</p>
<p>则x的通解为$x=a_1M_1M_1^{-1}+a_2M_2M_2^{-1}…+a_nM_nM_n^{-1} $</p>
<p>$x\%m_1 = a_1,   x\%m_2 = a_2 $ &lt;=&gt; x = m1*k1 + a1 = m2*k2 + a2  &lt;=&gt; m1*k1-m2*k2 = a2-a1 有解</p>
<p>&lt;=&gt; a2-a1是gcd(m1,m2)的倍数</p>
<p>k1的通解为 k1’ + k*m2/gcd(m1,m2)   </p>
<p>x的通解为m1*( k1’ + k*m2/gcd(m1,m2)) + a1 = a1 + m1*k1’ + k*lcm(m1,m2)  = x’ + k*m</p>
<p>x%a’ = x’ 将两个方程合并为1个</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">LL x = <span class="number">0</span>, m1, a1;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m1 &gt;&gt; a1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    LL m2, a2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m2 &gt;&gt; a2;</span><br><span class="line">    LL k1, k2;</span><br><span class="line">    LL d = exgcd(m1, m2, k1, k2);</span><br><span class="line">    <span class="keyword">if</span> ((a2 - a1) % d)  <span class="comment">// 无解</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    k1 *= (a2 - a1) / d; <span class="comment">// k1的特解</span></span><br><span class="line">    k1 = (k1 % (m2/d) + m2/d) % (m2/d); <span class="comment">// 最小的正整数解</span></span><br><span class="line"></span><br><span class="line">    x = k1 * m1 + a1; <span class="comment">// k1&lt;= m2/d - 1, a1&lt;m1; k1*m1+a1 &lt;= m1*m2/d - m1 + a1 &lt; m1*m2/d</span></span><br><span class="line"></span><br><span class="line">    LL m = <span class="built_in">abs</span>(m1 / d * m2); <span class="comment">// 最小公倍数</span></span><br><span class="line">    a1 = x;</span><br><span class="line">    m1 = m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><h3 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数"></a>组合计数</h3><p>$C_m^n\%p$</p>
<p>m,n 数量级为$10^{18}$</p>
<p>方法一： 动态规划 $C_m^n = C_{m-1}^{n-1}+C_{m-1}^n$  $O(n^2)$</p>
<p>方法二： $C_m^n = \frac{m!}{n!(m-n)!} = \frac{(m-n+1)…m}{1…n} = \frac{A}{B}$</p>
<p>$a = A\%p, b = B\%p$</p>
<p>(A/B)%p = (a*inv(b,p))%p</p>
<p>(b*inv(b,p))%p = 1 =&gt; bx%p = 1 =&gt; bx=py+1 =&gt; bx+py’=1  若p为质数 则可求解 (x=b^{p-1})</p>
<p>若p不为质数，将p分解为质数，中国剩余定理求解</p>
<h1 id="Bit-Manipulation"><a href="#Bit-Manipulation" class="headerlink" title="Bit Manipulation"></a>Bit Manipulation</h1><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>正数和0的补码就是将该数字本身。负数的补码则是将其对应正数按位取反再加1：</p>
<p>最大数(0 + 若干个1)-&gt;0(0+若干个0)-&gt; -1(1+ 若干个1)-&gt; 最小数（1+若干个0）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>0</strong></th>
<th><strong>1</strong></th>
<th><strong>1</strong></th>
<th><strong>1</strong></th>
<th><strong>1</strong></th>
<th><strong>1</strong></th>
<th><strong>1</strong></th>
<th><strong>1</strong></th>
<th><strong>=</strong></th>
<th style="text-align:center"><strong>127</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>=</strong></td>
<td style="text-align:center"><strong>2</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td><strong>=</strong></td>
<td style="text-align:center"><strong>1</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>=</strong></td>
<td style="text-align:center"><strong>0</strong></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>=</strong></td>
<td style="text-align:center"><strong>−1</strong></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>=</strong></td>
<td style="text-align:center"><strong>−2</strong></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td><strong>=</strong></td>
<td style="text-align:center"><strong>−127</strong></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>=</strong></td>
<td style="text-align:center"><strong>−128</strong></td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A             .......1 (000000)</span></span><br><span class="line"><span class="comment">// A-1           .......0 (111111)</span></span><br><span class="line"><span class="comment">// A&amp;(A-1)       .......0 (000000)  去掉A中最右边的1</span></span><br><span class="line"><span class="comment">// A&amp; ~(A-1)     00000001 (000000)  提取A中最右边的1所代表的数 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A |= 1 &lt;&lt; bit                    A中右边数第bit位置1</span></span><br><span class="line"><span class="comment">// A &amp;= ~(1 &lt;&lt; bit)                 A中右边数第bit位置0</span></span><br><span class="line"><span class="comment">// (A &amp; 1 &lt;&lt; bit) != 0              检验A中右边数第bit为0还是1</span></span><br><span class="line"><span class="comment">// ~0                               Get all 1-bits</span></span><br></pre></td></tr></table></figure>
<h2 id="左移右移"><a href="#左移右移" class="headerlink" title="左移右移"></a>左移右移</h2><blockquote>
<p> 对于无符号数来说，左移1位，相当于乘以一个2，右移一位相当于除以一个2;</p>
<p>对于有符号数则没有上述规律</p>
</blockquote>
<p><a href="https://blog.csdn.net/yusliao/article/details/39152671" target="_blank" rel="noopener">https://blog.csdn.net/yusliao/article/details/39152671</a></p>
<p><a href="https://blog.csdn.net/e3399/article/details/7526230" target="_blank" rel="noopener">https://blog.csdn.net/e3399/article/details/7526230</a></p>
<blockquote>
<p>在c 中左移也就是所说的逻辑移位，右端补0，而右移是算数移位，左端补齐的是最高位的符号位。</p>
</blockquote>
<p>1)负数的右移：负数右移的话，由于要保持它是负数，所以左端补齐的是最高位的符号位1。如果一直右移的话，最后就就变成0xFFFFFFFF 即-1</p>
<p>2)负数的左移：跟正整数左移一样，右边补0，一直左移的话，最后就是0啦。-2&lt;&lt;1 为-4 ； -2&lt;&lt;31为0</p>
<p>故负数左移，有可能变成正数，但负数右移，肯定还是负数。 </p>
<h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><h3 id="single-Number"><a href="#single-Number" class="headerlink" title="single Number"></a>single Number</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Given a non-empty array of integers, every element appears **twice** except for one. Find that single one.</span></span><br><span class="line"><span class="comment">// x^x = 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">        result ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="single-Number-ii"><a href="#single-Number-ii" class="headerlink" title="single Number ii"></a>single Number ii</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Given a non-empty array of integers, every element appears **k**(k&gt;=2) times except for one, which appears exactly once. Find that single one.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> count[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">        count[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;nums.size();j++)&#123;</span><br><span class="line">            count[i]+= (nums[j]&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;count[i]&lt;&lt;endl;</span></span><br><span class="line">        res |= ((count[i]%k)&lt;&lt;i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="single-Number-iii"><a href="#single-Number-iii" class="headerlink" title="single Number iii"></a>single Number iii</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; singleNumber(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">        n^=nums[i];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> m = n&amp;(~(n<span class="number">-1</span>));</span><br><span class="line">    <span class="comment">//cout&lt;&lt;n&lt;&lt;" "&lt;&lt;m&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">int</span> x1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&amp;m) x1^=nums[i];</span><br><span class="line">        <span class="keyword">else</span> x2^=nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line">    res.push_back(x1);</span><br><span class="line">    res.push_back(x2);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="给定范围的重复与缺失问题"><a href="#给定范围的重复与缺失问题" class="headerlink" title="给定范围的重复与缺失问题"></a>给定范围的重复与缺失问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N+1个数，范围在1~N，其中仅有一个数出现两次，其他出现一次，求出出现两次的数</span></span><br><span class="line"><span class="comment">// 1. hash                       空间O(N)  时间O(N)</span></span><br><span class="line"><span class="comment">// 2. 数学方法: sum-N(1+N)/2      空间O(1)  时间O(N)</span></span><br><span class="line"><span class="comment">// 3. 异或 index,val             空间O(1)  时间O(N)</span></span><br><span class="line">---------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// N个数，范围在0-N，每个数出现一次，求缺失的数</span></span><br><span class="line"><span class="comment">// 数学方法：N(1+N)/2-sum</span></span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数</span></span><br><span class="line"><span class="comment">// 1.排序</span></span><br><span class="line"><span class="comment">// 2. hash</span></span><br><span class="line"><span class="comment">// 3. 循环检测</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> fast=nums[nums[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">        slow=nums[slow];</span><br><span class="line">        fast=nums[nums[fast]];</span><br><span class="line">    &#125;</span><br><span class="line">    slow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">        slow=nums[slow];</span><br><span class="line">        fast=nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Count-set-bits-in-an-integer-正整数"><a href="#Count-set-bits-in-an-integer-正整数" class="headerlink" title="Count set bits in an integer(正整数)"></a>Count set bits in an integer(正整数)</h2><p>Simple method:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countSetBits</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">while</span> (n) </span><br><span class="line">  &#123; </span><br><span class="line">    count += n &amp; <span class="number">1</span>; </span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> count; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Brian Kernighan’s Algorithm</strong></p>
<blockquote>
<p><strong>When we do bitwise AND between (number) &amp; (number-1), Right most SET bit of “number” will be unset.</strong></p>
<p>The beauty of this solution is the number of times it loops is equal to the number of set bits in a given integer.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countSetBits</span><span class="params">(<span class="keyword">unsigned</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (n) </span><br><span class="line">    &#123; </span><br><span class="line">      n &amp;= (n<span class="number">-1</span>) ; </span><br><span class="line">      count++; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> count; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Number-Complement"><a href="#Number-Complement" class="headerlink" title="Number Complement"></a>Number Complement</h2><blockquote>
<p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>
<p>Eg:  5(101)-&gt;2(010)</p>
</blockquote>
<p>Simple method</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            result += (<span class="number">1</span>-(num&amp;<span class="number">1</span>))*i;</span><br><span class="line">            i=i&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            num=num&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Mask </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> mask = ~<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &amp; mask) mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ~mask &amp; ~num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Bitmap-Bitset"><a href="#Bitmap-Bitset" class="headerlink" title="Bitmap Bitset"></a>Bitmap Bitset</h2><p>大数据排序，查询以及去重</p>
<h3 id="Partition-Equal-Subset-Sum"><a href="#Partition-Equal-Subset-Sum" class="headerlink" title="Partition Equal Subset Sum"></a>Partition Equal Subset Sum</h3><p>Leetcode 416</p>
<blockquote>
<p>Given a <strong>non-empty</strong> array containing <strong>only positive integers</strong>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>
<p><strong>Note:</strong></p>
<ol>
<li>Each of the array element will not exceed 100.</li>
<li>The array size will not exceed 200.</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> MAX_NUM = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = <span class="number">200</span>;</span><br><span class="line">        <span class="built_in">bitset</span>&lt;MAX_NUM * MAX_ARRAY_SIZE / 2 + 1&gt; bits(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">            sum += n;</span><br><span class="line">            bits |= bits &lt;&lt; n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !(sum % <span class="number">2</span>) &amp;&amp; bits[sum / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;// explanation</span><br><span class="line">&gt;num = 5</span><br><span class="line">&gt;0 -&gt; 5 (set 5&apos;s bit, since we can achieve sum 5.)</span><br><span class="line">&gt;Now we can achieve 0 and 5 with [ ] and [ 5 ]. So by the union of both, we have 000000100001</span><br><span class="line">&gt;</span><br><span class="line">&gt;num = 2</span><br><span class="line">&gt;0-&gt;2</span><br><span class="line">&gt;5-&gt;7</span><br><span class="line">&gt;We can achieve 0,2,5,7 from [5,2] ==&gt; [ ], [5], [2], [5,2]</span><br><span class="line">&gt;After union our bitset is 000010100101</span><br><span class="line">&gt;</span><br><span class="line">&gt;num = 4</span><br><span class="line">&gt;0-&gt;4</span><br><span class="line">&gt;2-&gt;6</span><br><span class="line">&gt;5-&gt;9</span><br><span class="line">&gt;7-&gt;11</span><br><span class="line">&gt;We can achieve 0,2,4,5,6,7,11 from [5,2] ==&gt; [ ], [5], [2], [4], [5,2], [2,4], [5,4], [5,2,4]</span><br><span class="line">&gt;After union our bitset is 101011110101</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>Energy stone 贪心+背包</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N个能量石，i-th能量石有三个特性</span></span><br><span class="line"><span class="comment">// 初始能量Ei, 吃掉该能量石用时Si, 能量石每秒损失能量Li (开始吃能量石的瞬间获得能量，但需等Si才能吃下一个)</span></span><br><span class="line"><span class="comment">// 求吃能量石最大可获得的能量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Si/Li 贪心排序+背包dp</span></span><br><span class="line"><span class="comment">// 贪心，比较序列...,i,j,...和序列...,j,i,...</span></span><br><span class="line"><span class="comment">// ... +   max(0,E[i]-C*L[i]) + max(0, E[j]-(C+S[i])*L[j]) + ....</span></span><br><span class="line"><span class="comment">// ... +   max(0,E[j]-C*L[j]) + max(0, E[i]-(C+S[j])*L[i]) + ...</span></span><br><span class="line"><span class="comment">// 1) E均足够大 则S[i]/L[i]小的优先吃</span></span><br><span class="line"><span class="comment">// 2) 若4个式子中有取0， 则存在序列...,i,....或...,j,...更优</span></span><br><span class="line"><span class="comment">// 因此最优序列一定满足S[i]/L[i]的排序</span></span><br><span class="line"><span class="comment">// 至于选择哪些能量石吃或不吃转移为背包问题</span></span><br></pre></td></tr></table></figure>
<p>Code-eat switcher   贪心+二分</p>
<p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050edb/00000000001707b8" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050edb/00000000001707b8</a></p>
<h2 id="合并果子-huffman"><a href="#合并果子-huffman" class="headerlink" title="合并果子  huffman"></a>合并果子  huffman</h2><blockquote>
<p>在一个果园里，达达已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。</p>
<p>达达决定把所有的果子合成一堆。</p>
<p>每一次合并，达达可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。</p>
<p>可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。求最小的体力耗费值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        heap.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (heap.size() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = heap.top(); heap.pop();</span><br><span class="line">        <span class="keyword">int</span> b = heap.top(); heap.pop();</span><br><span class="line">        res += a + b;</span><br><span class="line">        heap.push(a + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h2><h3 id="离线区间merge"><a href="#离线区间merge" class="headerlink" title="离线区间merge"></a>离线区间merge</h3><p><a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-intervals/</a></p>
<ul>
<li><p>给出若干闭合区间，合并所有重叠的部分</p>
<p>按照区间的 start 大小进行排序</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// 首先对区间开始的位置做排序</span></span><br><span class="line">        sort(intervals.begin(),intervals.end(),compare);</span><br><span class="line">        <span class="keyword">int</span> begin = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(end&lt;intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; interval = &#123;begin,end&#125;;</span><br><span class="line">                res.push_back(interval);</span><br><span class="line">                begin = intervals[i][<span class="number">0</span>];</span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end = max(end,intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; interval = &#123;begin,end&#125;;</span><br><span class="line">        res.push_back(interval);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间选点-最大的不相交区间的数量"><a href="#区间选点-最大的不相交区间的数量" class="headerlink" title="区间选点|最大的不相交区间的数量"></a>区间选点|最大的不相交区间的数量</h3><blockquote>
<p> 给定N个闭区间[ai,biai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。</p>
<p>输出选择的点的最小数量。位于区间端点上的点也算作区间内。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对每个区间的结束位置做排序</span></span><br><span class="line"><span class="comment">// 从前往后一次枚举每个区间</span></span><br><span class="line"><span class="comment">//      1) 如果当前区间中已经包含点，则直接pass</span></span><br><span class="line"><span class="comment">//      2) 否则，选择当前区间的右端点</span></span><br><span class="line">--------</span><br><span class="line">    --------</span><br><span class="line">           -------</span><br></pre></td></tr></table></figure>
<p>等价于求最大的不相交区间的数量</p>
<blockquote>
<p>给定N个闭区间[ai,biai,bi]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。</p>
<p>输出可选取区间的最大数量。</p>
</blockquote>
<h3 id="区间分组"><a href="#区间分组" class="headerlink" title="区间分组"></a>区间分组</h3><blockquote>
<p>给定N个闭区间[ai,biai,bi]，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">-------</span><br><span class="line">    ---------</span><br><span class="line">          -----</span><br><span class="line"><span class="comment">// 对每个区间的开始位置做排序</span></span><br><span class="line"><span class="comment">// 从前往后枚举每个区间</span></span><br><span class="line"><span class="comment">//       判断能否将其放到现有的某个组(维护每个组的最靠右的点)</span></span><br><span class="line"><span class="comment">//             若不能则开新组，并将其放进去</span></span><br><span class="line"><span class="comment">//             否则，将其放进去，更新这个组的max_r</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Range &amp;W)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; W.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        range[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(range, range + n);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> r = range[i];</span><br><span class="line">        <span class="keyword">if</span> (heap.empty() || heap.top() &gt;= r.l) heap.push(r.r);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            heap.pop();</span><br><span class="line">            heap.push(r.r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, heap.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间覆盖"><a href="#区间覆盖" class="headerlink" title="区间覆盖"></a>区间覆盖</h3><blockquote>
<p>给定N个闭区间[ai,bi]以及一个线段区间[s,t]，请你选择尽量少的区间，将指定线段区间完全覆盖。</p>
<p>输出最少区间数，如果无法完全覆盖则输出-1。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对每个区间的开始位置做排序</span></span><br><span class="line"><span class="comment">// 从前往后枚举每个区间，在所有能够覆盖start的区间，选择右端点最大的，然后将start更新为最大的右端点</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Range &amp;W)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; W.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st, ed;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;st, &amp;ed);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        range[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(range, range + n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i, r = <span class="number">-2e9</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; range[j].l &lt;= st)</span><br><span class="line">        &#123;</span><br><span class="line">            r = max(r, range[j].r);</span><br><span class="line">            j ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r &lt; st)</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res ++ ;</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= ed)</span><br><span class="line">        &#123;</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        st = r;</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!success) res = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Maximum-Length-of-Pair-Chain"><a href="#Maximum-Length-of-Pair-Chain" class="headerlink" title="Maximum Length of Pair Chain"></a>Maximum Length of Pair Chain</h3><p><a href="https://leetcode.com/problems/maximum-length-of-pair-chain/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-length-of-pair-chain/</a></p>
<p><a href="https://leetcode.com/problems/maximum-length-of-pair-chain/discuss/105617/C%2B%2B-Clean-Code" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-length-of-pair-chain/discuss/105617/C%2B%2B-Clean-Code</a></p>
<ol>
<li>sort the pairs by their end in increasing order;</li>
<li>at any point, choose the pair that start after the tail end, then use it as the new tail;</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        sort(pairs.begin(), pairs.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pair = pairs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || pairs[i][<span class="number">0</span>] &gt; pair[<span class="number">1</span>]) &#123;</span><br><span class="line">                pair = pairs[i];</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>] || a[<span class="number">1</span>] == b[<span class="number">1</span>] &amp;&amp; a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="区间重叠-扫描线算法"><a href="#区间重叠-扫描线算法" class="headerlink" title="区间重叠 扫描线算法"></a>区间重叠 扫描线算法</h3><p>事件往往是以区间的形式存在</p>
<p>区间的两端代表事件的开始和结束</p>
<p>将起点和终点打散排序，[[1,3], [2,4]] =&gt; [[1,start],[2,start],[3,end],[4,end]</p>
<blockquote>
<p>[lintcode 920]给定一系列区间，代表一系列会议时间间隔，求一个人能否参加所有的会议。</p>
<p>=&gt; 第一步，打散区间，第二步，sequence 排 序，第三步，扫描，要是大于 1 就 return False</p>
<p>[lintcode 919] 给定一系列区间，代表一系列会议的时间间隔，求所需的最小的会议室数量。</p>
<p>=&gt; 在扫描过程中，记录扫描到的最大值</p>
<p>[lintcode 391] 给定 N 架飞机起飞降落的时间，求天上最多时有多少架飞机。</p>
<p>如果多架飞机降落起飞在同一时刻，我们认为先降落再起飞。</p>
<p>=&gt; 用 -1 代表降落， +1 代表起飞   </p>
</blockquote>
<p> 821  <a href="https://www.lintcode.com/problem/time-intersection/description" target="_blank" rel="noopener">https://www.lintcode.com/problem/time-intersection/description</a>  </p>
<p> 131  <a href="https://www.lintcode.com/problem/the-skyline-problem/description" target="_blank" rel="noopener">https://www.lintcode.com/problem/the-skyline-problem/description</a> </p>
<h3 id="动态维护区间"><a href="#动态维护区间" class="headerlink" title="动态维护区间"></a>动态维护区间</h3><p><a href="https://leetcode.com/problems/data-stream-as-disjoint-intervals/" target="_blank" rel="noopener">https://leetcode.com/problems/data-stream-as-disjoint-intervals/</a></p>
<p>Set hash</p>
<h2 id="Jump-Game2"><a href="#Jump-Game2" class="headerlink" title="Jump Game2"></a>Jump Game2</h2><p>leetcode 45</p>
<blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p><strong>Note:</strong> You can assume that you can always reach the last index.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次选择跳到能扩展范围最大的index</span></span><br><span class="line"><span class="comment">// BFS 记录下一层能到达的范围</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, curMax = <span class="number">0</span>, nextMax=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(curMax-i+<span class="number">1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        level++;</span><br><span class="line">        <span class="keyword">for</span>(; i&lt;=curMax; i++)&#123;</span><br><span class="line">            nextMax = max(nextMax,i+nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(nextMax&gt;=n<span class="number">-1</span>) <span class="keyword">return</span> level;</span><br><span class="line">        &#125;</span><br><span class="line">        curMax = nextMax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><blockquote>
<p>给定一个数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++ )</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i + <span class="number">1</span>; j ++ )</span><br><span class="line">        f[i][j] = -INF;</span><br><span class="line"></span><br><span class="line">f[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++ )</span><br><span class="line">        f[i][j] = max(f[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j], f[i - <span class="number">1</span>][j] + a[i][j]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = -INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = max(res, f[n][i]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<h3 id="Longest-common-subsequence-substring"><a href="#Longest-common-subsequence-substring" class="headerlink" title="Longest  common subsequence/substring"></a>Longest  common subsequence/substring</h3><p>Longest common substring of $S_1$ and $S_2$ :  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base case  lcs[i][-1] = 0   lcs[-1][j] = 0</span></span><br><span class="line"><span class="comment">// dp  iterate 0&lt;=i&lt;N 0&lt;=j&lt;M</span></span><br><span class="line"><span class="keyword">if</span>(S1[i]==S2[j]) lcs[i][j] = lcs[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span> lcs[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//result: max of lcs[i][j]  iterate 0&lt;=i&lt;N 0&lt;=j&lt;M</span></span><br></pre></td></tr></table></figure>
<p>Longest common subsequence of $S_1$ and $S_2$ :  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base case  lcs[i][-1] = 0 lcs[-1][j] = 0</span></span><br><span class="line"><span class="comment">// dp iterate 0&lt;=i&lt;N 0&lt;=j&lt;M</span></span><br><span class="line"><span class="keyword">if</span>(S1[i]==S2[j]) lcs[i][j] = lcs[i<span class="number">-1</span>,j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> lcs[i][j] = max(lcs[i][j<span class="number">-1</span>], lcs[i<span class="number">-1</span>][j])</span><br><span class="line"><span class="comment">// result: lcs[N][M]</span></span><br></pre></td></tr></table></figure>
<h3 id="Edit-Distance"><a href="#Edit-Distance" class="headerlink" title="Edit Distance"></a>Edit Distance</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base case</span></span><br><span class="line">ed[i][<span class="number">-1</span>] = i;  ed[<span class="number">-1</span>][j] = j;</span><br><span class="line"><span class="comment">// dp iterate 0&lt;=i&lt;N 0&lt;=j&lt;M</span></span><br><span class="line"><span class="keyword">if</span>(S1[i]==S2[j]) ed[i][j] = ed[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">else</span> ed[i][j] = min(min(ed[i<span class="number">-1</span>][j<span class="number">-1</span>],ed[i<span class="number">-1</span>][j]),ed[i][j<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// result: ed[N][M]</span></span><br></pre></td></tr></table></figure>
<h3 id="Longest-palindromic-subsequence"><a href="#Longest-palindromic-subsequence" class="headerlink" title="Longest palindromic subsequence"></a>Longest palindromic subsequence</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base case </span></span><br><span class="line">lps[i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// dp iterate 2&lt;=len&lt;=n   len: length of [i,j]  iterate i </span></span><br><span class="line"><span class="keyword">if</span>(s[i]==s[j] <span class="keyword">and</span> len==<span class="number">2</span>) lps[i][j] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[i]==s[j]) lps[i][j] = lps[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> lps[i][j] = max(lps[i+<span class="number">1</span>][j], lps[i][j<span class="number">-1</span>]);</span><br><span class="line"><span class="comment">// result: lps[0][n-1]</span></span><br></pre></td></tr></table></figure>
<h3 id="Longest-palindromic-substring"><a href="#Longest-palindromic-substring" class="headerlink" title="Longest palindromic substring"></a>Longest palindromic substring</h3><ul>
<li><p>$O(n^3)$ runtime, $O(1)$ space – Brute force:</p>
<p>The obvious brute force solution is to pick all possible starting and ending positions for a<br>substring, and verify if it is a palindrome. </p>
</li>
<li><p>$O(n^2)$ runtime, $O(n^2)$ space – Dynamic programming:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base case </span></span><br><span class="line">lps[i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// dp iterate 2&lt;=len&lt;=n   len: length of [i,j]</span></span><br><span class="line"><span class="keyword">if</span>(s[i]==s[j] <span class="keyword">and</span> len==<span class="number">2</span>) lps[i][j] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[i]==s[j]) lps[i][j] = lps[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> lps[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// result: max(lps[i][j]) iterate 0&lt;=i&lt;N 0&lt;=j&lt;N</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>$O(n^2)$ runtime, $O(1)$ space – Simpler solution:<br>In fact, we could solve it in $O(n^2)$ time using only constant space.<br>We observe that a palindrome mirrors around its center. Therefore, a palindrome can be<br>expanded from its center, and there are only 2n – 1 such centers.<br>You might be asking why there are 2n – 1 but not n centers? The reason is the center of a<br>palindrome can be in between two letters. Such palindromes have even number of letters<br>(such as “abba”) and its center are between the two ‘b’s.<br>Since expanding a palindrome around its center could take O(n) time, the overall<br>complexity is $O(n^2)$.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i);</span><br><span class="line">        <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">            start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            end = i + len / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">    <span class="keyword">while</span> (L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class="line">        L--;</span><br><span class="line">        R++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R - L - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>O(n) runtime, O(n) space – Manacher’s algorithm <a href="https://www.felix021.com/blog/read.php?2040" target="_blank" rel="noopener">https://www.felix021.com/blog/read.php?2040</a></p>
<blockquote>
<p>首先用一个非常巧妙的方式，将所有可能的奇数/偶数长度的回文子串都转换成了奇数长度：在每个字符的两边都插入一个特殊的符号。比如 abba 变成 #a#b#b#a#， aba变成 #a#b#a#。 为了进一步减少编码的复杂度，可以在字符串的开始加入另一个特殊字符，这样就不用特殊处理越界问题，比如$#a#b#a#（注意，下面的代码是用C语言写就，由于C语言规范还要求字符串末尾有一个’\0’所以正好OK，但其他语言可能会导致越界）</p>
<p>然后用一个数组 P[i] 来记录以字符S[i]为中心的最长回文子串向左/右扩张的长度（包括S[i]，也就是把该回文串“对折”以后的长度），比如S和P的对应关系</p>
<p>S  #  1  #  2  #  2  #  1  #  2  #  3  #  2  #  1  # </p>
<p>P  1   2  1  2  5  2  1  4  1  2  1   6  1  2  1  2  1 (p.s. 可以看出，P[i]-1正好是原字符串中回文串的总长度）</p>
<p>那么怎么计算P[i]呢？该算法增加两个辅助变量（其实一个就够了，两个更清晰）id和mx，其中 id 为已知的 {右边界最大} 的回文子串的中心，mx则为id+P[id]，也就是这个子串的右边界。  然后可以得到一个非常神奇的结论，这个算法的关键点就在这里了：如果mx &gt; i，那么P[i] &gt;= MIN(P[2 * id - i], mx - i)</p>
<p>实际上如果把它写得复杂一点，理解起来会简单很多：</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记j = 2 * id - i，也就是说 j 是 i 关于 id 的对称点(j = id - (i - id))</span></span><br><span class="line"><span class="keyword">if</span> (mx - i &gt; P[j]) </span><br><span class="line">    P[i] = P[j];</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* P[j] &gt;= mx - i */</span></span><br><span class="line">    P[i] = mx - i; <span class="comment">// P[i] &gt;= mx - i，取最小值，之后再匹配更新。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当 mx - i &gt; P[j] ，以S[j]为中心的回文子串包含在以S[id]为中心的回文子串中，由于 i 和 j 对称，以S[i]为中心的回文子串必然包含在以S[id]为中心的回文子串中，所以必有 P[i] = P[j]</li>
<li>当 P[j] &gt;= mx - i ，以S[j]为中心的回文子串不一定完全包含于以S[id]为中心的回文子串中，但是基于对称性可知，下图中两个绿框所包围的部分是相同的，也就是说以S[i]为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 P[i] &gt;= mx - i。至于mx之后的部分是否对称，就只能老老实实去匹配了。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入，并处理得到字符串s</span></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">1000</span>], mx = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; s[i] != <span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">    p[i] = mx &gt; i ? min(p[<span class="number">2</span>*id-i], mx-i) : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[i + p[i]] == s[i - p[i]]) p[i]++;</span><br><span class="line">    <span class="keyword">if</span> (i + p[i] &gt; mx) &#123;</span><br><span class="line">        mx = i + p[i];</span><br><span class="line">        id = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找出p[i]中最大的</span></span><br></pre></td></tr></table></figure>
<p>算法复杂度：<a href="https://segmentfault.com/a/1190000008484167" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008484167</a></p>
<h3 id="Longest-increasing-subsequence"><a href="#Longest-increasing-subsequence" class="headerlink" title="Longest increasing subsequence"></a>Longest increasing subsequence</h3><p><a href="https://leetcode.com/problems/longest-increasing-subsequence/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-increasing-subsequence/solution/</a></p>
<p>DP    $O(N^2)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lis[i] 所有以第i个数结尾的上升子序列   的长度的最大值</span></span><br><span class="line"><span class="comment">// 状态转移  以倒数第二个数分类</span></span><br><span class="line"><span class="comment">// base case + 初始化 iterate 0&lt;=i&lt;N</span></span><br><span class="line"><span class="comment">// lis[i] = 1;</span></span><br><span class="line"><span class="comment">// dp iterate 1&lt;=i&lt;N  0&lt;=j&lt;i</span></span><br><span class="line"><span class="comment">// if(num[j]&lt;nums[i]) lis[i] = max(lis[i], lis[j]+1);</span></span><br><span class="line"><span class="comment">// result: max(lis[0~N-1])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lis(n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[j]) lis[i] = max(lis[i], lis[j] + <span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        result =max(result, lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DP+ BS  $O(NlogN)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护DP数组，dp[i]为num[1:j]中使得递增序列长度为i+1的最小元素</span></span><br><span class="line"><span class="comment">// input: [0, 8, 4, 12, 2]</span></span><br><span class="line"><span class="comment">// dp: [0]</span></span><br><span class="line"><span class="comment">// dp: [0, 8]</span></span><br><span class="line"><span class="comment">// dp: [0, 4]</span></span><br><span class="line"><span class="comment">// dp: [0, 4, 12]</span></span><br><span class="line"><span class="comment">// dp: [0 , 2, 12] which is not the longest increasing subsequence, but length of dp array results in length of Longest Increasing Subsequence.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp; <span class="comment">// dp[i]为num[1:j]中使得递增序列长度为i+1的最小元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i ++)&#123;</span><br><span class="line">        <span class="comment">// 二分找到dp中&gt;=nums[i]的最小位置</span></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = dp.size();</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>( dp[mid] &lt; nums[i])&#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lo &lt; dp.size())&#123;</span><br><span class="line">            dp[lo] = nums[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Increasing-Triplet-Subsequence"><a href="#Increasing-Triplet-Subsequence" class="headerlink" title="Increasing Triplet Subsequence"></a>Increasing Triplet Subsequence</h3><p><a href="https://leetcode.com/problems/increasing-triplet-subsequence/" target="_blank" rel="noopener">https://leetcode.com/problems/increasing-triplet-subsequence/</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录当前最小的i和最小的j</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">increasingTriplet</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> minVal = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> minSecondVal = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;minSecondVal) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&gt;minVal) minSecondVal = nums[i]; <span class="comment">//minSecondVal only gets updated when there exists a minVal that comes before it.</span></span><br><span class="line">        <span class="keyword">else</span> minVal = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><a href="https://www.bilibili.com/video/av33930433?from=search&amp;seid=9210859877463751216" target="_blank" rel="noopener">https://www.bilibili.com/video/av33930433?from=search&amp;seid=9210859877463751216</a></p>
<p><a href="https://www.cnblogs.com/jbelial/articles/2116074.html" target="_blank" rel="noopener">https://www.cnblogs.com/jbelial/articles/2116074.html</a></p>
<h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><blockquote>
<p>有N件物品和一个容量为M的背包。第i件物品的体积是v[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大</p>
</blockquote>
<ul>
<li>每种物品仅有一件，可以选择放或不放</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f[i][j]表示只看前i件物品，总体积**刚**好为j时的最大价值</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line"><span class="comment">iterate i from 1 to N, j from 1 to M</span></span><br><span class="line"><span class="comment">f[i][j]:</span></span><br><span class="line"><span class="comment">      1.不选第i件物品，f[i][j]=f[i-1][j]</span></span><br><span class="line"><span class="comment">      2.选第i件物品，f[i][j]=w[i]+f[i-1][j-v[i]]  // 要判断 j&gt;=v[i]</span></span><br><span class="line"><span class="comment">f[i][j]= max(1,2)</span></span><br><span class="line"><span class="comment">-----------</span></span><br><span class="line"><span class="comment">初始化：f[i][j]=INT_MIN, f[i][0]=0,     0&lt;=i&lt;=N, 0&lt;=j&lt;=M</span></span><br><span class="line"><span class="comment">result = max(f[N][0-M])</span></span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"><span class="comment">时间复杂度：O(NM)</span></span><br><span class="line"><span class="comment">空间复杂度：O(NM)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">空间复杂度优化：O(M)</span></span><br><span class="line"><span class="comment">iterate i from 1 to N, j from M to v[i] //j逆序：为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f[i-1][v-c[i]]</span></span><br><span class="line"><span class="comment">f[j]:</span></span><br><span class="line"><span class="comment">      1.不选第i件物品，f[j]=f[j]</span></span><br><span class="line"><span class="comment">      2.选第i件物品，f[j]=w[i]+f[j-v[i]]  //j&gt;=v[i]</span></span><br><span class="line"><span class="comment">f[j]= max(1,2)</span></span><br><span class="line"><span class="comment">-----------</span></span><br><span class="line"><span class="comment">初始化： f[j]=INT_MIN   f[0]=0</span></span><br><span class="line"><span class="comment">result = max(f[0-M])</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><ul>
<li>每种物品有无穷多件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f[j]表示总体积刚好为j时的最大价值</span></span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"><span class="comment">iterate i from 1 to N, j from v[i] to M //j顺序：在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][j-v[i]]，所以就可以并且必须采用顺序循环</span></span><br><span class="line"><span class="comment">f[j]:</span></span><br><span class="line"><span class="comment">      1.不选第i件物品，f[j]=f[j]</span></span><br><span class="line"><span class="comment">      2.选第i件物品，f[j]=w[i]+f[j-v[i]]  //j&gt;=v[i]</span></span><br><span class="line"><span class="comment">f[j]= max(1,2) </span></span><br><span class="line"><span class="comment">------</span></span><br><span class="line"><span class="comment">初始化： f[j]=INT_MIN   f[0]=0</span></span><br><span class="line"><span class="comment">result = max(f[0-M])</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="coin-change"><a href="#coin-change" class="headerlink" title="coin change"></a>coin change</h4><p>Leetcode322</p>
<blockquote>
<p>You are given coins of different denominations and a total amount of money <em>amount</em>. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全背包 </span></span><br><span class="line"><span class="comment">// dp[i] 表示前j件硬币，每件硬币可选无数次，刚好组成amout的选法  的最小值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = coins.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount+<span class="number">1</span>,INT_MAX);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=amount; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(coins[j]&lt;=i <span class="keyword">and</span> dp[i-coins[j]]!=INT_MAX)&#123;</span><br><span class="line">                    dp[i] = min(dp[i], dp[i-coins[j]]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount]==INT_MAX? <span class="number">-1</span>:dp[amount];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><ul>
<li>第i种物品最多有n[i]件可用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f[j]表示总体积刚好为j时的最大价值</span></span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"><span class="comment">iterate i from 1 to N, j from M to 0, k from 0 to (k*v[i]&lt;=j,k&lt;=n[i]) </span></span><br><span class="line"><span class="comment">f[j] = max(f[j-k*v[i]]+k*w[i])</span></span><br><span class="line"><span class="comment">------</span></span><br><span class="line"><span class="comment">初始化： f[j]=INT_MIN   f[0]=0</span></span><br><span class="line"><span class="comment">result = max(f[0-M])</span></span><br><span class="line"><span class="comment">------</span></span><br><span class="line"><span class="comment">时间复杂度：O(N*sum(n[i]))</span></span><br><span class="line"><span class="comment">空间复杂度：O(M)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二进制优化方法</span></span><br><span class="line"><span class="comment">将多重背包拆成二进制的01背包  倍增思想</span></span><br><span class="line"><span class="comment">7 = 4 + 2 + 1</span></span><br><span class="line"><span class="comment">10 = 4 + 2 + 1 + 3</span></span><br><span class="line"><span class="comment">iterate i from 1 to N, iterate k from 1 to (k&lt;=n[i],k*=2)  </span></span><br><span class="line"><span class="comment">添加物体(体积为k,价值为k*w[i]), n[i]-=k;</span></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"><span class="comment">if(n[i]&gt;0) 添加物体(体积为n[i],价值为n[i]*w[i])</span></span><br><span class="line"><span class="comment">转化为01背包问题</span></span><br><span class="line"><span class="comment">-----------------------</span></span><br><span class="line"><span class="comment">时间复杂度：O(M*sum(log(n[i])))</span></span><br><span class="line"><span class="comment">空间复杂度：O(M*sum(log(n[i])))</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">单调队列优化 O(MN)</span></span><br><span class="line"><span class="comment">&lt;男人八题，楼天城&gt;</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line"><span class="comment">// f[v] = max(f[v-v[i]]+w[i],f[v-2*v[i]]+2*w[i],...f[v-k*v[i]]+k*w[i]</span></span><br><span class="line"><span class="comment">// f[v+v[i]] = max(f[v]+w[i], f[v-v[i]]+2*w[i],...)</span></span><br><span class="line"><span class="comment">// 将f按照%v[i]的值分为v[i]类，每一类是独立的</span></span><br><span class="line"><span class="comment">itertate i from 1 to N</span></span><br><span class="line"><span class="comment">   g = f；</span></span><br><span class="line"><span class="comment">   iterate j from 0 to v[i]-1</span></span><br><span class="line"><span class="comment">       deque&lt;int&gt; q // 单调递减队列</span></span><br><span class="line"><span class="comment">       iterate v from j to M(v+=v[i])</span></span><br><span class="line"><span class="comment">          f[v] = g[v]；</span></span><br><span class="line"><span class="comment">          if(!q.empty() and v - v[i]*n[i] &gt; q.front()) q.pop_front()</span></span><br><span class="line"><span class="comment">          if(!q.empty()) f[v] = max(f[v], g[q.front()]+(v-q.front())/v[i]*w[i]);</span></span><br><span class="line"><span class="comment">          while(!q.empty() and g[q.front()]-(q.front()-j)/v[i]*w[i] &lt;= g[v] - (v-j)/v[i]*w[i]) q.pop_back();</span></span><br><span class="line"><span class="comment">          q.push_back(k);</span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment">(经典单调队列问题，sliding window maximum,差分)</span></span><br><span class="line"><span class="comment">对每个j, 单调下降队列按f[v]-k*w[i]排序</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h3><ul>
<li>有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">n[i]: -1(只能取1次)  0(无限次)  &gt;0(多重)</span></span><br><span class="line"><span class="comment">首先多重背包拆成01背包=&gt; 01背包+完全背包</span></span><br><span class="line"><span class="comment">iterate i from 1 to N*(拆解后的物品总数) //对每个物品采用不同的转移方式</span></span><br><span class="line"><span class="comment">if(01背包) j逆序</span></span><br><span class="line"><span class="comment">if(完全背包) j顺序</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h3><ul>
<li>对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">背包体积M，承重G</span></span><br><span class="line"><span class="comment">f[j][k]: 体积为j,重量为k的最大价值  01背包</span></span><br><span class="line"><span class="comment">------</span></span><br><span class="line"><span class="comment">iterate i from 1 to N, j from M to v[i], k from G to g[i]</span></span><br><span class="line"><span class="comment">f[j][k] = max(f[j][k],f[j-v[i]][k-g[i]]+w[i])</span></span><br><span class="line"><span class="comment">-----</span></span><br><span class="line"><span class="comment">初始化f[j][k]=INT_MIN, f[0][0]=0</span></span><br><span class="line"><span class="comment">result = max(f[0-M][0-G])</span></span><br><span class="line"><span class="comment">-----</span></span><br><span class="line"><span class="comment">时间复杂度：O(NMG)</span></span><br><span class="line"><span class="comment">空间复杂度：O(MG)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><ul>
<li>这些物品被划分为若干组，每组中的物品互相冲突，最多选一件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">每组物品有若干决策：全不选or选择任意一件物品// 多重背包是分组背包的特殊情况，打包选一件，两件，...的情况</span></span><br><span class="line"><span class="comment">N:物品组，M:背包容量</span></span><br><span class="line"><span class="comment">每个物品组：S[i]:第i组内物品数量</span></span><br><span class="line"><span class="comment">v[i][k]，w[i][k]:第i组第k件物品的体积，价值</span></span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"><span class="comment">iterate i from 1 to N, j from M to 0, k from 0 to S[i]-1</span></span><br><span class="line"><span class="comment">if(j&gt;=v[i][k]) f[j]=max(f[j],f[j-v[i][k]]+w[i][k])</span></span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"><span class="comment">初始化：f[j]=INT_MIN, f[0]=0</span></span><br><span class="line"><span class="comment">result = max(f[0-M])</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><blockquote>
<p>设有N堆石子排成一排，其编号为1，2，3，…，N。</p>
<p>每堆石子有一定的质量，可以用一个整数来描述，现在要将这N堆石子合并成为一堆。</p>
<p>每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。</p>
<p>找出一种合理的方法，使总的代价最小，输出最小代价。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有将第i堆石子到第j堆石子合并到一堆的方式 的代价的最小值</span></span><br><span class="line"><span class="comment">// 状态转移 按照最后一次合并的分界线分类</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;s[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) s[i] += s[i - <span class="number">1</span>]; <span class="comment">// 前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len ++ ) <span class="comment">// 循环长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i ++ ) <span class="comment">// 循环左端点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = i, r = i + len - <span class="number">1</span>;</span><br><span class="line">        f[l][r] = <span class="number">1e8</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt; r; k ++ )</span><br><span class="line">            f[l][r] = min(f[l][r], f[l][k] + f[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[<span class="number">1</span>][n]);</span><br></pre></td></tr></table></figure>
<h2 id="计数类DP"><a href="#计数类DP" class="headerlink" title="计数类DP"></a>计数类DP</h2><h3 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h3><blockquote>
<p>一个正整数n可以表示成若干个正整数之和，形如：$n=n_1+n_2+…+n_k=n_1+n_2+…+n_k$，其中$n_1≥n_2≥…≥n_k,k≥1,n_1≥n_2≥…≥n_k,k≥1$。</p>
<p>我们将这样的一种表示称为正整数n的一种划分。</p>
<p>现在给定一个正整数n，请你求出n共有多少种不同的划分方法</p>
<p>由于答案可能很大，输出结果请对10^9+7取模。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全背包</span></span><br><span class="line"><span class="comment">// f[i][j] 表示从1~i中选，和恰好为j的选法  的数量</span></span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j ++ )</span><br><span class="line">        f[j] = (f[j] + f[j - i]) % mod;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------</span></span><br><span class="line"><span class="comment">// f[i][j] 表示，和为i, 并且恰好表示为i个数的选法  的数量</span></span><br><span class="line"><span class="comment">// f[i][j] 的选法分为  最小值是1 和  最小值大于1 </span></span><br><span class="line"><span class="comment">// f[i][j] = f[i-1][j-1] + f[i-j][j]</span></span><br><span class="line"><span class="comment">// ans = f[n][1] + f[n][2] + ... f[n][n]</span></span><br><span class="line">f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++ )</span><br><span class="line">        f[i][j] = (f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - j][j]) % mod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = (res + f[n][i]) % mod;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="coin-change2"><a href="#coin-change2" class="headerlink" title="coin change2"></a>coin change2</h3><blockquote>
<p>You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全背包</span></span><br><span class="line"><span class="comment">// array中元素的值互异，每个元素可无限次取  从中选出任意个数|  返回组合种数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(amount+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j:coins)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=amount; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line">                f[i] += f[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;i&lt;&lt;" "&lt;&lt;f[i]&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Combination-Sum-IV"><a href="#Combination-Sum-IV" class="headerlink" title="Combination Sum IV"></a>Combination Sum IV</h3><blockquote>
<p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>
</blockquote>
<p><strong>array中元素的值互异，每个元素可无限次取 从中选出任意个数|  返回排列的种数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合：先循环每个元素，再循环target     元素的顺序固定</span></span><br><span class="line"><span class="comment">// 排列：先循环target, 再循环每个元素     元素的顺序不固定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(target+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=target; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j:nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(INT_MAX-f[i]&lt;=f[i-j])&#123; <span class="comment">// 防止中间的f[i]溢出</span></span><br><span class="line">                        f[i] = INT_MAX;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        f[i] += f[i-j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;i&lt;&lt;" "&lt;&lt;f[i]&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[target];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h2><h3 id="计数问题"><a href="#计数问题" class="headerlink" title="计数问题"></a>计数问题</h3><blockquote>
<p>给定两个整数 a 和 b，求 a 和 b 之间的所有数字中0~9的出现次数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// count(n,x) 1~n中x出现的次数</span></span><br><span class="line"><span class="comment">// [a,b]中x出现的次数 = count(b,x) - count(a-1,x)</span></span><br></pre></td></tr></table></figure>
<h3 id="No-Nine"><a href="#No-Nine" class="headerlink" title="No Nine"></a>No Nine</h3><h2 id="鸡蛋问题"><a href="#鸡蛋问题" class="headerlink" title="鸡蛋问题"></a>鸡蛋问题</h2><blockquote>
<p>一幢 100 层的大楼,给你两个鸡蛋. 如果在第 n 层扔下鸡蛋,鸡蛋不碎,那么从前 n-1 层扔鸡蛋都不碎. 这两只鸡蛋一模一样，不碎的话可以扔无数次. 已知鸡蛋在0层扔不会碎. 提出一个策略, 要保证能测出鸡蛋恰好不会碎的楼层, 并使此策略在<strong>最坏</strong>情况下所扔次数<strong>最少</strong>.</p>
</blockquote>
<p><a href="http://datagenetics.com/blog/july22012/index.html" target="_blank" rel="noopener">http://datagenetics.com/blog/july22012/index.html</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有n层楼，2个鸡蛋</span></span><br><span class="line"><span class="comment">// f[i]  表示i层楼, 2个鸡蛋，没有摔碎的最少尝试次数  f[0] = 0  </span></span><br><span class="line">itertate i from <span class="number">1</span> to n, j from <span class="number">1</span> to i</span><br><span class="line"><span class="comment">// f[i]   决策：从第j层扔第一个鸡蛋， 1&lt;=j&lt;=i 决策的最小值，对决策取最小  </span></span><br><span class="line"><span class="comment">//        情况： 第一个鸡蛋碎了，则第二个鸡蛋，需要从第一层开始试验，还需要扔j-1次</span></span><br><span class="line"><span class="comment">//              第一个鸡蛋没碎，则还有i-j层，还需要扔f[i-j]次</span></span><br><span class="line"><span class="comment">//        情况最坏，对情况取最大值</span></span><br><span class="line">f[i] = min(<span class="number">1</span> + max(j - <span class="number">1</span>, f[i - j]))</span><br><span class="line"><span class="comment">// ---------------------------------------</span></span><br><span class="line"><span class="comment">// 假设有n层楼，m个鸡蛋</span></span><br><span class="line"><span class="comment">// f[i][j]  表示i层楼, j个鸡蛋，没有摔碎的最少尝试次数  f[0][j] = 0  f[i][1] = i</span></span><br><span class="line">itertate i from <span class="number">1</span> to n, j from <span class="number">2</span> to m</span><br><span class="line"><span class="comment">// f[i][j]   决策：从第k层扔第一个鸡蛋， 1&lt;=k&lt;=i 决策的最小值，对决策取最小  </span></span><br><span class="line"><span class="comment">//        情况： 第一个鸡蛋碎了，则还有k-1层，j-1个鸡蛋，还需要扔f[k-1][j-1]次</span></span><br><span class="line"><span class="comment">//              第一个鸡蛋没碎，则还有i-k层, j个鸡蛋，还需要扔f[i-k][j]次</span></span><br><span class="line"><span class="comment">//        情况最坏，对情况取最大值</span></span><br><span class="line">f[i][j] = min(<span class="number">1</span> + max(f[k - <span class="number">1</span>][j - <span class="number">1</span>], f[i - k][j]))</span><br></pre></td></tr></table></figure>
<p><strong>Remember we need to mimimize the number of drops in the worst case, so we take the higher (max) of these two situations, and select the floor which yields the minimum number of drops.</strong></p>
<blockquote>
<p> 基于数学方程的方法 </p>
<p>假设最少尝试次数为x，那么，第一个鸡蛋必须要从第x层扔下，因为：如果碎了，前面还有x - 1层楼可以尝试，如果没碎，后面还有x-1次机会。如果没碎，第一个鸡蛋，第二次就可以从x +（x - 1）层进行尝试，为什么是加上x - 1，因为，当此时，第一个鸡蛋碎了，第二个鸡蛋还有可以从x+1 到 x + (x - 1) - 1层进行尝试，有x - 2次。如果还没碎，那第一个鸡蛋，第三次从 x + (x - 1) + (x - 2)层尝试。碎或者没碎，都有x - 3次尝试机会，依次类推。那么，x次的最少尝试，可以确定的最高的楼层是多少呢？ x + (x - 1) + (x - 2) + … + 1 = x(x+1) / 2 那反过来问，当最高楼层是100层，最少需要多少次呢？x(x+1)/2 &gt;= 100, 得到x&gt;=14，最少要尝试14次。</p>
</blockquote>
<h2 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h2><p>状态</p>
<ul>
<li>天数 i</li>
<li>交易次数限制 k</li>
<li>当前是否持有股票 </li>
</ul>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/</a></p>
<h2 id="最大子区间求和"><a href="#最大子区间求和" class="headerlink" title="最大子区间求和"></a>最大子区间求和</h2><h3 id="最大子区间求和-1"><a href="#最大子区间求和-1" class="headerlink" title="最大子区间求和"></a>最大子区间求和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the contiguous subarray within an array (containing at least one number) that has the largest sum.</span></span><br><span class="line"><span class="comment">// 动态规划 </span></span><br><span class="line"><span class="comment">// 状态定义：f(k) = Maximum sum of subarray ending at index k.</span></span><br><span class="line"><span class="comment">// 状态转移： f(k) = max( f(k-1) + A[k], A[k] ) </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_sub_array</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> max_ending_here = A[<span class="number">0</span>], max_so_far = A[<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.size(); i++) &#123; </span><br><span class="line">        max_ending_here = max(max_ending_here + A[i], A[i]); </span><br><span class="line">        max_so_far = max(max_ending_here, max_so_far); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> max_so_far; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大子区间求积"><a href="#最大子区间求积" class="headerlink" title="最大子区间求积"></a>最大子区间求积</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the contiguous subarray within an array(containing at least one number) of integers that has the largest product.</span></span><br><span class="line"><span class="comment">// f(k) = Largest product subarray, from index 0 up to k.</span></span><br><span class="line"><span class="comment">// g(k) = Smallest product subarray, from index 0 up to k.</span></span><br><span class="line"><span class="comment">// f(k) = max( f(k-1) * A[k], A[k], g(k-1) * A[k] )</span></span><br><span class="line"><span class="comment">// g(k) = min( g(k-1) * A[k], A[k], f(k-1) * A[k] )</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> maxP = A[<span class="number">0</span>], minP = A[<span class="number">0</span>], maxAns = A[<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> mx = maxP, mn = minP;</span><br><span class="line">        maxP = max(max(A[i], mx * A[i]), mn * A[i]);</span><br><span class="line">        minP = min(min(A[i], mx * A[i]), mn * A[i]);</span><br><span class="line">        maxAns = max(max, maxAns); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> maxAns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Maximum-Sum-Circular-Subarray"><a href="#Maximum-Sum-Circular-Subarray" class="headerlink" title="Maximum Sum Circular Subarray"></a>Maximum Sum Circular Subarray</h3><p><a href="https://leetcode.com/problems/maximum-sum-circular-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-sum-circular-subarray/</a></p>
<p><a href="https://leetcode.com/problems/maximum-sum-circular-subarray/discuss/178422/One-Pass" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-sum-circular-subarray/discuss/178422/One-Pass</a></p>
<p><img src="https://assets.leetcode.com/users/motorix/image_1538888300.png" alt="image"></p>
<p>So the max subarray circular sum equals to<br><code>max(the max subarray sum, the total sum - the min subarray sum)</code></p>
<p>One <strong>corner case</strong>  to pay attention:</p>
<p>If all number are negative,<br>return the maximum one,<br>(which equals to the max subarray sum)</p>
<p>(因为case2必须要保证MinSubarray是真subarray,从而保证有对应的MaxSubarray存在，假设MinSubarray即为整个subarray,则the total sum - the min subarray sum==0，只要array不是全部非负，则the max subarray sum必然大于等于0)</p>
<h3 id="最大子矩阵求和"><a href="#最大子矩阵求和" class="headerlink" title="最大子矩阵求和"></a>最大子矩阵求和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 矩阵中子矩阵最大和</span></span><br><span class="line"><span class="comment">// 预处理每一行 从0-j列的前缀和</span></span><br><span class="line"><span class="comment">// 1) 枚举j1,j2列，枚举i1,i2 O(N^4)</span></span><br><span class="line"><span class="comment">// 2) 枚举j1,j2列, 转化为最大子区间求和  O(N^3)</span></span><br></pre></td></tr></table></figure>
<h3 id="两个不重叠子区间最大和"><a href="#两个不重叠子区间最大和" class="headerlink" title="两个不重叠子区间最大和"></a>两个不重叠子区间最大和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到两个不相交的子区间A,B 使得sumA+sumB最大</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_max_sum</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s1(n,<span class="number">0</span>); <span class="comment">// s1[i]表示以a[0:i+1]的最大子区间</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s2(n,<span class="number">0</span>); <span class="comment">// s2[i]表示以a[i:n]的最大子区间</span></span><br><span class="line">    s1[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max_ending_here = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">		max_ending_here = max(max_ending_here+a[i], a[i]);</span><br><span class="line">        s1[i] = max(max_ending_here, s1[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    s2[n<span class="number">-1</span>] = a[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> max_begin_here = a[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        max_begin_here = max(max_begin_here+a[i], a[i]);</span><br><span class="line">        s2[i] = max(max_begin_here, s2[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++) ans  = max(ans, s1[i]+s2[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="固定长度，k个不重叠子区间最大和"><a href="#固定长度，k个不重叠子区间最大和" class="headerlink" title="固定长度，k个不重叠子区间最大和"></a>固定长度，k个不重叠子区间最大和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 2 3 4 5 6 5 4 3 2 1 10</span></span><br><span class="line"><span class="comment">// find 3 sub lenght=K seq, no overlap, make the sum of 3*K number max.  </span></span><br><span class="line"><span class="comment">// 1. O (N^3) 前缀和，ijk枚举三段</span></span><br><span class="line"><span class="comment">// 2. O (N)  </span></span><br><span class="line"><span class="comment">// f(i,1) 1~i </span></span><br><span class="line"><span class="comment">// f(i,2) 1~i = max(f(i-1,2),f(i-k,1)+s[i]-s[i-k]) </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">function</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> k = <span class="number">3</span>)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">int</span> n = a.size();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; f(<span class="number">4</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));<span class="comment">// 下标从1开始</span></span><br><span class="line">  	<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; s(n+<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 下标从1开始</span></span><br><span class="line">  	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) s[i] = s[i<span class="number">-1</span>] + a[i<span class="number">-1</span>]; <span class="comment">//s[i] = a[0] + ... + a[i-1]</span></span><br><span class="line">  	<span class="comment">// f[j][i]: [1, i]  </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=k; i&lt;=n; i++)</span><br><span class="line">    	f[<span class="number">1</span>][i] = max(f[<span class="number">1</span>][i<span class="number">-1</span>], s[i]-s[i-k]); </span><br><span class="line">  	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>*k; i&lt;=n; i++)</span><br><span class="line">    	f[<span class="number">2</span>][i] = max(f[<span class="number">2</span>][i<span class="number">-1</span>], f[<span class="number">1</span>][i-k]+s[i]-s[i-k]);</span><br><span class="line">  	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">3</span>*k; i&lt;=n; i++)</span><br><span class="line">    	f[<span class="number">3</span>][i] = max(f[<span class="number">3</span>][i<span class="number">-1</span>], f[<span class="number">2</span>][i-k]+s[i]-s[i-k]);</span><br><span class="line">  	<span class="keyword">return</span> f[<span class="number">3</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h1><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p><strong>越早被访问到的顶点，其邻居结点优先被访问</strong></p>
<p>广度优先搜索的通常用法是指定一个source,广度优先的遍历这个source所能到达的所有节点。<strong>相关的算法有：Prim’s minimum-spanning- tree algorithm and Dijkstra’s single-source shortest-paths algorithm </strong></p>
<h3 id="多源BFS"><a href="#多源BFS" class="headerlink" title="多源BFS"></a>多源BFS</h3><p><a href="https://leetcode.com/problems/01-matrix/" target="_blank" rel="noopener">https://leetcode.com/problems/01-matrix/</a></p>
<p>Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多源BFS</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; updateMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">-1</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; move = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    res[i][j]=<span class="number">0</span>;</span><br><span class="line">                    q.push(make_pair(i,j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> ux = q.front().first;</span><br><span class="line">            <span class="keyword">int</span> uy = q.front().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;move.size(); i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> vx = ux+move[i].first;</span><br><span class="line">                <span class="keyword">int</span> vy = uy+move[i].second;</span><br><span class="line">                <span class="keyword">if</span>(vx&gt;=<span class="number">0</span> <span class="keyword">and</span> vx&lt;m <span class="keyword">and</span> vy&gt;=<span class="number">0</span> <span class="keyword">and</span> vy&lt;n <span class="keyword">and</span> res[vx][vy]==<span class="number">-1</span>)&#123;</span><br><span class="line">                    res[vx][vy] = res[ux][uy]+<span class="number">1</span>;</span><br><span class="line">                    q.push(make_pair(vx,vy));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度$O(V+E)$</p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p><strong>优先选取最后一个被访问到的顶点的邻居</strong></p>
<p>​                  数据结构         空间复杂度  </p>
<p>BFS            queue               O(n)              最短路(边的距离为1)</p>
<p>DFS              stack                树的高度     不具有最短性</p>
<p>DP 有向无环图的最短路</p>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p><strong>恢复现场</strong>    <strong>注意搜索的顺序</strong></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95</a></p>
<p><strong>回溯法</strong>（英语：backtracking）是暴力搜索中的一种。</p>
<p>对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。</p>
<p>回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p>
<ul>
<li><strong>找到一个存在的正确的答案</strong></li>
<li><strong>在尝试了所有可能的分步方法后宣告该问题没有答案</strong></li>
</ul>
<p>在最坏的情况下，回溯法会导致一次复杂度为<strong>指数时间</strong>的计算</p>
<ul>
<li>剪枝：最优性剪枝  可行性剪枝</li>
</ul>
<h4 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h4><p>N=1或N&gt;=4才有解</p>
<p>搜索方式1：按行枚举放置的列数</p>
<p>搜索方式2：按格子枚举放置或者不放置 </p>
<p><a href="https://www.acwing.com/activity/content/code/content/47097/" target="_blank" rel="noopener">https://www.acwing.com/activity/content/code/content/47097/</a></p>
<p><strong>NOTE:</strong> Please don’t use <code>vector&lt;bool&gt; flag</code> to replace <code>vector&lt;int&gt; flag</code> in the following C++ code. In fact, <code>vector&lt;bool&gt;</code> is not a STL container. You should avoid to use it. You can also get the knowledge from <a href="http://stackoverflow.com/questions/17794569/why-is-vectorbool-not-a-stl-container" target="_blank" rel="noopener">here</a> and <a href="http://stackoverflow.com/questions/670308/alternative-to-vectorbool" target="_blank" rel="noopener">here</a>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用flag标志f the column or the diagonal had a queen before, if not, we can put a queen in this position and continue.</span></span><br><span class="line"><span class="comment">// col x=b    b=x   [0,n-1]    </span></span><br><span class="line"><span class="comment">// 45 y=x+b   b=x-y [1-n,n-1]+(n-1)  [0,2n-2]</span></span><br><span class="line"><span class="comment">// 135 y=x-b   b=x+y [0,2n-2]</span></span><br><span class="line"><span class="comment">// 按行枚举放置皇后的列数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;sstring&gt; &gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; nQueens(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; flag_col(n, <span class="number">1</span>), flag_45(<span class="number">2</span> * n - <span class="number">1</span>, <span class="number">1</span>), flag_135(<span class="number">2</span> * n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        solveNQueens(res, nQueens, flag_col, flag_45, flag_135, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveNQueens</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;nQueens, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;flag_col, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;flag_45, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;flag_135, <span class="keyword">int</span> row, <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;<span class="comment">//找到一个存在的正确答案</span></span><br><span class="line">            res.push_back(nQueens);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col != n; ++col)</span><br><span class="line">            <span class="keyword">if</span> (flag_col[col] &amp;&amp; flag_45[row + col] &amp;&amp; flag_135[n - <span class="number">1</span> + col - row]) &#123;</span><br><span class="line">                flag_col[col] = flag_45[row + col] = flag_135[n - <span class="number">1</span> + col - row] = <span class="number">0</span>;</span><br><span class="line">                nQueens[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">                solveNQueens(res, nQueens, flag_col, flag_45, flag_135, row + <span class="number">1</span>, n);</span><br><span class="line">                nQueens[row][col] = <span class="string">'.'</span>;</span><br><span class="line">                flag_col[col] = flag_45[row + col] = flag_135[n - <span class="number">1</span> + col - row] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="comment">// else 没有答案，剪枝</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Partition-to-K-Equal-Sum-Subsets"><a href="#Partition-to-K-Equal-Sum-Subsets" class="headerlink" title="Partition to K Equal Sum Subsets"></a>Partition to K Equal Sum Subsets</h4><p>leetcode 698</p>
<p><a href="https://www.geeksforgeeks.org/partition-set-k-subsets-equal-sum/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/partition-set-k-subsets-equal-sum/</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="图论基本概念"><a href="#图论基本概念" class="headerlink" title="图论基本概念"></a>图论基本概念</h2><p>边：无向边  有向边(更普适，无向边可以等价转换为有向边） </p>
<ul>
<li>只含有向边的图：有向图  </li>
<li>只含无向边的图：无向图</li>
<li>同时包含有向边和无向边的图：混合图 </li>
</ul>
<p>度： 无向图中与顶点v关联的边数</p>
<p>出度，入度：   有向图中的出边总数和入边总数</p>
<p>自环：连接于同一顶点的边</p>
<p>简单图：不包含自环的图</p>
<p>通路（Path）: 由m+1个顶点和m条边交替而成的序列：$\pi = \{v_0,e_1,v_1,e_2,v_2,…,e_m,v_m\} $</p>
<p>且对任何0&lt;i&lt;=m都有$e_i=(v_{i-1},v_i)$,即这些边依次首尾相连</p>
<ul>
<li>通路上的边必须互异，但顶点可能重复</li>
<li>沿途顶点互异的通路，成为<strong>简单通路</strong></li>
<li>对于m&gt;=1的通路，若起止点相同，则称为<strong>环路</strong></li>
<li>不含任何环路的有向图称为<strong>有向无环图</strong></li>
<li>除起止点外，沿途其他点均互异的环路称为<strong>简单环路</strong></li>
<li>经过图中各边一次且恰好一次的环路称为<strong>欧拉环路</strong></li>
<li>经过图中各点一次且恰好一次的环路称为<strong>哈密尔顿环路</strong></li>
</ul>
<p>带权图（边有权重） 无权图</p>
<p>邻接矩阵 邻接表       (v,v)  描述一对顶点之间可能存在的邻接关系</p>
<p>关联矩阵                    (v,e) 描述顶点与边之间可能存在的关联关系</p>
<h2 id="树和图的深度-广度优先遍历"><a href="#树和图的深度-广度优先遍历" class="headerlink" title="树和图的深度/广度优先遍历"></a>树和图的深度/广度优先遍历</h2><h3 id="树的深度优先遍历"><a href="#树的深度优先遍历" class="headerlink" title="树的深度优先遍历"></a>树的深度优先遍历</h3><ul>
<li>访问到一个新的节点时，该节点的子节点一定都是没有访问的，因此简单的递归调用即可实现</li>
</ul>
<p>二叉树的深度优先搜索可分为：</p>
<p>前序遍历：根结点 —-&gt; 左子树 —-&gt; 右子树</p>
<p>中序遍历：左子树—-&gt; 根结点 —-&gt; 右子树</p>
<p>后序遍历：左子树 —-&gt; 右子树 —-&gt; 根结点</p>
<p>图的深度优先搜索按各顶点被访问到的次序类似树的前序遍历；按各顶点访问结束的次序类似树的后序遍历</p>
<h4 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h4><p><a href="https://www.acwing.com/activity/content/problem/content/909/1/" target="_blank" rel="noopener">https://www.acwing.com/activity/content/problem/content/909/1/</a></p>
<p>// dfs返回子树的大小size1,size2,其余为n-size1-size2-1</p>
<h3 id="图的深度优先遍历"><a href="#图的深度优先遍历" class="headerlink" title="图的深度优先遍历"></a>图的深度优先遍历</h3><ul>
<li>访问到一个新的节点时，该节点的相邻节点可能已经访问过，已访问过的节点不用再访问</li>
</ul>
<blockquote>
<p>It may seem arbitrary that <strong>breadth-first search is limited to only one source whereas depth-first search may search from multiple sources</strong>. Although conceptually, breadth-first search could proceed from multiple sources and depth-first search could be limited to one source, our approach reflects how the results of these searches are typically used. <strong>Breadth-first search usually serves to find shortest- path distances (and the associated predecessor subgraph) from a given source. Depth-first search is often a subroutine in another algorithm, as we shall see later in this chapter</strong>. </p>
</blockquote>
<p>时间复杂度$O(V+E)$ </p>
<p><strong>Parenthesis theorem</strong></p>
<p>In any depth-first search of a (directed or undirected) graph $G+(V, E)$, for any two vertices $u$ and $v$ 􏰍, exactly one of the following three conditions holds:  </p>
<p>要么完全包含要么完全不重叠（不存在重叠一部分的情况）</p>
<ul>
<li>the intervals $[u.d, u.f]$ and $[v.d, v.f]$ are entirely disjoint, and neither $u$ nor $v$ 􏰍 is a descendant of the other in the depth-first forest </li>
<li>the interval $[u.d, u.f]$ is contained entirely within the interval $[v.d, v.f]$ ,and $u$ is a descendant of 􏰍$v$ in a depth-first tree, or </li>
<li>the interval $[v.d, v.f]$ is contained entirely within the interval  $[u.d, u.f]$􏰌, and 􏰍$v$  is a descendant of $u$ in a depth-first tree. </li>
</ul>
<p><strong>Classification of edges</strong></p>
<p>We can define four edge types in terms of the depth-first forest $G_\pi$􏰂 produced by a depth-first search on $G$: </p>
<ul>
<li><strong>Tree edges</strong> are edges in the depth-first forest $G_\pi$􏰂. Edge$(u,v)$ is a tree edge if􏰍 $v$ was first discovered by exploring edge$(u, v)$.  </li>
<li><strong>Back edges</strong> are those edges$(u, v)$ connecting a vertex $u$ to an ancestor $v$ 􏰍 in a depth-first tree. We consider self-loops, which may occur in directed graphs, to be back edges. </li>
<li><strong>Forward edges</strong> are those nontree edges$(u, v)$ connecting a vertex $u$ to a descendant 􏰍$v$ in a depth-first tree. </li>
<li><strong>Cross edges</strong> are all other edges. They can go between vertices in the same depth-first tree, as long as one vertex is not an ancestor of the other, or they can go between vertices in different depth-first trees. </li>
</ul>
<p>The DFS algorithm has enough information to classify some edges as it encounters them. The key idea is that when we first explore an edge$(u, v)$, the color of vertex $v$􏰍 tells us something about the edge: </p>
<ol>
<li>WHITE indicates a tree edge, </li>
<li>GRAY indicates a back edge, and </li>
<li>BLACK indicates a forward or cross edge. (edge $(u, v)$ is a forward edge if $u.d &lt; v.d$ and a cross edge if $u.d &gt; v.d$. )</li>
</ol>
<p><strong>无向图</strong>：</p>
<p>An undirected graph may entail some ambiguity in how we classify edges, since $(u, v)$ and $(v， u)$ are really the same edge. In such a case, we classify the edge as the first type in the classification list that applies. Equivalently, we classify the edge according to whichever of $(u, v)$ or $(v， u)$ the search encounters first. </p>
<p><strong>In a depth-first search of an undirected graph G, every edge of G is either a tree edge or a back edge. </strong></p>
<h4 id="Find-Eventual-Safe-States"><a href="#Find-Eventual-Safe-States" class="headerlink" title="Find Eventual Safe States"></a>Find Eventual Safe States</h4><p><a href="https://leetcode.com/problems/find-eventual-safe-states/" target="_blank" rel="noopener">https://leetcode.com/problems/find-eventual-safe-states/</a></p>
<p><a href="https://leetcode.com/problems/find-eventual-safe-states/discuss/119871/Straightforward-Java-solution-easy-to-understand!" target="_blank" rel="noopener">https://leetcode.com/problems/find-eventual-safe-states/discuss/119871/Straightforward-Java-solution-easy-to-understand!</a></p>
<p>value of color represents three states:<br>0:have not been visited<br>1:safe<br>2:unsafe<br>For DFS,we need to do some optimization.When we travel a path,we mark the node with 2 which represents having been visited,and when we encounter a node which results in a cycle,we return false,all node in the path stays 2 and it represents unsafe.And in the following traveling,whenever we encounter a node which points to a node marked with 2,we know it will results in a cycle,so we can stop traveling.On the contrary,when a node is safe,we can mark it with 1 and whenever we encounter a safe node,we know it will not results in a cycle.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">eventualSafeNodes</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(graph == <span class="keyword">null</span> || graph.length == <span class="number">0</span>)  <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> nodeCount = graph.length;</span><br><span class="line">        <span class="keyword">int</span>[] color = <span class="keyword">new</span> <span class="keyword">int</span>[nodeCount];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nodeCount;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(graph, i, color))    res.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> start, <span class="keyword">int</span>[] color)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(color[start] != <span class="number">0</span>)   <span class="keyword">return</span> color[start] == <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        color[start] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> newNode : graph[start])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(graph, newNode, color))    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        color[start] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="noopener">https://leetcode.com/problems/course-schedule/</a></p>
<p><a href="https://leetcode.com/problems/course-schedule-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/course-schedule-ii/</a></p>
<p>BFS： 要想完成拓扑排序，我们每次都应当从入度为0的结点开始遍历。因为只有入度为0的结点才能够成为拓扑排序的起点。<strong>这一改进后的算法与普通的广度优先遍历唯一的区别在于我们应当保存每一个结点对应的入度，并在遍历的每一层选取入度为0的结点开始遍历</strong>（多源BFS）</p>
<p><a href="https://www.jianshu.com/p/3347f54a3187" target="_blank" rel="noopener">https://www.jianshu.com/p/3347f54a3187</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopologicalSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get topological ordering of the input directed graph </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n number of nodes in the graph</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> adjacencyList adjacency list representation of the input directed graph</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> topological ordering of the graph stored in an List&lt;Integer&gt;. </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topologicalSort</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] adjacencyList)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; topoRes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] parent : adjacencyList) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : parent) &#123;</span><br><span class="line">                inDegree[child]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// start from nodes whose indegree are 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) deque.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = deque.poll();</span><br><span class="line">            topoRes.add(curr);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : adjacencyList[curr]) &#123;</span><br><span class="line">                inDegree[child]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[child] == <span class="number">0</span>) &#123;</span><br><span class="line">                    deque.offer(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> topoRes.size() == n ? topoRes : <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DFS  按照访问结束的顺序  逆序输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        <span class="comment">// 构建图的邻接表</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph(numCourses,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prerequisites.size(); i++)&#123;</span><br><span class="line">            graph[prerequisites[i][<span class="number">1</span>]].push_back(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// topological sort</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visit(numCourses,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>; u&lt;numCourses; u++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[u]==<span class="number">0</span> &amp;&amp; !dfs(graph,visit,res,u))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(),res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visit, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res, <span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        visit[u]=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;graph[u].size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = graph[u][i];</span><br><span class="line">            <span class="keyword">if</span>(visit[v]==<span class="number">0</span>) dfs(graph,visit,res,v); <span class="comment">// 0 树边 递归搜索</span></span><br><span class="line">            <span class="keyword">if</span>(visit[v]==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 1 反向边，存在环   // 2 前向边 交叉边</span></span><br><span class="line">        &#125;</span><br><span class="line">        visit[u]=<span class="number">2</span>;</span><br><span class="line">        res.push_back(u);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><p><strong>注：难点在于抽象问题，建图</strong></p>
<p><a href="https://www.acwing.com/blog/content/27/" target="_blank" rel="noopener">https://www.acwing.com/blog/content/27/</a></p>
<h3 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h3><h4 id="所有边的权重都为正数"><a href="#所有边的权重都为正数" class="headerlink" title="所有边的权重都为正数"></a>所有边的权重都为正数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dijkstra 贪心</span></span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"><span class="comment">朴素：</span></span><br><span class="line"><span class="comment">d[s]=0 </span></span><br><span class="line"><span class="comment">for each v in V-&#123;s&#125;: d[v] = INF</span></span><br><span class="line"><span class="comment">for each v in V: S[v] = False //标志是否已找到离源点的最短路 </span></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"><span class="comment">iterate v次//每次找到一个点到源点的最短路</span></span><br><span class="line"><span class="comment">t&lt;-不在S中的距离最近的点(需要遍历一遍所有点，S[v]=false,且d[v]最小)</span></span><br><span class="line"><span class="comment">S[t]=True</span></span><br><span class="line"><span class="comment">for each v in adj(u)//更新其邻接点到源点的距离,直接更改</span></span><br><span class="line"><span class="comment">    d[v] = min(d[v],d[u]+w_uv)</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line"><span class="comment">堆优化：手写堆</span></span><br><span class="line"><span class="comment">d[s]=0 </span></span><br><span class="line"><span class="comment">for each v in V-&#123;s&#125;: d[v] = INF</span></span><br><span class="line"><span class="comment">Q.push&#123;d[s],s&#125;</span></span><br><span class="line"><span class="comment">while Q is not empty</span></span><br><span class="line"><span class="comment">    u&lt;-extract_min(Q)</span></span><br><span class="line"><span class="comment">    Q.pop()</span></span><br><span class="line"><span class="comment">    for each v in adj(u)//用t更新其邻接点到源点的距离,删除原距离，添加新距离</span></span><br><span class="line"><span class="comment">        if d[v]&gt;d[u]+w_uv</span></span><br><span class="line"><span class="comment">            Q.erase(&#123;d[v],v&#125;)</span></span><br><span class="line"><span class="comment">            d[v] = d[u]+w_uv</span></span><br><span class="line"><span class="comment">            Q.push(&#123;d[v],v&#125;)</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">------</span></span><br><span class="line"><span class="comment">堆优化： STL priority queue// 无法直接删除指定节点</span></span><br><span class="line"><span class="comment">d[s]=0 </span></span><br><span class="line"><span class="comment">for each v in V-&#123;s&#125;: d[v] = INF</span></span><br><span class="line"><span class="comment">for each v in V: S[v] = False //标志是否已找到离源点的最短路 </span></span><br><span class="line"><span class="comment">Q.push&#123;d[s],s&#125;</span></span><br><span class="line"><span class="comment">while Q is not empty</span></span><br><span class="line"><span class="comment">    t&lt;-extract_min(Q)</span></span><br><span class="line"><span class="comment">    Q.pop()</span></span><br><span class="line"><span class="comment">    if s[t]==true</span></span><br><span class="line"><span class="comment">        continue</span></span><br><span class="line"><span class="comment">    s[t] = true</span></span><br><span class="line"><span class="comment">    for each v in adj(u)//用t更新其邻接点到源点的距离,不删除原距离(冗余节点)，添加新距离</span></span><br><span class="line"><span class="comment">        if d[v]&gt;d[u]+w_uv</span></span><br><span class="line"><span class="comment">            d[v] = d[u]+w_uv</span></span><br><span class="line"><span class="comment">            Q.push(&#123;d[v],v&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度$O(N<em>T(getmin)+M</em>T(update))$</p>
<h5 id="朴素Dijkstra"><a href="#朴素Dijkstra" class="headerlink" title="朴素Dijkstra"></a>朴素Dijkstra</h5><p>时间复杂度：$O(N^2)$ 适用于稠密图</p>
<h5 id="堆优化Dijkstra"><a href="#堆优化Dijkstra" class="headerlink" title="堆优化Dijkstra"></a>堆优化Dijkstra</h5><p>时间复杂度: $O(MlogN)$ 适用于稀疏图</p>
<h4 id="存在负权边"><a href="#存在负权边" class="headerlink" title="存在负权边"></a>存在负权边</h4><h5 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">d[s]=0</span></span><br><span class="line"><span class="comment">for each v in V-&#123;s&#125;: d[v] = INF</span></span><br><span class="line"><span class="comment">for |V|-1次  //迭代k次后的dist，一定保证能找到从源点，经过不超过k条边的最短路</span></span><br><span class="line"><span class="comment">    for 所有边 a-&gt;b,w</span></span><br><span class="line"><span class="comment">        dist[b] = min(dist[b],dist[a]+w)  // 松弛操作</span></span><br><span class="line"><span class="comment">for 所有边 a-&gt;b,w</span></span><br><span class="line"><span class="comment">    if dist[b] &gt; dist[a]+w</span></span><br><span class="line"><span class="comment">         存在负环</span></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"><span class="comment">若不存在负环，longest simple path has &lt;=|V|-1条边，循环|V|-1次后，能找到所有最短路，对于所有的边a-&gt;b,w 均有 dist[b]&lt;=dist[a]+w</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(NM)$</p>
<h6 id="Within-K-Stops"><a href="#Within-K-Stops" class="headerlink" title="Within K Stops"></a>Within K Stops</h6><p>There are <code>n</code> cities connected by <code>m</code> flights. Each fight starts from city <code>u</code>and arrives at <code>v</code> with a price <code>w</code>. Now given all the cities and flights, together with starting city <code>src</code> and the destination <code>dst</code>, your task is to find the cheapest price from <code>src</code> to <code>dst</code> with up to <code>k</code>stops. If there is no such route, output <code>-1</code>.</p>
<p><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/discuss/115596/c%2B%2B-8-line-bellman-ford" target="_blank" rel="noopener">https://leetcode.com/problems/cheapest-flights-within-k-stops/discuss/115596/c%2B%2B-8-line-bellman-ford</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//bellman ford.</span></span><br><span class="line">    <span class="comment">//just run it k+1 iterations.</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="keyword">int</span> src, <span class="keyword">int</span> sink, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c(n, <span class="number">1e8</span>);</span><br><span class="line">        c[src] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> z=<span class="number">0</span>; z&lt;=k; z++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C(c);<span class="comment">//备份上一次的结果，保证不发生串联更新</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> e: a)</span><br><span class="line">                c[e[<span class="number">1</span>]] = min(c[e[<span class="number">1</span>]], C[e[<span class="number">0</span>]] + e[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c[sink] == <span class="number">1e8</span> ? <span class="number">-1</span> : c[sink];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​        In the original Bellman-Ford algorithm, <code>C[e[1]] = min(C[e[1]], c[e[0]] + e[2]);</code> or Relaxation as it is called in the CLRS is called (|G.V| -1) times which is the longest possible stops in the whole graph. The proof of Bellman-Ford lies in <a href="https://www.cl.cam.ac.uk/teaching/1516/Algorithms/shortestpath.pdf" target="_blank" rel="noopener">Path-Relaxation Property(Lemma 24.15 in CLRS)</a> .So in this problem we have only “relaxed” for k+1 times. If such a path( shortest path within k stops) truly exists then yes, no problem. If not,, two cases: one, the destination is unreachable from src, which gives infinite distance; case two, a shortest path exists with more than k stops. k+1 times of relaxation may and may not find such a path(this is highly related to how the subvectors inside flights vector are arranged) , so you have to double check that.</p>
<p>​         But notice here you used two vector storing shortest paths, C being the last time’s shortest path, c being the current one. In this way, you cannot successively get two shortest path along the line! This means with k+1 times relaxations you cannot even change c[dest]’s value of infinity if theoretical shortest path has more than k stops. </p>
<h5 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h5><p>时间复杂度：一般$O(M)$ 最坏$O(NM)$</p>
<p>但需要注意的是，在网格图中，spfa算法的效率比较低，如果边权为正，则尽量使用 dijkstra 算法。</p>
<p>用BFS对Bellman-Ford算法的优化,利用了每个点不会更新次数太多的特点</p>
<blockquote>
<p>具体做法是用一个队列保存待松弛的点，然后对于每个出队的点依次遍历每个与他有边相邻的点，如果该点可以松弛并且队列中没有该点则将它加入队列中(只有进行松弛操作的点才会对它的邻接点有影响，也就是说其邻接点才需要松弛操作)，如此迭代直到队列为空。</p>
<p>SPFA 在形式上和宽度优先搜索非常类似，不同的是宽度优先搜索中一个点出了队列就不可能重新进入队列，但是SPFA中一个点可能在出队列之后再次被放入队列，也就是一个点改进过其它的点之后，过了一段时间可能本身被改进，于是再次用来改进其它的点，这样反复迭代下去。设一个点用来作为迭代点对其它点进行改进的平均次数为k，有办法证明对于通常的情况，k在2左右</p>
</blockquote>
<p><a href="https://blog.csdn.net/u013445530/article/details/41761687" target="_blank" rel="noopener">https://blog.csdn.net/u013445530/article/details/41761687</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">不存在负环的情况</span></span><br><span class="line"><span class="comment">d[s]=0 </span></span><br><span class="line"><span class="comment">for each v in V-&#123;s&#125;: d[v] = INF</span></span><br><span class="line"><span class="comment">for each v in V: S[v] = False //标志是否在队列中</span></span><br><span class="line"><span class="comment">Q.push(s)</span></span><br><span class="line"><span class="comment">S[s]=True</span></span><br><span class="line"><span class="comment">while Q is not empty</span></span><br><span class="line"><span class="comment">   u&lt;-Q.front()</span></span><br><span class="line"><span class="comment">   Q.pop()</span></span><br><span class="line"><span class="comment">   S[u]=False</span></span><br><span class="line"><span class="comment">   for each v in adj(u)//更新u的所有邻接点v,若v松弛成功且不队列，则Q.push(v)</span></span><br><span class="line"><span class="comment">       if d[v]&gt;d[u]+w_uv</span></span><br><span class="line"><span class="comment">           d[v]=d[u]+w_uv</span></span><br><span class="line"><span class="comment">           if S[v]==False</span></span><br><span class="line"><span class="comment">              Q.push(v)</span></span><br><span class="line"><span class="comment">              S[v]=True</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">判断是否存在负环</span></span><br><span class="line"><span class="comment">d[s]=0 </span></span><br><span class="line"><span class="comment">for each v in V-&#123;s&#125;: d[v] = INF</span></span><br><span class="line"><span class="comment">for each v in V: S[v] = False //标志是否在队列中</span></span><br><span class="line"><span class="comment">for each v in V: c[v] = 0// 当前最短路边数</span></span><br><span class="line"><span class="comment">for each v in V: </span></span><br><span class="line"><span class="comment">    Q.push(v) </span></span><br><span class="line"><span class="comment">    S[v]=True</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">while Q is not empty</span></span><br><span class="line"><span class="comment">   u&lt;-Q.front()</span></span><br><span class="line"><span class="comment">   Q.pop()</span></span><br><span class="line"><span class="comment">   S[s]=False</span></span><br><span class="line"><span class="comment">   for each v in adj(u)//更新u的所有邻接点v,若v松弛成功且不队列，则Q.push(v)</span></span><br><span class="line"><span class="comment">       if d[v]&gt;d[u]+w_uv</span></span><br><span class="line"><span class="comment">           d[v]=d[u]+w_uv</span></span><br><span class="line"><span class="comment">           c[v]=c[u]+1</span></span><br><span class="line"><span class="comment">           if c[v]&gt;=|V|</span></span><br><span class="line"><span class="comment">               存在负环</span></span><br><span class="line"><span class="comment">           if S[v]==False</span></span><br><span class="line"><span class="comment">              Q.push(v)</span></span><br><span class="line"><span class="comment">              S[v]=True</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="多源汇最短路"><a href="#多源汇最短路" class="headerlink" title="多源汇最短路"></a>多源汇最短路</h3><h4 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h4><p>时间复杂度：$O(N^3)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// d[i][j] 初始化：没有任何中间点的距离值</span></span><br><span class="line"><span class="comment">// d[i][j] 表示只经过1~k作为中间点，从i到j的最短路径</span></span><br><span class="line"><span class="comment">// for (k=1; k&lt;=n; k++)</span></span><br><span class="line"><span class="comment">//    for (i=1; i&lt;=n; i++)</span></span><br><span class="line"><span class="comment">//        for (j=1; j&lt;=n; j++)</span></span><br><span class="line"><span class="comment">//            d[i][j] = min(d[i][j], d[i][k]+d[k][j])</span></span><br></pre></td></tr></table></figure>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>定理：设$G=(V,E)$是一个在边$E$上定义了实数值权重$w$的连通无向图，设集合$A$为$E$的一个子集，且$A$包括在图$G$的某棵最小生成树$T$中，设$(S,V-S)$是图$G$中尊重集合$A$的任意一个切割，又设$(u,v)$是横跨切割$(S,V-S)$的一条轻量级边，则边$(u,v)$对于$A$是安全的。</p>
<p><strong>在kruskal算法中，集合A是森林，其结点是给定图的结点，每次加入到集合A中的安全边永远是权重最小的连接两个不同分量的边</strong></p>
<p><strong>在Prim算法中，集合A则是一棵树，每次加入到A中的安全边永远是连接A和A之外的某个结点的边中权重最小的边</strong></p>
<h3 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稠密图： 朴素版prim  O(n^2)</span></span><br><span class="line">朴素：</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> each v in V-&#123;s&#125;: d[v] = INF</span><br><span class="line">d[s]=<span class="number">0</span> <span class="comment">// for some arbitray s in V</span></span><br><span class="line"><span class="keyword">for</span> each v in V: S[v] = False <span class="comment">//标志是否在连通块的集合中</span></span><br><span class="line">---</span><br><span class="line">iterate v次<span class="comment">//每次找到一个点到源点的最短路</span></span><br><span class="line">t&lt;-不在S中的距离最近的点(需要遍历一遍所有点，S[v]=<span class="literal">false</span>,且d[v]最小)</span><br><span class="line">S[t]=True</span><br><span class="line"><span class="keyword">if</span>(d[t]==INF) <span class="keyword">return</span> INF <span class="comment">// 不连通</span></span><br><span class="line"><span class="keyword">else</span> res += d[t]</span><br><span class="line"><span class="keyword">for</span> each v in adj(u)<span class="comment">//更新其邻接点到**集合**的距离,直接更改</span></span><br><span class="line">    d[v] = min(d[v], w_uv)</span><br><span class="line"><span class="comment">//---------------------------------------------------------------    </span></span><br><span class="line"><span class="comment">// 稀疏图：堆优化版prim  O(mlogn)</span></span><br></pre></td></tr></table></figure>
<h3 id="kruskal-算法"><a href="#kruskal-算法" class="headerlink" title="kruskal 算法"></a>kruskal 算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稀疏图： kruskal算法 O(mlogn)</span></span><br><span class="line"><span class="comment">// 最小生成树</span></span><br><span class="line"><span class="comment">//  无向图 n个点 m条边 挑出n-1条边，使得n个点连通且所有边的权值和最小</span></span><br><span class="line"><span class="comment">//   等价于   n-1条边中最大的边最小</span></span><br><span class="line"><span class="comment">// 将m条边按从小到大排序，依次判断新加入这条边是否和之前的成环，成则舍弃，不成则加进来（用并查集判断）</span></span><br><span class="line"><span class="comment">// O(MlogM)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = find(a), b = find(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><h3 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 染色法 O(n+m) DFS</span></span><br><span class="line"><span class="comment">// 判断一个图是不是二分图 </span></span><br><span class="line"><span class="comment">// 把一个图的所有点分为两个集合,集合内部没有边</span></span><br><span class="line"><span class="comment">// 二分图 &lt;=&gt; 图中不含有奇数环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!color[j]) <span class="comment">// 无向图只有树边和环边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(j, <span class="number">3</span> - c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">if</span> (!color[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfs(i, <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(mn) 实际情况一般远小于O(mn)</span></span><br><span class="line"><span class="comment">// 二分图的匹配：给定一个二分图G，在G的一个子图M中，M的边集&#123;E&#125;中的任意两条边都不依附于同一个顶点，则称M是一个匹配。</span></span><br><span class="line"><span class="comment">// 二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || find(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">if</span> (find(i)) res ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br></pre></td></tr></table></figure>
<h2 id="图的连通"><a href="#图的连通" class="headerlink" title="图的连通"></a>图的连通</h2><p>连通   双连通  强连通 <a href="https://www.cnblogs.com/szy-wlxy/p/4639316.html" target="_blank" rel="noopener">https://www.cnblogs.com/szy-wlxy/p/4639316.html</a></p>
<p>所谓连通与强连通，最大的差别，也是最本质的差别就是前者适用于无向图中，而后者适用于有向图。至于两者的概念是一样的，就是图中有a点、b点，从a点可到达b点，同时从b点可到达a点。（若是有向图必须延方向到达。）    </p>
<ul>
<li>无向图是否连通：dfs,bfs搜索 </li>
<li>Union Find（判断无向图中任意两个点是否连通）</li>
</ul>
<p>在图论中，一个有向图被称为是<strong>强连通的</strong>（strongly connected）当且仅当每一对不相同结点 u 和 v 间既存在从 u 到 v 的路径也存在从 v 到 u 的路径（<strong>u-&gt;v和v-&gt;u路径中可以有重复边</strong>）。有向图的极大强连通子图（这里指点数极大）被称为<strong>强连通分量</strong>（strongly connected component）。</p>
<ul>
<li>传递闭包  floyd算法（和强连通关系） 判断是否为强连通图</li>
<li><a href="https://www.cnblogs.com/mhpp/p/6751723.html#_nav_1" target="_blank" rel="noopener">https://www.cnblogs.com/mhpp/p/6751723.html#_nav_1</a></li>
<li><a href="http://blog.miskcoo.com/2016/07/tarjan-algorithm-strongly-connected-components" target="_blank" rel="noopener">http://blog.miskcoo.com/2016/07/tarjan-algorithm-strongly-connected-components</a></li>
</ul>
<blockquote>
<p>定义DFN(u)为节点u搜索的次序编号(时间戳)，Low(u)为u或u的子树能够追溯到的最早的栈中节点的次序号。由定义可以得出，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; Low(u)=Min</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     DFN(u),</span><br><span class="line">&gt;     Low(v),(u,v)为树枝边，u为v的父节点</span><br><span class="line">&gt;     DFN(v),(u,v)为指向栈中节点的后向边或横叉边 //当前节点的后向边一定在栈中,横叉边则不一定</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>算法伪代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tarjan(u)</span><br><span class="line">&#123;</span><br><span class="line">    DFN[u]=Low[u]=++Index                      // 为节点u设定次序编号和Low初值</span><br><span class="line">    Stack.push(u)                              // 将节点u压入栈中</span><br><span class="line">    for each (u, v) in E                       // 枚举每一条边</span><br><span class="line">        if (v is not visted)               // 如果节点v未被访问过</span><br><span class="line">            tarjan(v)                  // 继续向下找</span><br><span class="line">            Low[u] = min(Low[u], Low[v])</span><br><span class="line">        else if (v in S)                   // 如果节点v还在栈内，用bool数组储存是否在栈内的信息</span><br><span class="line">            Low[u] = min(Low[u], DFN[v])</span><br><span class="line">    if (DFN[u] == Low[u])                      // 如果节点u是强连通分量的根</span><br><span class="line">        repeat</span><br><span class="line">            v = S.pop                  // 将v退栈，为该强连通分量中一个顶点</span><br><span class="line">            print v</span><br><span class="line">        until (u== v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中双连通分量可细分为：点-双连通分量，边-双连通分量。所谓点-双连通分量是指在一个无向图中两点间至少有两条路径，且路径中（不算头尾）的点不同。不同的点-双连通分量最多有一个公共点，这个点必定是“割顶”。提到割顶不得不在这里啰嗦一下，割顶（如下图）就是当删去这个点时，连通块的数量会增加。至于什么叫连通块，可以理解为一个点的集合，若两点间可直接或间接的连接则两点在同一连通块中。</p>
<blockquote>
<p>一个顶点u是割点，当且仅当满足(1)或(2) </p>
<p>(1) u为树根，且u有多于一个子树（按DFS访问有多于一个的子树）</p>
<p> (2) u不为树根，且满足存在(u,v)为树枝边(或称父子边，即u为v在搜索树中的父亲)，使得DFN(u)&lt;=Low(v)。</p>
</blockquote>
<p>至于边-双连通分量是指在一个无向图中两点间至少有两条路径，且路径中的边不同。边-双连通分量中一定没有桥。而桥（如上图）是指当删去这个边时，连通块的数量会增加。</p>
<blockquote>
<p>一条无向边(u,v)是桥，当且仅当(u,v)为树枝边，且满足DFN(u)&lt;Low(v)。</p>
</blockquote>
<ul>
<li>无向图 每个点若干巧克力，任意起始点终点的一条路，拿到最多的巧克力-&gt;找最’大‘的连通分量</li>
<li>有向无环图： 拓扑排序，按逆序动态规划</li>
<li>有向图： 强连通分量 缩点  -&gt; 无环   再按拓扑排序按逆序动态规划</li>
</ul>
<h2 id="Union-Find-Set"><a href="#Union-Find-Set" class="headerlink" title="Union Find Set"></a>Union Find Set</h2><ul>
<li>将两个集合合并</li>
<li>询问两个元素是否在一个集合当中</li>
</ul>
<p>基本原理：</p>
<ul>
<li>每个集合用一棵树表示，树根的编号就是整个集合的编号。每个节点存储它的父节点，f[x]表示x的父节点</li>
<li>问题1：如何判断树根： f[x]==x</li>
<li>问题2： 如何求x的集合编号： while(x!=f[x])  x = f[x]</li>
<li>问题3： f[y]=x</li>
</ul>
<p><strong>时间复杂度分析</strong></p>
<p>Let n denote the overall number of elements (equivalently, the number of MAKE-SET operations). </p>
<p>Let m denote the total number of operations.</p>
<p>Let f denote the number of FIND-SET operations</p>
<ul>
<li>only Trick 1: Smaller into larger (Merge tree with smaller weight into tree with larger weight.)<ul>
<li>Theorem: Cost of all UNION’s is O(m+f lg n).</li>
<li>Height of tree increases only when its size doubles, so height is logarithmic in weight. Thus total cost is O(m + f lg n).</li>
</ul>
</li>
<li>only Trick 2: Path compression<ul>
<li>Total cost of FIND-SET’s is O(m lg n).     （Amortization by potential function.）</li>
<li>If all UNION operations occur before all FIND-SET operations, then total cost is O(m).</li>
</ul>
</li>
<li>with both trick <ul>
<li>We will build a simple disjoint-union data structure that, in an amortized sense, performs significantly better than Θ(lg n) per op., even better than Θ(lg lg n), Θ(lg lg lg n), etc., but not quite Θ(1). </li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Union Find 规范写法：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Union_Find</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Union_Find (<span class="keyword">int</span> N) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            f.push_back(i);</span><br><span class="line">            sz.push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootA = Find(A);</span><br><span class="line">        <span class="keyword">int</span> rootB = Find(B);</span><br><span class="line">        <span class="keyword">if</span> (rootA == rootB) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (sz[rootA] &lt; sz[rootB]) &#123;</span><br><span class="line">            f[rootA] = rootB;</span><br><span class="line">            sz[rootB] += sz[rootA];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f[rootB] = rootA;</span><br><span class="line">            sz[rootA] += sz[rootB];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p != f[p]) &#123;</span><br><span class="line">            f[p] = Find(f[p]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[p];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> s : sz)</span><br><span class="line">            res = max(res, s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sz;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-islands/</a></p>
<h1 id="区间和-最值查询"><a href="#区间和-最值查询" class="headerlink" title="区间和/最值查询"></a>区间和/最值查询</h1><p>整个数组给定不变，在线给定查询，多次查询给定区间[left,right)，返回sum ———累加</p>
<h3 id="Sparse-Table算法-数组给定不变"><a href="#Sparse-Table算法-数组给定不变" class="headerlink" title="Sparse_Table算法 (数组给定不变)"></a>Sparse_Table算法 (数组给定不变)</h3><p>整个数组给定不变，在线给定查询，多次查询给定区间[left,right)，返回min/max</p>
<p><a href="https://www.cnblogs.com/yyxayz/p/4109390.html" target="_blank" rel="noopener">https://www.cnblogs.com/yyxayz/p/4109390.html</a></p>
<p>Sparse_Table算法，是一个快速求区间最值的离线算法，预处理时间复杂度O（n*log(n)），查询O(1)，所以是一个很快速的算法，当然这个问题用线段树同样能够解决。</p>
<p>多次查询给定区间[left,right)，返回max/min ——— 动态规划   倍增状态</p>
<ul>
<li><p>预处理：</p>
<p>设数组$maxn[i][j]$ 表示给定的数组从下标i开始，长度为2^j的区间最大值(最小值一样)也就是arr[i]——arr[i+2^j-1]这个区间的最大值。于是我们可以写出这样一个动态转移方程$maxn[i][j] = max(maxn[i][j-1], maxn[i-2^{j-1}][j-1])$</p>
<p>其实就是把区间$[i,i+2^j-1]$分成两段，一段是$[i,i+2^{j-1}-1]$和$[i+2^{j-1},i+2^j-1]$<strong>(一直记住二维数组后面一维表示的是区间的长度2^j)</strong></p>
<p>那么对于$maxn[i][j]$当j等于0，也就是区间长度为1的最大值显然就有$maxn[i][0]=arr[i]$;</p>
</li>
<li><p>查询：</p>
<p>注意到我们的最值数组存的都是区间长度为2^k(k=0,1,2,3…..)次方的最值</p>
<p>所以对于区间[a,b] 我们肯定要划分为两个区间长度是$2^x$, $ 2^y$的区间才可以直接利用我们得到的最值数组来求最值嘛 这里有两个未知数不好求，我们可以直接取k，对于k满足a+2^k-1=b  k=log2(b-a+1) 那么区间a,b的最大值就是$max(maxn[a][k], maxn[b-2^k+1][k])$</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getbestarr</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//n为给定的数组的长度  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="keyword">int</span> tem = (<span class="keyword">int</span>)<span class="built_in">floor</span>(log2((<span class="keyword">double</span>)n));<span class="comment">//因为区间的最长长度是2^tem==n嘛  </span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)  </span><br><span class="line">        minn[i][<span class="number">0</span>]= maxn[i][<span class="number">0</span>] = arr[i];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tem;j++) <span class="comment">//下标从1开始  </span></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">             maxn[i][j] = max(maxn[i][j<span class="number">-1</span>],maxn[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);  <span class="comment">//最大值  </span></span><br><span class="line">             minn[i][j] = min(minn[i][j<span class="number">-1</span>],minn[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);  <span class="comment">//最小值  </span></span><br><span class="line">        &#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">bool</span> getwhat)</span><span class="comment">//getwhat表示你是想取最大还是最小  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="keyword">int</span> k = log2(b-a+<span class="number">1</span>);  <span class="comment">// 四舍五入</span></span><br><span class="line">   <span class="keyword">if</span>(getwhat)  </span><br><span class="line">   		<span class="keyword">return</span> max(maxn[a][k],maxn[b-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);  </span><br><span class="line">   <span class="keyword">else</span>  </span><br><span class="line">     	<span class="keyword">return</span> min(minn[a][k],minn[b-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线段树-数组可变"><a href="#线段树-数组可变" class="headerlink" title="线段树 (数组可变)"></a>线段树 (数组可变)</h3><p><strong>线段树（区间维护）</strong></p>
<p>Query1:  range sum/min/max in  [i,j]</p>
<p>Query2: update value at index i  to val</p>
<p><a href="https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/</a></p>
<p><a href="https://leetcode.com/problems/range-sum-query-mutable/" target="_blank" rel="noopener">https://leetcode.com/problems/range-sum-query-mutable/</a></p>
<p>整个数组给定，且可在线更改，在线查询区间sum/min/max</p>
<blockquote>
<p>We have an array arr[0 . . . n-1]. We should be able to</p>
<p><strong>1</strong> Find the sum of elements from index l to r where 0 &lt;= l &lt;= r &lt;= n-1</p>
<p><strong>2</strong> Change value of a specified element of the array to a new value x. We need to do arr[i] = x where 0 &lt;= i &lt;= n-1.</p>
</blockquote>
<ul>
<li>A <strong>simple solution</strong> is to run a loop from l to r and calculate sum of elements in given range. To update a value, simply do arr[i] = x. The first operation takes O(n) time and second operation takes O(1) time.</li>
<li><strong>Another solution</strong> is to create another array and store sum from start to i at the ith index in this array. Sum of a given range can now be calculated in O(1) time, but update operation takes O(n) time now. This works well if the number of query operations are large and very few updates.</li>
<li>What if the number of query and updates are equal? <strong>Can we perform both the operations in O(log n) time once given the array?</strong> We can use a Segment Tree to do both operations in O(Logn) time.</li>
</ul>
<p><strong>Representation of Segment trees</strong> </p>
<p><strong>1.</strong> Leaf Nodes are the elements of the input array.</p>
<p> <strong>2.</strong> Each internal node represents some merging of the leaf nodes. The merging may be different for different problems. For this problem, merging is sum of leaves under a node.</p>
<p>An array representation of tree is used to represent Segment Trees. For each node at index $i$, the left child is at index $2i$, right child at $2i+1$ and the parent is at $i/2$ (下标从1开始)</p>
<blockquote>
<p>Heap : compelete binary tree</p>
<p>Segment trees: full binary tree</p>
</blockquote>
<p><strong>Construction of Segment Tree from given array</strong><br>We start with a segment arr[0 . . . n-1]. and every time we divide the current segment into two halves(if it has not yet become a segment of length 1), and then call the same procedure on both halves, and for each such segment, we store the sum in the corresponding node.<br>All levels of the constructed segment tree will be completely filled except the last level. Also, the tree will be a <a href="https://www.geeksforgeeks.org/binary-tree-set-3-types-of-binary-tree/" target="_blank" rel="noopener">Full Binary Tree</a> because we always divide segments in two halves at every level. Since the constructed tree is always a full binary tree with n leaves, there will be n-1 internal nodes. So total number of nodes will be 2*n – 1. Note that this does not include dummy nodes.</p>
<p><strong>What is total size of array representing segment tree?</strong><br>If n is a power of 2, then there are no dummy nodes. So size of segment tree is 2n-1 (n leaf nodes and n-1) internal nodes. If n is not a power of 2, then size of tree will be 2<em>x – 1 where x is smallest of 2 greater than n. For example, when n = 10, then size of array representing segment tree is 2</em>16-1 = 31.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    Node* l;</span><br><span class="line">    Node* r;</span><br><span class="line">    <span class="keyword">int</span> st,ed; <span class="comment">// 左闭 右闭</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    Node(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> st, <span class="keyword">int</span> ed) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;st = st; <span class="keyword">this</span>-&gt;ed = ed; <span class="keyword">this</span>-&gt;op = op;</span><br><span class="line">        <span class="keyword">if</span>(st == ed)&#123; <span class="comment">// 叶子节点</span></span><br><span class="line">            l = <span class="literal">NULL</span>; r = <span class="literal">NULL</span>; val = nums[st];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l = <span class="keyword">new</span> Node(nums,st,(st+ed)/<span class="number">2</span>);</span><br><span class="line">            r = <span class="keyword">new</span> Node(nums,((st+ed)/<span class="number">2</span>)+<span class="number">1</span>,ed);</span><br><span class="line">            val = l-&gt;val + r-&gt;val;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// getSum 区间查询</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(Node* now, <span class="keyword">int</span> st, <span class="keyword">int</span> ed)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (now-&gt;st &gt;=st <span class="keyword">and</span> now-&gt;ed &lt;= ed) &#123;<span class="comment">// now完全属于[l,r] 返回now.sum 否则返回左边+右边（如果存在且有交集）</span></span><br><span class="line">        <span class="keyword">return</span> now-&gt;val;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 此时now 一定有交集</span></span><br><span class="line">        <span class="keyword">if</span>(now-&gt;l != <span class="literal">NULL</span> <span class="keyword">and</span> now-&gt;l-&gt;ed &gt;= st) sum += getSum(now-&gt;l, st, ed);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;r != <span class="literal">NULL</span> <span class="keyword">and</span> now-&gt;r-&gt;st &lt;= ed) sum += getSum(now-&gt;r, st, ed);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// update 单点修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Node* now, <span class="keyword">int</span> index, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (now-&gt;st == now-&gt;ed)&#123; <span class="comment">// 叶子节点</span></span><br><span class="line">        now-&gt;val = val;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt;= now-&gt;l-&gt;ed)&#123;</span><br><span class="line">            update(now-&gt;l,index,val);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            update(now-&gt;r,index,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据左右子树重新计算now-&gt;val</span></span><br><span class="line">        now-&gt;val = now-&gt;l-&gt;val + now-&gt;r-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity:</strong><br>Time Complexity for tree construction is O(n). There are total 2n-1 nodes, and value of every node is calculated only once in tree construction.</p>
<p>Time complexity to query is O(Logn). To query a sum, <strong>we process at most four nodes at every level and number of levels is O(Logn)</strong>.</p>
<p>The time complexity of update is also O(Logn). To update a leaf value, we process one node at every level and number of levels is O(Logn).</p>
<p>升级版：</p>
<p>Query1 : range sum/min/max in [i,j]   </p>
<p>Query2: update value in [i,j) to val    ———————————— 懒标记</p>
<h1 id="在线算法-amp-离线算法"><a href="#在线算法-amp-离线算法" class="headerlink" title="在线算法 &amp; 离线算法"></a>在线算法 &amp; 离线算法</h1><p><strong>在线算法：在计算机科学中，一个在线算法是指它可以以序列化的方式一个个的处理输入，也就是说在开始时并不需要已经知道所有的输入。</strong></p>
<p><strong>离线算法：在开始时就需要知道问题的所有输入数据，而且在解决一个问题后就要立即输出结果。例如，选择排序在排序前就需要知道所有待排序元素，然而插入排序就不必了。</strong></p>
<h2 id="最近公共祖先离线算法"><a href="#最近公共祖先离线算法" class="headerlink" title="最近公共祖先离线算法"></a>最近公共祖先离线算法</h2><p><a href="https://www.cnblogs.com/JVxie/p/4854719.html" target="_blank" rel="noopener">https://www.cnblogs.com/JVxie/p/4854719.html</a></p>
<p>tarjan算法（DFS+Union Find）离线算法 O(N+Q)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Tarjan(u)<span class="comment">//marge和find为并查集合并函数和查找函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">for</span> <span class="title">each</span><span class="params">(u,v)</span>    <span class="comment">//访问所有u子节点v</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Tarjan(v);        <span class="comment">//继续往下遍历</span></span><br><span class="line">        marge(u,v);    <span class="comment">//合并v到u上</span></span><br><span class="line">        标记v被访问过;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">for</span> <span class="title">each</span><span class="params">(u,e)</span>    <span class="comment">//访问所有和u有询问关系的e</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        如果e被访问过;</span><br><span class="line">        u,e的最近公共祖先为find(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/ywcpig/article/details/52336496" target="_blank" rel="noopener">https://blog.csdn.net/ywcpig/article/details/52336496</a></p>
<p>转换为RMQ问题，用Sparse Table（简称ST）算法解决。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>建立常识性的时间概念：</p>
<p>一般笔记本电脑的CPU主频两级为GHZ，也就是说，每秒可以处理<strong>10^9次</strong>基本运算。</p>
<p>One day：24<em>3600 = 25</em>4000 = 10^5 sec</p>
<p>One century : 100<em>365 = 3</em>10^4 = 3*10^9 sec</p>
<p>三生三世：10^10 sec</p>
<p>Debug 的时候如果代码跑的慢具体定位到某一部分，并确定该部分有没有更好的时间复杂度的算法。如果是因为整体数据量大，如机器学习中的问题，则可切分小数据集测试代码的正确性。 </p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>二维vector: </p>
<p>Vector 中主要维持两个变量： 数组地址  数组长度  （数组存储在连续空间）</p>
<p>二维vector中维持的数组中存储的为一维vector实例  （二维vector的内容存储并不连续）</p>
<p>vector   rbegin   rend      reverse</p>
<h1 id="Tutorials"><a href="#Tutorials" class="headerlink" title="Tutorials"></a>Tutorials</h1><p><a href="https://www.topcoder.com/community/competitive-programming/tutorials/" target="_blank" rel="noopener">https://www.topcoder.com/community/competitive-programming/tutorials/</a></p>
<p><a href="https://yangshun.github.io/tech-interview-handbook/" target="_blank" rel="noopener">https://yangshun.github.io/tech-interview-handbook/</a></p>
<p><a href="https://www.acwing.com/" target="_blank" rel="noopener">https://www.acwing.com/</a></p>
<p><a href="https://oi-wiki.org/ds/" target="_blank" rel="noopener">https://oi-wiki.org/ds/</a></p>
<p><a href="http://courses.csail.mit.edu/iap/interview/index.php" target="_blank" rel="noopener">http://courses.csail.mit.edu/iap/interview/index.php</a></p>
<p><a href="https://www.geeksforgeeks.org/" target="_blank" rel="noopener">https://www.geeksforgeeks.org</a></p>
<p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/recitation-notes/" target="_blank" rel="noopener">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/recitation-notes/</a></p>
<p><a href="https://www.nowcoder.com/study/vod/1041" target="_blank" rel="noopener">https://www.nowcoder.com/study/vod/1041</a></p>
<p><a href="https://techdevguide.withgoogle.com/" target="_blank" rel="noopener">https://techdevguide.withgoogle.com/</a></p>
<h2 id="算法Youtube-channel"><a href="#算法Youtube-channel" class="headerlink" title="算法Youtube channel"></a>算法Youtube channel</h2><p>Back To Back SWE <a href="https://www.youtube.com/channel/UCmJz2DV1a3yfgrR7GqRtUUA" target="_blank" rel="noopener">https://www.youtube.com/channel/UCmJz2DV1a3yfgrR7GqRtUUA</a></p>
<p>HackerRank <a href="https://www.youtube.com/channel/UCOf7UPMHBjAavgD0Qw5q5ww" target="_blank" rel="noopener">https://www.youtube.com/channel/UCOf7UPMHBjAavgD0Qw5q5ww</a></p>
<p>花花酱 <a href="https://space.bilibili.com/9880352/" target="_blank" rel="noopener">https://space.bilibili.com/9880352/</a></p>
<p>CS Dojo <a href="https://www.youtube.com/channel/UCxX9wt5FWQUAAz4UrysqK9A" target="_blank" rel="noopener">https://www.youtube.com/channel/UCxX9wt5FWQUAAz4UrysqK9A</a></p>
<p>Tuschar Roy <a href="https://www.youtube.com/user/tusharroy2525" target="_blank" rel="noopener">https://www.youtube.com/user/tusharroy2525</a></p>
<p>GeeksForGeeks <a href="https://www.youtube.com/channel/UC0RhatS1pyxInC00YKjjBqQ" target="_blank" rel="noopener">https://www.youtube.com/channel/UC0RhatS1pyxInC00YKjjBqQ</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/12/c++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lizzy llq">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Forward">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/12/c++/" itemprop="url">C++ learning</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-12T15:58:30+08:00">
                2019-11-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h2 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h2><p>计算机系统：硬件，软件，<strong>指令系统</strong>(硬件与软件的界面，<strong>硬件能识别的二进制指令集合</strong>)</p>
<p>硬件：输入设备/输出设备/外存储器     内存储器   cpu</p>
<p>软件： 应用软件  系统软件(操作系统) 中间件(提供系统软件和应用软件之间链接的软件)</p>
<p><strong>软件 = 程序 + 文档</strong></p>
<h2 id="计算机语言"><a href="#计算机语言" class="headerlink" title="计算机语言"></a>计算机语言</h2><p>计算机语言：程序员与计算机沟通的语言，描述解决问题的方法和相关数据</p>
<p>​                       机器语言(二进制代码)  汇编语言(助记符，抽象层次并没有提高)  高级语言(类似英语单词，语句)</p>
<p>程序设计方法：面向过程  面向对象  泛型</p>
<p>面向对象：对象  类（抽象）  封装(安全易用)  消息通信  继承  多态(同样的消息作用在不同对象有可能引起不同的行为)</p>
<p>c++程序的开发过程：算法设计 源程序编辑  编译 连接  测试 调试  执行</p>
<p>源程序   =翻译》 目标程序(二进制的机器语言程序)  =连接(eg 连接程序库)》 可执行程序</p>
<p>翻译程序：汇编程序(翻译汇编语言)   编译程序  解释程序(边翻译边执行)   </p>
<p>c++(编译)    java(半编译半解释, java虚拟机)   Python(解释)</p>
<h2 id="信息在计算机中的表示与存储"><a href="#信息在计算机中的表示与存储" class="headerlink" title="信息在计算机中的表示与存储"></a>信息在计算机中的表示与存储</h2><p>计算： 算数运算  逻辑运算</p>
<p>计算机内部的信息： 控制信息  数据信息(数值信息：整数  实数，非数值信息：字符数据 逻辑数据)</p>
<p>信息的存储单位： 位bit  字节 Byte  (1KB=1024B  1MB=1024KB  1GB=1024MB)</p>
<p>进制 : 十进制  八进制  十六进制 </p>
<p>负数(补码)：零的表示为1       符号位可作为数值参与运算</p>
<p><strong>一个数减去一个数和加上它的补数效果一样</strong></p>
<p>！！数据有表示范围，只能保证在范围内的运算正确</p>
<p>小数：定点方式(特别大的数和特别小的数没法表示)  浮点方式($N=M*2^E$)</p>
<p>字符数据： 编码  ASCII(7位二进制数，最多可表示$2^7$个字符)</p>
<h1 id="数据和基本运算"><a href="#数据和基本运算" class="headerlink" title="数据和基本运算"></a>数据和基本运算</h1><p>c++字符集：大小写英文字母  数字字符  特殊字符</p>
<p>词法记号：关键字(预定义单词) 标志符(程序员声明的单词) 文字(直接使用符号表示的数据) 分隔符 运算符 空白符</p>
<p>标志符命名规则：以大小写字母或下划线开始，由大小写字母或下划线或数字构成，对大小写敏感，不能是关键字或操作符</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>计算机的最基本功能：数据处理</p>
<p>数据：变量  常量</p>
<p>常量：在程序运行过程中其值始终不可改变的值，直接使用文字表示的值为常量/ 符号常量</p>
<p>整数常量：十进制(若干0~9的数字，但不可以0开头)    八进制(前缀为0)   十六进制(前缀为0x)</p>
<p>​                    默认为int    后缀U或u: unsigned   L或l: long    LL或ll: long long </p>
<p>​                    负数 前面加-</p>
<p>浮点数常量：默认为double   后缀F或f为float</p>
<p>​                      一般形式 12.5  -12.5         </p>
<p>​                       指数形式  0.345E+2   -34.4E-3   整数部分和小数部分可以省略其一</p>
<p>字符常量：单引号括起来的字符       有些字符无法在屏幕显示，用转义字符表示</p>
<p>字符串常量：双引号括起来的字符</p>
<p>符号常量：const 数据类型说明符 常量名 = 常量值 或  数据类型说明符  const  常量名 = 常量值</p>
<p>​                  符号常量在定义时一定要进行初始化，在程序中间不能修改值</p>
<p>为了存储数据，需要预先为这些数据分配内存空间变量的定义就是在给变量命名的时候分配内存空间</p>
<p>整数类型：short         int(默认signed)/ unsigned int           long          long long</p>
<p>实数类型:  float     double     long double </p>
<p>​                    (浮点数不是一个准确的值，要比较两个浮点数是否相等，应看两数之差是否足够小)</p>
<p>字符类型:  char(单引号 容纳单个字符的编码，实质上存储的也为整数：字符的ascii码)</p>
<p>字符串类型：有字符串常量(双引号)，基本类型中没有字符串变量</p>
<p>​                      用字符数组(末尾添加’\0’作为结束标记)  或 STL中的string类 存储</p>
<p>布尔类型: true  false</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>基本算数运算符：+ - * /(若整数相除，结果取整)     %(取余，操作数为整数)</p>
<p>​                               优先级：先乘除，后加减，同级从左至右</p>
<p>​                                自增++   自减—</p>
<p>赋值运算符： =   (赋值表达式的值为赋值运算符左边对象被赋值后的值，类型为赋值运算符左边对象的类型)</p>
<p>复合赋值运算符(10种)： +=    -=   *=   /=    %=    &lt;&lt;=    &gt;&gt;=    &amp;=  ^=  |=</p>
<p>逗号运算符：表达式1,表达式2     (先求解表达式1，后求解表达式2， 最终结果为表达式2的值)</p>
<p>关系运算符：&lt;  &lt;= &gt; &gt;=  (优先级高)           ==  !=  (优先级低)       结果为bool类型</p>
<p>逻辑运算符： (优先级从高到低)    !     &amp;&amp;   ||    结果为bool类型       短路特性</p>
<p>条件运算符：表达式1  ?  表达式2: 表达式3     (表达式1必须为bool类型)</p>
<p>sizeof运算符:   sizeof(类型名)      sizeof(表达式)    返回</p>
<p>位运算符:  ~   &amp;     |    ^（与0异或保持原值，与1异或取反）</p>
<p>移位运算符：&lt;&lt; (低位补0，高位舍弃)    &gt;&gt; 低位舍弃，高位：无符号数补0，有符号数补符号位</p>
<p>​                      &lt;\<1 相当于乘2(若符号位变化，说明在*2的含义下该运算溢出)>&gt; 1相当于除2</1></p>
<p>运算优先级</p>
<p>类型转换：一些二元运算符(算数运算符, 关系运算符, 逻辑运算符,位运算符,  赋值运算符)要求两个操作数类型一     致，若不一致，会隐含的转换；   显示转换：类型转换操作符&lt;类型说明符&gt;(表达式)      static_cast</p>
<h2 id="输入-输出"><a href="#输入-输出" class="headerlink" title="输入/输出"></a>输入/输出</h2><p>cin 预定义的标准输入流对象       &gt;&gt; 预定义的提取运算符</p>
<p>cout 预定义的标准输出流对象     &lt;&lt; 预定义的插入运算符</p>
<p>操纵符：dec   hex   oct     ws提取空白符    endl    ends插入空字符     setsprecision(int)设置浮点数的小数位数      </p>
<p>​                setw(int)设置域宽</p>
<h2 id="选择结构-循环结构"><a href="#选择结构-循环结构" class="headerlink" title="选择结构/循环结构"></a>选择结构/循环结构</h2><p>if                          else if                    else</p>
<p>swith  case   default   break</p>
<p>for(; ;)       for(声明:表达式)范围for循环，用于遍历容器          while           do while</p>
<p>break   continue</p>
<h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>typedef 已有类型名   别名</p>
<p>枚举类型    enum   数据合法性检验   ： enum 枚举类型名  {枚举常量}</p>
<p>enum Weekday {SUN, MON, TUE, WED, THU, FRI, SAT}    默认值0 1 2 3 4 5 6</p>
<p>auto 编译器根据初始值自动推断变量的类型</p>
<p>decltype  定义一个变量与某一表达式的类型相同，但并不用该表达式初始化变量 eg: decltype(i)  j = 2</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数： 程序的功能模块</p>
<h2 id="函数定义-函数调用"><a href="#函数定义-函数调用" class="headerlink" title="函数定义  函数调用"></a>函数定义  函数调用</h2><p>函数定义   形参(不分配空间，形实结合才分配空间)</p>
<p>若函数定义不在当前文件或在当前函数之后，函数调用之前需要函数原型声明</p>
<p>嵌套调用     用栈保存当前现场和返回地址 </p>
<p>递归(函数直接或间接调用自身)   递归深入  递归终止条件</p>
<p>随机函数  int rand(void) 所需头文件<cstdlib>  求出并返回一个伪随机数</cstdlib></p>
<p>随机数种子   void srand(unsigned int seed)       所需头文件&lt;cstdlib  为rand()产生一序列伪随机数设置起始点</p>
<h2 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h2><p>值传递：  单向传递</p>
<p>指针传递  </p>
<p>引用传递：双向传递  （传递的数据安全性：不希望双向传递时，常引用）</p>
<p><strong>引用</strong>是标志符的别名，定义一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象 ，并且不可以再指向别的对象，引用可以作为形参，形实结合时，对形参进行初始化，不分配内存</p>
<p>含有可变参数的函数：</p>
<ul>
<li>若所有实参的类型相同：传递一个名为initializer_list的标准库类型，头文件<initializer_list></initializer_list></li>
<li>若不同：编写可变参数的模板  </li>
</ul>
<p>带<strong>默认参数</strong>的函数值</p>
<ul>
<li>可预先设置默认的参数值，有默认参数的形参必须在参数列表的最右边，调用时形实结合的次序为从左到右</li>
<li>如果一个函数有原型声明，且原型声明在定义之前，则默认参数值在函数声明中给出</li>
<li>如果只有函数的定义，或函数定义在前，则默认参数值可以在函数定义给出</li>
</ul>
<p><strong>函数重载</strong></p>
<ul>
<li>c++允许功能相近的函数在相同的作用域内以相同函数名声明，从而形成重载：形参类型不同，形参个数不同</li>
</ul>
<h2 id="内联函数-constexpr函数"><a href="#内联函数-constexpr函数" class="headerlink" title="内联函数  constexpr函数"></a>内联函数  constexpr函数</h2><p>内联函数：逻辑上是一个函数，实际运行不是    inline    在编译时在调用处用函数体进行替换，节省了参数传递、控制转移等开销</p>
<p>内联函数体不能有循环语句和swith语句，内联函数的定义必须在内联函数第一次调用前，对内联函数不能进行异常接口声明     （inline是对编译器的一个建议）</p>
<p>constexpr函数：常量表达式函数，可以用来初始化常量</p>
<p>contexpr修饰的函数，在其所有参数都是contexpr时，一定返回constexpr</p>
<p>常数初始化   编译时能确定</p>
<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><p>面向对象的基本特点：抽象  封装  继承 多态</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>设计类就是设计类型：</p>
<ul>
<li>此类型的”合法值“是什么</li>
<li>此类型该有什么样的函数和操作符</li>
<li>新类型的对象如何创建和销毁</li>
<li>如何进行对象的初始化和赋值</li>
<li>对象作为函数的参数如何以值传递</li>
<li>谁将使用此类型的对象成员</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	公有成员，外部接口</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	私有成员</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        保护型成员</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以为数据成员设置类内初始值，用于初始化数据成员</p>
<p><strong>类成员的访问控制</strong></p>
<ul>
<li>public: 任何外部函数都可以访问public的数据和函数</li>
<li>private: 只允许本类中的函数访问，如果紧跟在类名称的后面声明私有成员，则关键字private可省略</li>
<li>protected：与private类似，其差别体现在继承与派生时对派生类的影响不同</li>
</ul>
<p>类的成员函数</p>
<ul>
<li>在类中声明函数原型</li>
<li>可以在类外给出函数体实现，并在函数名前使用类名加以限定</li>
<li>也可以直接在类中给出函数体，形成内联函数成员</li>
<li>允许声明重载函数和带默认参数值的函数</li>
</ul>
<p>内联成员函数</p>
<ul>
<li>未来提高运行时的效率，对于较简单的函数可以声明为内联形式</li>
<li>内联函数体不要有复杂结构(如循环语句和switch语句)</li>
<li>在类中声明内联成员函数的方式：将函数体放在类的声明中    或   使用inline关键字</li>
</ul>
<h2 id="构造函数-析构函数"><a href="#构造函数-析构函数" class="headerlink" title="构造函数 析构函数"></a>构造函数 析构函数</h2><p>构造函数：在对象被创建时使用特定的值构造对象，将对象初始化为一个特定的初始状态</p>
<p>构造函数的形式</p>
<ul>
<li>函数名与类名相同</li>
<li>不能定义返回值类型，也不能有return语句</li>
<li>可以有形式参数，也可以没有</li>
<li>可以是内联函数</li>
<li>可以重载</li>
<li>可以带默认参数值</li>
</ul>
<p>构造函数在对象创建时自动调用</p>
<p>默认构造函数：调用时不需要实参的构造函数</p>
<ul>
<li>参数表为空的构造函数</li>
<li>全部参数都有默认值的构造函数</li>
</ul>
<p>！！！参数表为空的构造函数 和 全部参数都有默认值的构造函数 如在类中同时出现  会产生<strong>编译错误</strong>，不是合法的参数重载形式</p>
<p><strong>隐含的默认构造函数</strong></p>
<p>如果程序中未定义构造函数，编译器将自动生成一个默认构造函数</p>
<ul>
<li>参数列表为空，不为数据成员设置初始值</li>
<li>如果类内定义了成员的初始值，则使用类内定义的初始值</li>
<li>如果没有定义类内的初始值，则以默认的方式初始化</li>
<li>基本类型的数据默认初始化的值是不确定的</li>
</ul>
<p>如果程序中已定义构造函数，默认情况下编译器不再自动生成一个默认构造函数，<strong>如果此时依然希望编译器隐含生成默认构造函数，可以使用      类名()=default    声明</strong></p>
<p><strong>初始化列表</strong>：对类的数据成员初始化，首选用初始化列表，比在函数体中用赋值表达式效率要高一些</p>
<p>委托构造函数  c++11</p>
<p>委托构造函数使用类的其他构造函数执行初始化过程    有助于保持代码的一致性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS): </span><br><span class="line">hour(newH), minute(newM), second(newS)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Clock(): Clock(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>复制构造函数</strong>：由一个已经存在的对象初始化一个新对象</p>
<p>复制构造函数是一种特殊的构造函数，形参为本类对象的常引用</p>
<p>调用复制构造函数的三种情况：</p>
<ul>
<li>定义一个对象时，以本类的另一个对象作为初始值</li>
<li>如果函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象</li>
<li>如果函数的返回值是类的对象，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数</li>
</ul>
<p>如果在程序中没有定义复制构造函数，编译器会自动产生一个默认的复制构造函数：实现两个对象数据成员之间的一一对应复制 ，但 eg:当类中的数据成员包含指针时，默认的复制构造函数（浅层复制）不够用</p>
<p>如果不希望对象被复制构造</p>
<ul>
<li><p>c++98做法：将复制构造函数声明为private,并且不提供函数的实现</p>
</li>
<li><p>c++11做法：用  =delete 指示编译器不生成默认的复制构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	类名(<span class="keyword">const</span> 类名&amp; p) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p><strong>析构函数</strong>:完成对象被删除前的一些清理工作，当对象的生存期结束的时候，系统自动调用析构函数</p>
<p>如果在程序中没有定义析构函数，编译器会自动产生一个默认的析构函数，其函数体为空</p>
<p>析构函数的原型：~类名()      析构函数没有参数，没有返回类型</p>
<h2 id="类的组合-UML"><a href="#类的组合-UML" class="headerlink" title="类的组合  UML"></a>类的组合  UML</h2><p>组合的概念：</p>
<ul>
<li>类中的成员是另一个类的对象</li>
<li>可以在已有抽象的基础上实现更复杂的抽象</li>
</ul>
<p>组合类的构造函数：不仅要对本类中的基本类型成员数据初始化，也要对对象成员初始化</p>
<p>定义形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类名::类名(对象成员需要的形参,本类成员形参):</span><br><span class="line">     对象<span class="number">1</span>(参数),对象<span class="number">2</span>(参数),...  <span class="comment">// 初始化次序按成员在类体中声明的次序，未在初始化列表中出现的对象成员，用对应类的默认构造函数初始化</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 函数体其他语句      </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前向引用声明</p>
<ul>
<li>类应该先声明后使用</li>
<li>如果需要在某一个类的声明之前，引用该类，则应进行前向引用声明  (两个类互相引用的情况)</li>
<li>前向引用声明只为程序引入一个标志符，但具体声明在其他地方</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span> <span class="comment">//前向引用声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">         <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(B b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(A a)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>在提供一个完整的类声明之前，不能声明该类的对象，也不能在内联函数成员中使用该类的对象</li>
<li>当使用前向引用声明时，只能使用被声明的符号，而不能涉及类的任何细节</li>
</ul>
<p>UML语言</p>
<p>事物  关系  图</p>
<p>依赖  关联  聚合  继承</p>
<h2 id="结构体-联合体"><a href="#结构体-联合体" class="headerlink" title="结构体 联合体"></a>结构体 联合体</h2><p>结构体是一种特殊的类，与类唯一的区别：</p>
<ul>
<li>类的缺省访问权限：private</li>
<li>结构体的缺省访问权限: public</li>
</ul>
<p>什么时候用结构体而不用类</p>
<ul>
<li>定义主要用来保存数据，而没有什么操作的类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名称&#123;</span></span><br><span class="line">       公有成员</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">       保护型成员</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       私有成员</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果一个结构体的全部数据成员都是公共成员，没有用户定义的构造函数，没有基类和虚函数：这个结构体的变量可用下面的语法形式初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名 变量名 = &#123;成员数据<span class="number">1</span>初值, 成员数据<span class="number">1</span>初值,...&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>联合体</p>
<ul>
<li>成员共用同一组内存单元// 按最多字节数的数据分配空间</li>
<li>任何两个成员不会同时有效</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> 结构体名称&#123;</span><br><span class="line">       公有成员</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">       保护型成员</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       私有成员</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>枚举类：强类型的枚举   c++11</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> 枚举类型名:</span>底层类型&#123;枚举值列表&#125;; <span class="comment">//默认底层类型为int</span></span><br></pre></td></tr></table></figure>
<p>优势：</p>
<ul>
<li><p>强作用域</p>
<p>使用Type的枚举值General    Type::General</p>
</li>
<li><p>转换限制</p>
<p>枚举类对象不可以和整形隐式的互换</p>
</li>
<li><p>可以指定底层类型</p>
</li>
</ul>
<h1 id="数据的共享与保护"><a href="#数据的共享与保护" class="headerlink" title="数据的共享与保护"></a>数据的共享与保护</h1><p>变量和对象定义在不同的位置（函数体内，类体内，函数原型参数表内，所有函数和类之外），其作用域，可见性，生存期都不同</p>
<h2 id="标志符作用域和可见性"><a href="#标志符作用域和可见性" class="headerlink" title="标志符作用域和可见性"></a>标志符作用域和可见性</h2><p>作用域分类： 由小到大</p>
<ul>
<li>函数原型作用域</li>
</ul>
<p>​       函数原型中的参数；其作用域始于”(“,结束于”)”</p>
<ul>
<li><p>局部作用域（块作用域）</p>
<p>函数定义中的形参，在块中声明的标志符；其作用域自声明处起，限于块中</p>
</li>
<li><p>类作用域</p>
<p>类的成员具有类作用域，其范围包括类体和成员函数体，在类作用域以外访问类的成员：</p>
<ul>
<li>静态成员：通过类名或者该类的对象名，对象引用访问</li>
<li>非静态成员：通过该类的对象名，对象引用，对象指针访问</li>
</ul>
</li>
<li><p>文件作用域</p>
<p>不在前述各个作用域出现的声明具有文件作用域；其作用域始于声明点，结束于文件尾</p>
</li>
<li><p>命名空间作用域</p>
</li>
</ul>
<hr>
<p>可见性：表示从内层作用域向外层作用域看能看见什么，如果标志符在某处可见，就可以在该处引用此标志符</p>
<ul>
<li>如果某个标志符在外层中声明且在内层中没有统一标志符的声明，则该标志符在内层可见</li>
<li>对于两个嵌套的作用域，如果在内层作用域声明了和外层作用域同名的标志符，则外层作用域的标志符在内层不可见</li>
</ul>
<h2 id="对象的生存期"><a href="#对象的生存期" class="headerlink" title="对象的生存期"></a>对象的生存期</h2><p>静态生存期：与程序的运行期相同；在文件作用域声明的对象具有这种生存期，在函数内部声明静态生存期对象要用关键字static</p>
<p>动态生存期：开始于程序执行到声明点时，结束语命名该标志符的作用域结束处；块作用域中生命的，没有用static修饰的对象是动态生存期的对象（局部生存期对象）</p>
<h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><p>静态数据成员</p>
<ul>
<li>用static声明，为该类的所有对象共享，具有静态生存期</li>
<li>声明在类体内，但必须在类外定义和初始化，用::来指明所属的类</li>
</ul>
<p>静态函数成员:主要用于处理该类的静态数据，不能用来直接访问非静态数据，只能通过对象来访问非静态数据</p>
<h2 id="类的友元"><a href="#类的友元" class="headerlink" title="类的友元"></a>类的友元</h2><p>friend</p>
<ul>
<li>友元是c++提供的一种破坏数据封装和数据隐藏的机制（隐藏和效率的平衡）</li>
<li>通过将一个模块声明为另一个模块的友元，一个模块能引用另一个模块中被隐藏的信息</li>
<li>可以声明友元函数或友元类</li>
<li>为了确保数据的完整性，以及数据封装和隐藏的原则，慎用</li>
</ul>
<p>友元函数：</p>
<ul>
<li>在类中声明由关键字friend修饰的非成员函数，在其函数体中通过传递的对象参数访问private和protected成员</li>
<li>访问对象中的成员必须通过对象名</li>
</ul>
<p>友元类</p>
<ul>
<li><p>将友元类名在另一个类中用friend修饰声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> 类名;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>若一个类是另一个类的友元，则此类的所有成员都能访问对方类的私有成员</p>
</li>
<li>类的友元关系是单向的</li>
</ul>
<h2 id="共享数据的保护"><a href="#共享数据的保护" class="headerlink" title="共享数据的保护"></a>共享数据的保护</h2><p>const  常类型</p>
<ul>
<li><p>常对象：必须进行初始化，不能被更新    const 类名 对象名;</p>
</li>
<li><p>常成员：用const修饰的类成员，常数据成员，常函数成员</p>
<ul>
<li><p>常数据成员：不能被修改，同时它只能在构造函数的初始化列表中赋值，不能在函数体中初始化，不能被非常成员函数访问</p>
</li>
<li><p>常成员函数不更新对象的数据成员，常对象只能调用其常成员函数，常成员函数不能调用非常成员函数，可以访问常数据成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类型说明符 函数名(参数表) <span class="keyword">const</span>; <span class="comment">// const是函数类型的一个组成部分；声明，实现部分都要带const</span></span><br><span class="line"><span class="comment">// const 可用于参与对重载函数的区分</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>常引用：被引用的对象不能被更新    construction 类型说明符 &amp; 引用名</p>
<p>既可以提高参数传递的效率，同时保证实参的安全性</p>
</li>
<li><p>常数组：数组元素不能被更新  const 数组名[大小]</p>
</li>
<li><p>常指针：指向常量的指针</p>
</li>
</ul>
<h2 id="多文件结构和预编译命令"><a href="#多文件结构和预编译命令" class="headerlink" title="多文件结构和预编译命令"></a>多文件结构和预编译命令</h2><p>编译预处理</p>
<p>c++程序的一版组织结构：</p>
<ul>
<li>一个工程一般可以划分为多个源文件，如<ul>
<li>类声明文件(.h文件)</li>
<li>类实现文件(.cpp文件)</li>
<li>类的使用文件(main()所在的.cpp文件)</li>
</ul>
</li>
<li>利用工程来组合各个文件</li>
</ul>
<hr>
<p>外部变量</p>
<ul>
<li>除了在定义它的源文件中可以使用外，还能被其他文件使用</li>
<li>文件作用域中定义的变量默认情况下是外部变量</li>
<li>在其他文件中如果需要使用，需要用extern关键字声明</li>
</ul>
<p>外部函数</p>
<ul>
<li>在所有类之外声明的函数(非成员函数)，都是具有文件作用域的</li>
<li>这样的函数都快可以在不同的编译单元中被调用</li>
<li>只要在调用之前使用引用性声明（声明函数原型）即可</li>
</ul>
<p>将变量和函数限制在编译单元内：在匿名命名空间中定义的变量和函数，都不会暴露给其他的编译单元</p>
<hr>
<p><strong>标准c++库</strong>是一个极为灵活并可扩展的可重用的软件模块的集合，在逻辑上分为6种类型：</p>
<ul>
<li>输入/输出类</li>
<li>容器类和抽象数据类型</li>
<li>存储管理类</li>
<li>算法</li>
<li>错误处理</li>
<li>运行环境支持</li>
</ul>
<hr>
<p>编译预处理</p>
<p>#include 包含指令 : 将一个源文件嵌入到当前源文件中该点处</p>
<ul>
<li>#include &lt;文件名&gt;  按标准方式搜索，文件位于c++系统目录的include子目录下</li>
<li>#include “文件名”  首先在当前目录中搜索，若没有则再按标准方式搜索</li>
</ul>
<p>#define 宏定义指令</p>
<ul>
<li>定义符号常量，很多情况被const取代</li>
<li>定义带参数宏，被内联函数取代</li>
</ul>
<p>#undef 删除由#define定义的宏，使之不再起作用</p>
<p>条件编译指令  #if    (#elif)    (#else)   #endif</p>
<p>#ifdef 标志符  （如果标志符经#define定义过，且未经#undef删除，防止重复定义）</p>
<p>#ifndef 标志符 </p>
<h1 id="数组-指针-字符串"><a href="#数组-指针-字符串" class="headerlink" title="数组 指针 字符串"></a>数组 指针 字符串</h1><h2 id="数组的定义与初始化"><a href="#数组的定义与初始化" class="headerlink" title="数组的定义与初始化"></a>数组的定义与初始化</h2><p>数组是具有一定顺序关系的若干相同类型变量的集合体，组成数组的变量称为该数组的元素</p>
<p>数组的定义：类型说明符 数组名[常量表达式][常量表达式]…;</p>
<p>数组名的构成方法和一般变量名相同</p>
<p>数组元素在内存中顺次存放，他们的地址是连续的，元素间物理位置的相邻，对应着逻辑次序的相邻</p>
<ul>
<li>数组名是数组首元素的内存地址</li>
<li>数组名是一个常量，不能被赋值</li>
</ul>
<hr>
<p>一维数组的初始化</p>
<ul>
<li><p>列出全部元素的初始值   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出部分元素的初始值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>二维数组的初始化</p>
<ul>
<li><p>列出全部元素的初始值  【列出全部元素的初始值时，第一维下标可省略】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> a[][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出部分元素的初始值 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果不做任何初始化，局部作用域的非静态数组中会存在垃圾数据，static数组中的数据默认初始化为0</p>
<p>如果只对部分元素初始化，剩下的未显示初始化的元素会自动被初始化为0</p>
<h2 id="数组作为函数的参数"><a href="#数组作为函数的参数" class="headerlink" title="数组作为函数的参数"></a>数组作为函数的参数</h2><ul>
<li>数组元素作为实参，与单个变量一样</li>
<li>数组名作为参数，形参实参都应是数组名，类型要一样，传送的是数组首地址，对形参数组的改变会直接影响到实参数组</li>
</ul>
<h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><p>定义对象数组： 类名 数组名[元素个数];</p>
<p>访问对象数组： 数组名[下标].成员名</p>
<p>对象数组的初始化： Point a[2] = {Point(1,2), Point(3,4)};</p>
<p>如果没有为数组元素指定显示初始值，数组元素便使用默认值初始化（调用默认构造函数） Point a[2];</p>
<p><strong>数组元素的构造与析构</strong></p>
<ul>
<li>构造数组时，元素所属的类为声明构造函数，则采用默认构造函数</li>
<li>各元素对象的初值要求为相同的值时，可以声明具有默认形参值的构造函数</li>
<li>各元素对象的初值要求为不同的值时，需要声明带形参的构造函数</li>
<li>当数组中的每一个对象被删除时，系统都要调用一次析构函数</li>
</ul>
<p>基于范围的for循环   c++11</p>
<p>自动遍历整个容器</p>
<h2 id="指针的定义与运算"><a href="#指针的定义与运算" class="headerlink" title="指针的定义与运算"></a>指针的定义与运算</h2><p>内存空间的访问方式</p>
<ul>
<li>通过变量名访问</li>
<li>通过地址访问</li>
</ul>
<p>指针：内存地址，用于间接访问内存单元（必须是程序运行期间合法获得的）</p>
<p>指针变量：用于存放地址的变量 </p>
<p>指针变量初始化:   数据类型* 指针名 = 初始地址;</p>
<ul>
<li>用变量地址作为初值时，该变量必须在指针初始化之前已经声明过，且变量类型应和指针类型一致</li>
<li>可以用一个已有的合法的指针去初始化另一个指针变量</li>
<li>不要用内部非静态变量的地址去初始化static指针</li>
</ul>
<p>指针变量的赋值： 指针名 = 地址;</p>
<ul>
<li><p>地址中存放的数据类型与指针类型必须相符，向指针变量赋值的必须是指针常量或变量，不能是普通整数</p>
<p>如：通过地址运算符&amp;求得已定义的变量和对象的起始地址，动态内存分配成功时返回的地址</p>
</li>
<li><p>但整数0可以赋给指针，表示空指针  | c++11中使用nullptr表达更准确，类型安全的空指针</p>
</li>
<li><p>允许定义或声明指向void类型的指针，该指针可以被赋予任何类型对象的地址   void* general; </p>
<p>void指针可以容纳地址，但不能去访问地址，必须转化为具体类型的指针才能访问地址</p>
</li>
</ul>
<p>指向常量的指针： const 数据类型* 指针名</p>
<ul>
<li>不能通过指向常量的指针改变所指对象的值，但指针本身可以改变，可以指向另外的对象</li>
</ul>
<p>指针常量： 数据类型*  const 指针名</p>
<ul>
<li>指针本身的值不能被改变</li>
</ul>
<p>指针的运算</p>
<ul>
<li>算数运算：与整数的加减运算，++,  —<ul>
<li>指针p加上n或减去n:指针当前指向位置的前方或后方第n个数据(取决于指针指向的数据类型)的起始位置</li>
<li>只有当指针指向连续存储的同类型数据时，指针与整数的加减运算和自增减运算才有意义</li>
</ul>
</li>
<li>关系运算<ul>
<li>指向相同类型数据的指针之间可以进行各种关系运算</li>
<li>指向不同类型数据的指针之间以及指针与一般整数变量之间的关系运算是无意义的</li>
<li>指针可以和0之间进行等于或不等于的关系运算</li>
</ul>
</li>
</ul>
<p>floor()  向下取整</p>
<p>floor(x+0.5)  四舍五入</p>
<p>floor(x*100+0.5)/100  保留小数点后两位数</p>
<h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], *pa;</span><br><span class="line">pa = &amp;a[<span class="number">0</span>];<span class="comment">// 或 pa=a;</span></span><br><span class="line"><span class="comment">// a[i], *(pa+i), *(a+i), pa[i]都是等效的</span></span><br></pre></td></tr></table></figure>
<p>指针数组：数组的元素是指针类型</p>
<p>二维数组 等价于  一维指针数组  （实际存储有差别）</p>
<h2 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h2><p>以指针作为函数参数</p>
<ul>
<li>需要数据双向传递时（引用也可达到此效果）    (入口参数，出口参数)</li>
<li>需要传递一组数据，只传首地址效率高 （vector的引用）     指向常量的指针</li>
</ul>
<p>最小授权原则</p>
<p>指针类型的函数：函数的返回类型是指针类型</p>
<ul>
<li>不要将非静态的局部地址作为函数的返回值   （非法地址）</li>
<li>在子函数中通过动态内存分配取得的内存地址返回给主函数是合法有效的，但是内存分配和释放不在同一级别，要注意不能忘记释放，避免内存泄漏</li>
</ul>
<p><strong>指向函数的指针</strong>  (函数名其实就是函数的地址)</p>
<p>函数指针指向的是程序代码存储区    数据类型 (*函数指针名)(参数表);</p>
<p>函数指针的典型用途：实现函数回调</p>
<ul>
<li><p>通过函数指针调用的函数</p>
<ul>
<li>例如将函数的指针作为参数传递给一个函数，使得在处理相似时间的时候可以灵活的使用不同的方法</li>
</ul>
</li>
<li><p>调用者不关心谁是被调用者</p>
<ul>
<li>需知道存在一个具有特定原型和限制条件的被调用函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>(*func)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> func(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="对象指针"><a href="#对象指针" class="headerlink" title="对象指针"></a>对象指针</h2><p>用来容纳对象地址的指针</p>
<p>通过指针访问对象成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;getx(); <span class="comment">// (*ptr).getx()</span></span><br></pre></td></tr></table></figure>
<p>this指针</p>
<ul>
<li>隐含于类的每一个非静态成员函数中</li>
<li>指出成员函数所操作的对象<ul>
<li>当通过一个对象调用成员函数时，系统现将该对象的地址赋给this指针，然后调用成员函数，成员函数对对象数据进行操作时，就隐含使用了this指针</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fred</span>;</span> <span class="comment">//前向引用声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Barney</span> &#123;</span></span><br><span class="line">    Fred * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fred</span> &#123;</span></span><br><span class="line">    Barney y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态内存分配和释放"><a href="#动态内存分配和释放" class="headerlink" title="动态内存分配和释放"></a>动态内存分配和释放</h2><p>new 类型名T (初始化参数列表)   // 调用构造函数</p>
<ul>
<li>在程序执行期间，申请用于存放T类型对象的内存空间，并依据初始值列表赋以初值</li>
<li>成功：返回T类型的指针，指向新分配的内存</li>
<li>失败：跑出异常</li>
</ul>
<p>delete 指针p</p>
<ul>
<li>释放指针p所指向的内存</li>
<li>p必须是new操作的返回值</li>
</ul>
<p>分配和释放动态数组</p>
<ul>
<li>分配 new 类型名T[数组长度]<ul>
<li>数组长度可以是任何整数类型表达式，在运行时计算</li>
</ul>
</li>
<li>释放  delete[] 数组名p<ul>
<li>释放指针p所指向的数组</li>
<li>p必须是new分配得到的数组首地址</li>
</ul>
</li>
</ul>
<p>分配和释放多维数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>(*fp)[<span class="number">3</span>];</span><br><span class="line">fp = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">// fp+1 跨越一整行</span></span><br><span class="line"><span class="keyword">delete</span>[] fp;</span><br></pre></td></tr></table></figure>
<p>智能指针 c++11</p>
<ul>
<li>unique_ptr  不允许多个指针共享资源，可以用标准库中的move函数转移指针</li>
<li>share_ptr 多个指针共享资源</li>
<li>weak_ptr 可复制shared_ptr, 但其构造或者释放对资源不产生影响</li>
</ul>
<p>将动态数组封装为一个类</p>
<p>vector</p>
<ul>
<li>封装任何类型的动态数组，自动创建和删除</li>
<li>数组下标越界检查</li>
</ul>
<h2 id="对象复制与移动"><a href="#对象复制与移动" class="headerlink" title="对象复制与移动"></a>对象复制与移动</h2><p>浅层复制 ：实现对象间数据元素的一一对应复制</p>
<p>深层复制：当被复制的对象数据成员是指针类型时，不是复制该指针成员本身，而是将指针所指对象进行复制</p>
<p>移动构造   （不需要副本）c++11</p>
<ul>
<li>将源对象的资源控制权全部交给目标对象</li>
</ul>
<p>移动构造函数</p>
<ul>
<li>当临时对象在复制后，就不再被利用了，我们完全可以把临时对象的资源直接移动，这样就避免了多余的复制操作</li>
</ul>
<p>例如当函数返回含有指针成员的对象</p>
<ul>
<li><p>A:使用深层复制构造函数</p>
<ul>
<li>返回时临时构造临时对象，动态分配将临时对象返回到主调函数，然后删除临时对象</li>
</ul>
</li>
<li><p>B:使用移动构造函数</p>
<ul>
<li><p>将要返回的局部对象转移到主调函数，省去了构造和删除临时对象的过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className(className &amp;&amp; 对象名);</span><br><span class="line"><span class="comment">// &amp;&amp;为右值引用，即将消亡的值为右值，函数返回的临时变量为右值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串常量</p>
<ul>
<li>双引号括起来，如”program”</li>
<li>各字符连续，顺序存放，每个字符占一个字节，以’\0’结尾，相当于隐含创建的字符常量数组</li>
<li>“program”出现在表达式中，表示这一char数组的首地址</li>
<li>首地址可以赋给char常量指针：const char* STRING1 = “program”;</li>
</ul>
<p>c风格字符串：用字符数组存储字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">8</span>] = &#123;<span class="string">'p'</span>,<span class="string">'r'</span>,<span class="string">'o'</span>,<span class="string">'g'</span>,<span class="string">'r'</span>,<span class="string">'a'</span>,<span class="string">'m'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="comment">// char str[8] = "program";</span></span><br><span class="line"><span class="comment">// char str[] = "program";</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行连接，拷贝，比较等操作，都需要显示调用库函数</li>
<li>当字符串长度很不确定时，需要用new动态创建字符数组，最后用delete释放</li>
<li>字符串实际长度大于为它分配的空间时，会产生数组下标越界的错误</li>
</ul>
<p>string类：封装起来的字符数组</p>
<p>输入整行字符串: getline    (#include\<string>) 从标准输入设备键盘读取一串字符串，并以指定的结束符结束</string></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getline(<span class="built_in">cin</span>,s);</span><br><span class="line">getline(<span class="built_in">cin</span>,s,<span class="string">','</span>);</span><br></pre></td></tr></table></figure>
<h1 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h1><h2 id="继承的基本概念与语法"><a href="#继承的基本概念与语法" class="headerlink" title="继承的基本概念与语法"></a>继承的基本概念与语法</h2><p>继承和派生是同一过程从不同角度看</p>
<ul>
<li>保持已有类(基类)的特性而构造新类(派生类)的过程称为继承</li>
<li>在已有类的基础上新增自己的特性而产生新类的过程称为派生</li>
<li>直接参与派生出某类的基类称为直接基类</li>
<li>基类的基类甚至更高层的基类称为简介基类</li>
</ul>
<p>继承的目的：实现设计与代码的重用</p>
<p>派生的目的：当新的问题出现，原有程序无法解决或不能完全解决时，需要对原有程序进行改造</p>
<p>单继承：派生类只从一个直接基类继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span> 继承方式 基类名&#123;</span><br><span class="line">    成员声明;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span> 继承方式<span class="number">1</span> 基类名<span class="number">1</span>, 继承方式<span class="number">2</span> 基类名<span class="number">2</span>,...&#123;</span><br><span class="line">    成员声明;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>派生类的构成：</p>
<ul>
<li>吸收基类成员<ul>
<li>默认情况下派生类包含了基类除构造和析构函数之外的所有成员</li>
<li>c++11 规定可以用using语句继承基类的构造函数</li>
</ul>
</li>
<li>改造基类成员<ul>
<li>如果派生类声明了一个和某基类成员同名的新成员，派生的新成员就隐藏或覆盖了外层同名成员</li>
</ul>
</li>
<li>添加新的成员<ul>
<li>派生类增加新成员使派生类在功能上有所发展</li>
</ul>
</li>
</ul>
<h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><p>不同继承方式的影响主要体现在</p>
<ul>
<li>派生类成员对基类成员的访问权限</li>
<li>通过派生类对象对基类成员的访问权限</li>
</ul>
<p><strong>三种继承方式</strong></p>
<ul>
<li>public 公有继承<ul>
<li>继承的访问控制<ul>
<li>基类的public和protected成员：访问属性在派生类中保持不变</li>
<li>基类的private成员：不可直接访问</li>
</ul>
</li>
<li>访问权限<ul>
<li>派生类的成员函数：可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员</li>
<li>通过派生类的对象：只能访问public成员</li>
</ul>
</li>
</ul>
</li>
<li>private 私有继承<ul>
<li>继承的访问控制<ul>
<li>基类的public和protected成员：访问属性在派生类中变为private</li>
<li>基类的private成员：不可直接访问</li>
</ul>
</li>
<li>访问权限<ul>
<li>派生类的成员函数：可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员</li>
<li>通过派生类的对象：不能直接访问从基类继承的任何成员</li>
</ul>
</li>
</ul>
</li>
<li>Protected 保护型继承<ul>
<li>继承的访问控制<ul>
<li>基类的public和protected成员：访问属性在派生类中变为protected</li>
<li>基类的private成员：不可直接访问</li>
</ul>
</li>
<li>访问权限<ul>
<li>派生类的成员函数：可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员</li>
<li>基类的private成员：不可直接访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>protected成员的特点和作用</p>
<ul>
<li>对建立其所在类对象的模块来说，它和private成员性质相同</li>
<li>对于其派生类来说，它与public成员的性质相同</li>
<li>既实现了数据隐藏，又方便继承，实现代码重用</li>
</ul>
<h2 id="基类与派生类类型转换"><a href="#基类与派生类类型转换" class="headerlink" title="基类与派生类类型转换"></a>基类与派生类类型转换</h2><p>类型转换</p>
<ul>
<li>公有派生类对象可以被当做基类的对象使用，反之则不然<ul>
<li>派生类的对象可以隐含转换为基类对象</li>
<li>派生类的指针可以因哈转换为基类的指针</li>
</ul>
</li>
<li>通过基类对象名，指针只能使用从基类继承的成员</li>
</ul>
<p><strong>不要重新定义继承而来的非虚函数</strong></p>
<h2 id="派生类的构造与析构"><a href="#派生类的构造与析构" class="headerlink" title="派生类的构造与析构"></a>派生类的构造与析构</h2><p>派生类的构造函数</p>
<p>默认情况下</p>
<ul>
<li>基类的构造函数不被继承</li>
<li>派生类需要定义自己的构造函数</li>
</ul>
<p>c++11 </p>
<ul>
<li>可以使用using语句继承基类构造函数</li>
<li>但是只能初始化从基类继承的成员  using B::B;</li>
</ul>
<p>若不继承基类的构造函数</p>
<ul>
<li>派生类新增成员：派生类定义构造函数初始化</li>
<li>继承来的成员：自动调用基类构造函数进行初始化</li>
<li>派生类的构造函数需要给基类的构造函数传递参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未在初始化列表中出现的基类，对象成员，用对应类的默认构造函数初始化</span></span><br><span class="line">派生类名::派生类名(基类需要的形参，本类成员需要的形参):基类名(参数表),本类成员初始化列表</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 其他初始化;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数的执行顺序</p>
<ul>
<li>调用基类构造函数<ul>
<li>顺序按照它们被继承时声明的顺序 从左向右 </li>
</ul>
</li>
<li>对初始化类表中的成员进行初始化<ul>
<li>顺序按照它们在类中定义的顺序</li>
<li>对象成员在初始化时自动调用其所属类的构造函数:由初始化列表提供参数</li>
</ul>
</li>
<li>执行派生类的构造函数体中的内容</li>
</ul>
<p><strong>派生类的复制构造函数</strong></p>
<p>若派生类没有声明复制构造函数</p>
<ul>
<li>编译器会在需要时生成一个隐含的复制构造函数</li>
<li>先调用基类的复制构造函数</li>
<li>再为派生类新增的成员执行复制</li>
</ul>
<p>若派生类定义复制构造函数</p>
<ul>
<li>一般都要为基类的复制构造函数传递参数</li>
<li>复制构造函数只能接受一个参数，既用来初始化派生类定义的成员，也将被传递给基类的复制构造函数</li>
<li>基类的复制构造函数形参是基类对象的引用，实参可以使派生类对象的引用</li>
</ul>
<p>派生类的析构函数</p>
<ul>
<li>析构函数不被继承，派生类如果需要，要自行声明析构函数</li>
<li>声明方法与吴继承关系时的类的析构函数相同</li>
<li>不需要显示的调用基类的析构函数，系统会自动隐式调用</li>
<li>先执行派生类析构函数的函数体，再调用基类的析构函数</li>
<li>析构的顺序和构造的顺序相反</li>
</ul>
<h2 id="派生类成员的标识与访问"><a href="#派生类成员的标识与访问" class="headerlink" title="派生类成员的标识与访问"></a>派生类成员的标识与访问</h2><p>当派生类中与基类中有相同成员时</p>
<ul>
<li>若无特别限定，则通过派生类对象使用的是派生类中的同名成员</li>
<li>如果要通过派生类对象访问基类中被隐藏的同名成员，应使用基类名和作用域操作符::来限定</li>
</ul>
<p>二义性问题</p>
<ul>
<li>如果从不同基类继承了同名成员，但在派生类中没有定义同名成员<ul>
<li>解决方法一：类名限定访问同名成员</li>
<li>解决方法二(函数成员)：在派生类中定义同名函数，函数体中根据需要调用基类中的同名成员</li>
</ul>
</li>
</ul>
<p><strong>虚基类</strong></p>
<ul>
<li>需要解决的问题：当派生类从多个基类继承，而这些基类又有共同基类，则在访问此共同基类中的成员时，将产生冗余，并有可能因冗余带来不一致性</li>
<li>虚基类声明：以virtual说明基类继承方式</li>
<li>作用：主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题，为最远的派生类提供唯一的基类成员，而不重复产生多次复制</li>
<li>注意：在第一级继承时就要将共同基类设计为虚基类</li>
</ul>
<p>虚基类及其派生类的构造函数</p>
<ul>
<li>建立对象时所指定的类称为最远派生类</li>
<li>虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的</li>
<li>在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数中的成员初始化列表中为虚基类的构造函数列出参数，如果没有列出，则表示调用该虚基类的默认构造函数</li>
<li>在建立对象时，只有最远派生类的构造函数调用虚基类的构造函数，其他类对虚基类的构造函数的调用被忽略</li>
</ul>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>操作接口具有表现不同形态的能力</p>
<p>编译时的绑定    函数重载(静态的多态，编译时绑定)</p>
<p>运行时的绑定</p>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>定义操作符函数</p>
<ul>
<li>c++几乎可以重载全部的运算符，而且只能重载c++已有的</li>
<li>不能重载的运算符    .    .*      ::      ?:</li>
<li>重载过后，运算符的优先级和结合性不变</li>
</ul>
<p>将运算符重载为类的非静态成员函数 (左操作数必须是类的对象)</p>
<ul>
<li>双目运算符 单目运算符</li>
<li>参数个数=原操作数个数-1 ，后置++,—除外(相比前置多一个int类型形参以示区分，重载)</li>
</ul>
<p>将运算符重载为非成员函数</p>
<ul>
<li>函数的形参代表依照自左至右次序排列各操作数</li>
<li>参数个数=原操作数个数 ，后置++,—除外(相比前置多一个int类型形参以示区分，重载)</li>
<li>至少应该有一个自定义类型的参数</li>
<li>如果在运算符的重载函数中需要操作某类对象的私有成员，可以将此函数声明为该类的友元</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数类型 <span class="keyword">operator</span> 运算符(形参)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重载&lt;&lt;插入运算符</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>多态行为的基础：基类声明虚函数，派生类声明一个函数覆盖该虚函数（覆盖要求：函数签名【函数名 参数列表 返回值类型 const】完全一致）</p>
<ul>
<li>同名函数前加 virtual 关键字，类体定义在外面（在里面是内联函数，对内联函数的处理是静态的）</li>
<li>运行时的动态绑定</li>
<li>虚函数必须是非静态的成员函数（属于对象，而不是整个类的）</li>
<li>构造函数不能是虚函数，析构函数可以是虚函数</li>
<li>派生类中的虚函数会隐藏基类中同名函数的所有其他重载形式，需要用类名才能调用</li>
</ul>
<p><strong>虚析构函数</strong></p>
<ul>
<li>如果你打算允许其他人通过基类指针调用对象的析构函数，就需要让基类的析构函数为虚函数，否则执行delete的结果是不确定的</li>
</ul>
<p>虚表</p>
<ul>
<li>每个多态类有一个虚表(virtual table)</li>
<li>虚表中有当前类的各个虚函数的入口地址</li>
<li>每个对象有一个指向当前类的虚表的指针 (虚指针 vptr)</li>
</ul>
<p>动态绑定的实现</p>
<ul>
<li>构造函数中为对象的虚指针赋值</li>
<li>通过多态类型的指针或引用调用成员函数时，通过虚指针找到虚表，进而找到所调用的虚函数的入口地址</li>
<li>通过该入口地址调用这个虚函数</li>
</ul>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>纯虚函数</p>
<ul>
<li>纯虚函数是一个在基类中声明的虚函数，它在基类中没有定义具体的操作内容，要求各派生类根据实际需要定义自己的版本</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 函数类型 函数名(参数表)=<span class="number">0</span>; <span class="comment">// 表示没有函数体</span></span><br></pre></td></tr></table></figure>
<p>带有纯虚函数的类称为抽象类：规范整个类家族的统一对外接口    （不能够实例化）</p>
<h2 id="override-final"><a href="#override-final" class="headerlink" title="override final"></a>override final</h2><p>c++11 override  显式地函数覆盖</p>
<p>final  不希望被继承 发展  （在类的声明和函数声明末尾加关键字 final）</p>
<h1 id="模板与群体数据"><a href="#模板与群体数据" class="headerlink" title="模板与群体数据"></a>模板与群体数据</h1><h1 id="泛型程序设计与c-标准模板库"><a href="#泛型程序设计与c-标准模板库" class="headerlink" title="泛型程序设计与c++标准模板库"></a>泛型程序设计与c++标准模板库</h1><h1 id="流类库-输入-输出"><a href="#流类库-输入-输出" class="headerlink" title="流类库  输入/输出"></a>流类库  输入/输出</h1><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/01/generative-models/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lizzy llq">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Forward">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/01/generative-models/" itemprop="url">Generative models</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-01T16:49:30+08:00">
                2019-07-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><h2 id="KL"><a href="#KL" class="headerlink" title="KL"></a>KL</h2><p>$D_{KL}(p(x)||q(x)) = \int p(x) log \frac{p(x)}{q(x)} dx = E_{x::p(x)} (log \frac{p(x)}{q(x)})$</p>
<h2 id="Jensen-不等式"><a href="#Jensen-不等式" class="headerlink" title="Jensen 不等式"></a>Jensen 不等式</h2><blockquote>
<p>设f是定义域为实数的函数，如果对于所有的实数x。如果对于所有的实数x，f(x)的二次导数大于等于0，那么f是凸函数。当<strong>x</strong>是向量时，如果其hessian矩阵H是半正定的，那么f是凸函数。如果只大于0，不等于0，那么称f是严格凸函数。</p>
</blockquote>
<p><strong>Jensen不等式</strong>：</p>
<p>如果f是凸函数，X是随机变量，那么：E[f(X)]&gt;=f(E[X])</p>
<p>特别地，如果f是严格凸函数，当且仅当X是常量时，上式取等号。</p>
<h2 id="discretized-distribution"><a href="#discretized-distribution" class="headerlink" title="discretized distribution"></a>discretized distribution</h2><ul>
<li>A <a href="https://en.wikipedia.org/wiki/Probability_distribution" target="_blank" rel="noopener">discrete probability distribution</a> is a probability distribution characterized by a  probability mass function (PMF).</li>
<li>But wait … since a discrete probability  distribution can’t be differentiated, how can we use it directly in neural  networks?</li>
<li>Only continuous probability distribution can be differentiated.</li>
<li>So, we need a discretized version of a continuous probability distribution.</li>
</ul>
<p>Given a distribution,  $P(. | θ)$ is the probability density function (PDF), $F(. | θ)$ is the cumulative density function (CDF), $\theta$ is the parameter set.</p>
<p>Given a set $X= \{x^0, x^1, …, x^{m} \}$ where $x^i \in ℝ$, the probability mass function (PMF) is $P(x^i | θ) = F(x^i + Δ | θ) - F(x^i - Δ | θ)$</p>
<p>It’s easy to compute the gradients of a PMF. E.g.  Logistic distribution</p>
<ul>
<li><p>PDF : $ \frac{1}{s}\sigma(\frac{x-\mu}{s}) (1-\sigma(\frac{x-\mu}{s}))$, where $\sigma(x) = \frac{1}{1+exp(-x)}$</p>
</li>
<li><p>CDF : $\sigma(\frac{x-\mu}{s}) $</p>
</li>
<li><p>A discretized version PMF: $\sigma(\frac{x-\mu +  Δ}{s})  - \sigma(\frac{x-\mu -  Δ}{s}) $</p>
</li>
<li>使用logistic分布的原因是其discretized PDF的函数形式简单（两个sigmoid相减），计算代价低)</li>
</ul>
<p>What is “mixture distribution”?</p>
<ul>
<li>A variable may have multiple  modes, so a single distribution is hard to model such a variable.</li>
<li>$p(x|\theta) = \sum_{i=1}^K w_ip_i(x|\theta_i)$  Where K is the number of components, θ is the parameter set.</li>
</ul>
<p>A softmax distribution can do that task as  well, why don’t use it?</p>
<ul>
<li>When the number of the valid dots is big, using softmax is inefficient. 256-way softmax is good, but the 65536-way is a disaster.</li>
<li>Softmax can’t utilize the inherent structure of continuous number</li>
</ul>
<p>How to use it in training?</p>
<ul>
<li>Use the discretized version to  calculate the likelihoods. It’s easy to back propagate.</li>
<li>Note: be careful of the numerical  problems.</li>
</ul>
<p>How to use it in generating?</p>
<ul>
<li>Use the continuous version of the distribution.</li>
<li>Use re-parametrize trick.</li>
</ul>
<h1 id="参数估计：（分布已知，参数未知）"><a href="#参数估计：（分布已知，参数未知）" class="headerlink" title="参数估计：（分布已知，参数未知）"></a>参数估计：（分布已知，参数未知）</h1><ul>
<li>最大似然估计：使得样本发生的概率$P(Y|\theta)$最大的参数$\theta$即为所估计的参数$\hat{\theta} $,  (这里隐含的假设是所有$\theta$的先验概率均相等)</li>
<li>贝叶斯估计： 使$P(\theta)P(Y|\theta)$最大的参数$\theta$即为所估计的参数$\hat{\theta} $</li>
</ul>
<p><strong>求最大似然函数估计值的一般步骤：</strong></p>
<p>（1）写出似然函数；</p>
<p>（2）对似然函数取对数，并整理；</p>
<p>（3）对参数求偏导，令导数为0，得到似然方程；</p>
<p>（4）解似然方程，若有解析解，则得到的参数即为所求； 若无解析解，如神经网络，可通过梯度下降逼近。</p>
<h1 id="EM"><a href="#EM" class="headerlink" title="EM"></a>EM</h1><p><a href="https://blog.csdn.net/zouxy09/article/details/8537620" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/8537620</a></p>
<ul>
<li>优化目标：maximize $log p(X)$</li>
</ul>
<p>$log p(X;\theta) = \sum_i log   p(x^{(i)};\theta) = \sum_i log \sum_{z^{(i)}} p(x^{(i)},z^{(i)};\theta)  $                <strong>$ x^{(i)}$是常数，$\theta$和$z^{(i)}$是变量</strong></p>
<p>​                   $=\sum_i log \sum_{z^{(i)}} Q_i(z^{(i)}) \frac{p(x^{(i)},z^{(i)};\theta)}{Q^i(z_{(i)})} $</p>
<p>​                    $&gt;=\sum_i \sum_{z^{(i)}} Q_i(z^{(i)}) log \frac{p(x^{(i)},z^{(i)};\theta)}{Q^i(z_{(i)})} ​$       <strong>Jensen不等式  和的对数-&gt;对数的和，便于求导</strong></p>
<p>初始化分布参数$\theta$</p>
<p>E:  根据参数初始值或上一次迭代的模型参数来计算出后验概率 $Q_i(z^{(i)})  = p(z^{(i)}|x^{(i)} ;\theta)$</p>
<p>M:  将似然函数最大化以获得新的参数值  $\theta := argmax_{\theta}\sum_i \sum_{z^{(i)}} Q_i(z^{(i)}) log \frac{p(x^{(i)},z^{(i)};\theta)}{Q^i(z_{(i)})} $</p>
<h1 id="VAE"><a href="#VAE" class="headerlink" title="VAE"></a>VAE</h1><h2 id="Problem-Senario"><a href="#Problem-Senario" class="headerlink" title="Problem Senario"></a>Problem Senario</h2><blockquote>
<p>Let us consider some dataset $X = \{x^(i) \}_{ i=1}^ N$ consisting of $N$ i.i.d. samples of some continuous or discrete variable $x$. We assume that the data are generated by some random process, involving an unobserved continuous random variable $z$. The process consists of two steps: (1) a value $z^(i)$ is generated from some prior distribution $p_{θ^∗} (z)$; (2) a value $x^(i)$ is generated from some conditional distribution $p_{θ^∗} (x|z)$. We assume that the prior $p_{θ^∗} (z)$ and likelihood $p_{θ^∗} (x|z)$ come from parametric families of distributions $p_{θ} (z)$ and $p_{θ} (x|z)$, and that their PDFs are differentiable almost everywhere w.r.t. both θ and z. Unfortunately, a lot of this process is hidden from our view: the true parameters θ ∗ as well as the values of the latent variables z (i) are unknown to us.</p>
<auto-encoding variational bayes>

</auto-encoding></blockquote>
<ul>
<li>Given a dataset $X = {x^1,x^2,x^3…x^N}$</li>
<li>理想优化目标：maximize $log p(X)$</li>
</ul>
<blockquote>
<p>but in general this marginal likelihood is intractable to compute or differentiate directly for ﬂexible generative models, e.g. when components of the generative model are parameterized by neural networks.</p>
<improved variational inference with inverse autoregressive flow>

</improved></blockquote>
<p>Choose prior p(z) to be simple, e.g. Gaussian.</p>
<p>Conditional p(x|z) is complex (generates image) =&gt; represent with neural network</p>
<ul>
<li>Data likelihood $p_{\theta}(x)= \int p_{\theta}(z) p_{\theta}(x|z)$  <strong>Intractible to compute $p_{\theta}(x|z)$ for every z, 无法直接用最大似然</strong></li>
<li>Posterior density also intractable $p_{\theta}(z|x) = p_{\theta}(x|z)p_{\theta}(z)/p_{\theta}(x)$  <strong>Intractable data likelihood 无法采用EM算法</strong></li>
</ul>
<p>Solution: In addition to decoder network modeling $p_θ (x|z)$, define additional encoder network $q_ɸ (z|x) $that approximates $p_θ (z|x)$</p>
<p>$log  p_{\theta}(x^{(i)}) = E_{z^{(i)}::q_{\phi}(z^{(i)}|x^{(i)})}[log  p_{\theta}(x^{(i)})]$     ($ p_{\theta}(x^{(i)}$ does not depend on z)</p>
<p>​                     $=  E_{z^{(i)}}[log  \frac{p_{\theta}(z^{(i)})p_{\theta}(x^{(i)}|z^{(i)})} {p_{\theta}(z^{(i)}|x^{(i)})}] $  (bayes)</p>
<p>​                     $ = E_{z^{(i)}}[log  \frac{p_{\theta}(z^{(i)})p_{\theta}(x^{(i)}|z^{(i)})} {p_{\theta}(z^{(i)}|x^{(i)})}   \frac {q_{\phi}(z^{(i)}|x^{(i)})} {q_{\phi}(z^{(i)}|x^{(i)})}] $</p>
<p>​                      $=  E_{z^{(i)}}[log  p_{\theta}(x^{(i)}|z^{(i)}) ]  - E_{z^{(i)}}[log  \frac{q_{\phi}(z^{(i)}|x^{(i)})} {p_{\theta}(z^{(i)}}] +E_{z^{(i)}}[log  \frac{q_{\phi}(z^{(i)}|x^{(i)})} {p_{\theta}(z^{(i)}|x^{(i)})}]  $</p>
<p>​                      $=  E_{z^{(i)}}[log  p_{\theta}(x^{(i)}|z^{(i)}) ]  -D_{KL}({q_{\phi}(z^{(i)}|x^{(i)})}|| {p_{\theta}(z^{(i)}})+ D_{KL}({q_{\phi}(z^{(i)}|x^{(i)})} ||{p_{\theta}(z^{(i)}|x^{(i)})}) $</p>
<p>​                          <strong>reconstruction loss</strong>                <strong>KL loss </strong>                        $p_{\theta}(z^{(i)}|x^{(i)}) untractable, KL&gt;=0$</p>
<p>​                         <strong>Reparameterization</strong></p>
<blockquote>
 <cs231n _2017_lecture13>

</cs231n></blockquote>
<p>Pros:</p>
<ul>
<li><p>Principled approach to generative models</p>
</li>
<li><p>Allows inference of q(z|x), can be useful feature representation for other tasks</p>
</li>
</ul>
<p>Cons:</p>
<ul>
<li><p>Maximizes lower bound of likelihood: okay, but not as good evaluation as PixelRNN/PixelCNN</p>
</li>
<li><p>Samples blurrier and lower quality compared to state-of-the-art (GANs)</p>
</li>
</ul>
<h1 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h1><ul>
<li>Explicit density   显示的对$p(x)$进行建模</li>
<li>Tractable density</li>
</ul>
<p>$x$~$p(x)$, $z$~$\pi(z)$ , $x = f(z)$   The function $f$ is invertible</p>
<p>=&gt; $p(x)=\pi(z)|det(\frac{dz}{dx})|$</p>
<p><img src="https://lilianweng.github.io/lil-log/assets/images/normalizing-flow.png" alt="Normalizing flow"></p>
<p>=&gt; $p_i(z_i) = p_{i-1}(z_{i-1}) |det (\frac{dz_{i-1}}{dz_i})| =  p_{i-1}(z_{i-1}) |det ((\frac{dz_i}{dz_{i-1}})^{-1})| = p_{i-1}(z_{i-1}) |det (\frac{dz_i}{dz_{i-1}})|^{-1}$    </p>
<blockquote>
<p> because  $det(AB)=det(A)det(B)$   ,   $1 = det(AA^{-1})) = det(A)det(A^{-1})$  </p>
</blockquote>
<p>=&gt; $log  p_i(z_i)  = log  p_{i-1}(z_{i-1})  - log |det (\frac{dz_i}{dz_{i-1}})|$</p>
<p>=&gt; $log  p_i(z_i)  = log  p_{0}(z_{0})  - \sum_{i=1}^{K} log |det (\frac{dz_i}{dz_{i-1}})|$</p>
<p>Required by the computation in the equation, a transformation function fifi should satisfy two properties:</p>
<ol>
<li>It is easily invertible.  (easy to generate data)</li>
<li>Its Jacobian determinant is easy to compute.  (easy to compute loss)</li>
</ol>
<h2 id="autoregressive"><a href="#autoregressive" class="headerlink" title="autoregressive"></a>autoregressive</h2><blockquote>
<p>Examples of such functions are autoregressive neural density estimators such as RNNs, MADE (Germain et al., 2015), PixelCNN (van den Oord et al., 2016b) or WaveNet (van den Oord et al., 2016a) models.</p>
<improved variational inference with inverse autoregressive flow>

</improved></blockquote>
<h3 id="PixelRNN-PixelCNN-Wavenet"><a href="#PixelRNN-PixelCNN-Wavenet" class="headerlink" title="PixelRNN   /   PixelCNN  /  Wavenet"></a>PixelRNN   /   PixelCNN  /  Wavenet</h3><p><strong>define tractable density function</strong></p>
<p>优化目标： maximize $p(x) = \prod_{i=1}^n  p(x_i|x_1,x_2,…,x_{i-1})$</p>
<ul>
<li>用神经网络(RNN/CNN)描述$p(x_i|x_1,x_2,…,x_{i-1})$</li>
<li>Softmax 计算概率(神经网络输出N个值,经过softmax归一化为N个类别的概率值)  </li>
<li>cross entropy计算loss</li>
<li>argmax采样 | 按照softmax probability随机采样</li>
</ul>
<p>pros</p>
<ul>
<li>Can explicitly compute likelihood p(x)</li>
<li>Explicit likelihood of training data gives good evaluation metric</li>
<li>Good samples</li>
</ul>
<p>cons</p>
<ul>
<li>Sequential generation =&gt; slow (CNN训练可并行，但生成还是序列化的)</li>
</ul>
<p>改进的loss: </p>
<p>根据data的连续或离散选取连续分布或者离散化的分布</p>
<ul>
<li>Gaussian loss   （神经网络预测mean &amp; scale）</li>
</ul>
<p>​         $x_t=z_t*\sigma(x_{&lt;t})+\mu(x_{&lt;t})$   其中$\sigma()$和$\mu()$均为神经网络,    $z_t$服从高斯分布</p>
<p>​         神经网络输出2个值：$\mu   ,  log  \sigma$       ( $log  \sigma$ 可正可负)</p>
<ul>
<li><p>Discretized logistic loss</p>
<p>A mixture of logistics (MoL) is a set of M  Logistic distributions, each with its own $\mu$ and $\sigma$ and $w$ which will determine the probability of a distribution to be picked.</p>
<p>神经网络输出3M个值</p>
</li>
</ul>
<h2 id="Inverse-Autoregressive-Flow"><a href="#Inverse-Autoregressive-Flow" class="headerlink" title="Inverse Autoregressive Flow"></a>Inverse Autoregressive Flow</h2><h3 id="parallel-wavenet"><a href="#parallel-wavenet" class="headerlink" title="parallel wavenet"></a>parallel wavenet</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">lizzy llq</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lizzy llq</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
