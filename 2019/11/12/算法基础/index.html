<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="C++语法基础知识0. 语法基础指针 &amp;amp; 引用1234int i = 5; int j = 6; int &amp;amp;k = i; k = j; // k 和 i 的值都变成了 6; &amp;amp; 用于创建引用变量以及取变量的地址，*用于创建指针变量以及解引用 指针和引用的区别：https://geekplux.com/2013/01/02/pointer_references  一、指针是一">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithm &amp; Data Structure">
<meta property="og:url" content="http://yoursite.com/2019/11/12/算法基础/index.html">
<meta property="og:site_name" content="Forward">
<meta property="og:description" content="C++语法基础知识0. 语法基础指针 &amp;amp; 引用1234int i = 5; int j = 6; int &amp;amp;k = i; k = j; // k 和 i 的值都变成了 6; &amp;amp; 用于创建引用变量以及取变量的地址，*用于创建指针变量以及解引用 指针和引用的区别：https://geekplux.com/2013/01/02/pointer_references  一、指针是一">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/1026866/201610/1026866-20161016022859889-2055402664.jpg">
<meta property="og:image" content="https://assets.leetcode.com/users/motorix/image_1538888300.png">
<meta property="og:updated_time" content="2019-11-12T08:21:12.103Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Algorithm &amp; Data Structure">
<meta name="twitter:description" content="C++语法基础知识0. 语法基础指针 &amp;amp; 引用1234int i = 5; int j = 6; int &amp;amp;k = i; k = j; // k 和 i 的值都变成了 6; &amp;amp; 用于创建引用变量以及取变量的地址，*用于创建指针变量以及解引用 指针和引用的区别：https://geekplux.com/2013/01/02/pointer_references  一、指针是一">
<meta name="twitter:image" content="https://images2015.cnblogs.com/blog/1026866/201610/1026866-20161016022859889-2055402664.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/11/12/算法基础/">





  <title>Algorithm & Data Structure | Forward</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Forward</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/12/算法基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lizzy llq">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Forward">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Algorithm & Data Structure</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-12T16:10:30+08:00">
                2019-11-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="C-语法基础知识"><a href="#C-语法基础知识" class="headerlink" title="C++语法基础知识"></a>C++语法基础知识</h1><h2 id="0-语法基础"><a href="#0-语法基础" class="headerlink" title="0. 语法基础"></a>0. 语法基础</h2><h3 id="指针-amp-引用"><a href="#指针-amp-引用" class="headerlink" title="指针 &amp; 引用"></a>指针 &amp; 引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>; </span><br><span class="line"><span class="keyword">int</span> j = <span class="number">6</span>; </span><br><span class="line"><span class="keyword">int</span> &amp;k = i; </span><br><span class="line">k = j; <span class="comment">// k 和 i 的值都变成了 6;</span></span><br></pre></td></tr></table></figure>
<p><strong>&amp; 用于创建引用变量以及取变量的地址，*用于创建指针变量以及解引用</strong></p>
<p>指针和引用的区别：<a href="https://geekplux.com/2013/01/02/pointer_references" target="_blank" rel="noopener">https://geekplux.com/2013/01/02/pointer_references</a></p>
<ul>
<li><p><strong>一、指针是一个实体（本质上就是存放变量地址的一个变量），而引用只是个别名。</strong></p>
<p>这句话从内存分配的角度很好理解，程序会为指针变量分配内存区域，而引用不分配内存区域。</p>
</li>
<li><p><strong>二、指针可变，引用不可变。</strong></p>
<p>指针在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。</p>
</li>
</ul>
<p>引用在逻辑上不独立，具有依附性，所以引用<strong>必须在一开始就被初始化</strong>，而且引用一旦和某个对象绑定后就不能再改变（从一而终）。</p>
<ul>
<li><p><strong>三、指针可以为空，引用不能为空。</strong></p>
<p> 即指针可以为 NULL，而引用必须与合法的存储单元关联。（指针则可以是 NULL，因此相对于指针，它不用检查它所指对象是否为空，这增加了效率）</p>
</li>
<li><p><strong>四、「sizeof 引用」得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小（</strong>由当前CPU运行模式的寻址位数决定,64位处理器上64位操作系统的64位编译器，指针大小8字节。8个字节）</p>
<p>指针通过*操作被指变量，引用直接操作被引变量，如指针和引用的自增(++)运算意义不一样</p>
</li>
<li><p><strong>五、引用不能 const，指针能 const，const 的指针不可变。</strong> </p>
<p>对于引用，具体指没有 int&amp;const a 这种形式，而 const int&amp; a 是有的， 前者指引用本身（即别名）不可以改变，这是理所当然的，所以不需要这种形式，后者指引用所指的值不可以改变）</p>
</li>
</ul>
<p>Tips: <strong>用适当的工具做恰如其分的工作</strong>  </p>
<p>指针能够毫无约束地操作内存中的任何东西，尽管指针功能强大，但是非常危险。</p>
<p>如果的确只需要借用一下某个对象的”别名”，那么就用”引用”，而不要用”指针”，以免发生意外</p>
<h3 id="for循环（范围循环）"><a href="#for循环（范围循环）" class="headerlink" title="for循环（范围循环）"></a>for循环（范围循环）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> my_array[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 每个数组元素乘于 2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x : my_array)</span><br><span class="line">&#123;</span><br><span class="line">    x *= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// auto 类型也是 C++11 新标准中的，用来自动获取变量的类型</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : my_array) &#123;</span><br><span class="line">    x *= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="STL综述"><a href="#STL综述" class="headerlink" title="STL综述"></a>STL综述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1) vector  变长数组，倍增的思想 (系统为某一程序分配空间时所需要的时间和空间大小无关，和申请次数有关)</span></span><br><span class="line"><span class="comment">    size()  返回元素个数</span></span><br><span class="line"><span class="comment">    empty()  返回是否为空</span></span><br><span class="line"><span class="comment">    clear()  清空</span></span><br><span class="line"><span class="comment">    front()/back()</span></span><br><span class="line"><span class="comment">    push_back()/pop_back()</span></span><br><span class="line"><span class="comment">    begin()/end()</span></span><br><span class="line"><span class="comment">    []</span></span><br><span class="line"><span class="comment">    支持比较运算，按字典序</span></span><br><span class="line"><span class="comment"> 2) pair&lt;int, int&gt;</span></span><br><span class="line"><span class="comment">     first, 第一个元素</span></span><br><span class="line"><span class="comment">     second, 第二个元素</span></span><br><span class="line"><span class="comment">     支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span></span><br><span class="line"><span class="comment"> 3) string 字符串</span></span><br><span class="line"><span class="comment">     size()/length()  返回字符串长度</span></span><br><span class="line"><span class="comment">     empty()</span></span><br><span class="line"><span class="comment">     clear()</span></span><br><span class="line"><span class="comment">     substr(起始下标，(子串长度))  返回子串</span></span><br><span class="line"><span class="comment">     c_str()  返回字符串所在字符数组的起始地址</span></span><br><span class="line"><span class="comment">4) queue, 队列</span></span><br><span class="line"><span class="comment">	size()</span></span><br><span class="line"><span class="comment">    empty()</span></span><br><span class="line"><span class="comment">    push()  向队尾插入一个元素</span></span><br><span class="line"><span class="comment">    front()  返回队头元素</span></span><br><span class="line"><span class="comment">    back()  返回队尾元素</span></span><br><span class="line"><span class="comment">    pop()  弹出队头元素</span></span><br><span class="line"><span class="comment">5) priority_queue, 优先队列，默认是大根堆</span></span><br><span class="line"><span class="comment">	push()  插入一个元素</span></span><br><span class="line"><span class="comment">    top()  返回堆顶元素</span></span><br><span class="line"><span class="comment">    pop()  弹出堆顶元素</span></span><br><span class="line"><span class="comment">    定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;</span></span><br><span class="line"><span class="comment">6) stack, 栈</span></span><br><span class="line"><span class="comment">    size()</span></span><br><span class="line"><span class="comment">    empty()</span></span><br><span class="line"><span class="comment">    push()  向栈顶插入一个元素</span></span><br><span class="line"><span class="comment">    top()  返回栈顶元素</span></span><br><span class="line"><span class="comment">    pop()  弹出栈顶元素</span></span><br><span class="line"><span class="comment">7) deque, 双端队列</span></span><br><span class="line"><span class="comment">    size()</span></span><br><span class="line"><span class="comment">    empty()</span></span><br><span class="line"><span class="comment">    clear()</span></span><br><span class="line"><span class="comment">    front()/back()</span></span><br><span class="line"><span class="comment">    push_back()/pop_back()</span></span><br><span class="line"><span class="comment">    push_front()/pop_front()</span></span><br><span class="line"><span class="comment">    begin()/end()</span></span><br><span class="line"><span class="comment">    []</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">8) set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</span></span><br><span class="line"><span class="comment">    size()</span></span><br><span class="line"><span class="comment">    empty()</span></span><br><span class="line"><span class="comment">    clear()</span></span><br><span class="line"><span class="comment">    begin()/end()</span></span><br><span class="line"><span class="comment">    ++, -- 返回前驱和后继，时间复杂度 O(logn)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    set/multiset</span></span><br><span class="line"><span class="comment">        insert()  插入一个数</span></span><br><span class="line"><span class="comment">        find()  查找一个数</span></span><br><span class="line"><span class="comment">        count()  返回某一个数的个数</span></span><br><span class="line"><span class="comment">        erase()</span></span><br><span class="line"><span class="comment">            (1) 输入是一个数x，删除所有x   O(k + logn)</span></span><br><span class="line"><span class="comment">            (2) 输入一个迭代器，删除这个迭代器</span></span><br><span class="line"><span class="comment">        lower_bound()/upper_bound()</span></span><br><span class="line"><span class="comment">            lower_bound(x)  返回大于等于x的最小的数的迭代器</span></span><br><span class="line"><span class="comment">            upper_bound(x)  返回大于x的最小的数的迭代器</span></span><br><span class="line"><span class="comment">    map/multimap</span></span><br><span class="line"><span class="comment">        insert()  插入的数是一个pair</span></span><br><span class="line"><span class="comment">        erase()  输入的参数是pair或者迭代器</span></span><br><span class="line"><span class="comment">        find()</span></span><br><span class="line"><span class="comment">        []  注意multimap不支持此操作。 时间复杂度是 O(logn)</span></span><br><span class="line"><span class="comment">        lower_bound()/upper_bound()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">9) unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</span></span><br><span class="line"><span class="comment">    和上面类似，增删改查的时间复杂度是 O(1)</span></span><br><span class="line"><span class="comment">    不支持 lower_bound()/upper_bound()， 迭代器的++，--</span></span><br><span class="line"><span class="comment">10) bitset, 圧位</span></span><br><span class="line"><span class="comment">    bitset&lt;10000&gt; s;</span></span><br><span class="line"><span class="comment">    ~, &amp;, |, ^</span></span><br><span class="line"><span class="comment">    &gt;&gt;, &lt;&lt;</span></span><br><span class="line"><span class="comment">    ==, !=</span></span><br><span class="line"><span class="comment">    []</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    count()  返回有多少个1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    any()  判断是否至少有一个1</span></span><br><span class="line"><span class="comment">    none()  判断是否全为0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    set()  把所有位置成1</span></span><br><span class="line"><span class="comment">    set(k, v)  将第k位变成v</span></span><br><span class="line"><span class="comment">    reset()  把所有位变成0</span></span><br><span class="line"><span class="comment">    flip()  等价于~</span></span><br><span class="line"><span class="comment">    flip(k) 把第k位取反</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><blockquote>
<p>Vectors are sequence containers representing arrays that can change in size.</p>
</blockquote>
<p><a href="http://www.cplusplus.com/reference/vector/vector/?kw=vector" target="_blank" rel="noopener">http://www.cplusplus.com/reference/vector/vector/?kw=vector</a></p>
<p><strong>vector的创建</strong></p>
<p>(1) empty container constructor (default constructor)</p>
<ul>
<li>Constructs an <a href="http://www.cplusplus.com/vector::empty" target="_blank" rel="noopener">empty</a> container, with no elements.</li>
</ul>
<p>(2) fill constructor</p>
<ul>
<li>Constructs a container with <em>n</em> elements. Each element is a copy of <em>val</em>(<strong>默认为0</strong>).</li>
</ul>
<p>(3) range constructor （<strong>from vector or array</strong>）</p>
<ul>
<li>Constructs a container with as many elements as the range <code>[first,last)</code>, with each element constructed from its corresponding element in that range, in the same order.</li>
</ul>
<p>(4) copy constructor （<strong>copy from another vector只能从vector复制，不能从array复制</strong>）</p>
<ul>
<li>Constructs a container with a copy of each of the elements in <em>x</em>, in the same order.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constructin vectors</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// constructors used in the same order as described above:</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; first;                                <span class="comment">// empty vector of ints</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; second (<span class="number">4</span>,<span class="number">100</span>);                       <span class="comment">// four ints with value 100</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; third (second.begin(),second.end());  <span class="comment">// iterating through second</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fourth (third);                       <span class="comment">// a copy of third</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// the iterator constructor can also be used to construct from arrays:</span></span><br><span class="line">  <span class="keyword">int</span> myints[] = &#123;<span class="number">16</span>,<span class="number">2</span>,<span class="number">77</span>,<span class="number">29</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fifth (myints, myints + <span class="keyword">sizeof</span>(myints) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">  <span class="comment">//也可以直接赋值</span></span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sixth = &#123;<span class="number">16</span>,<span class="number">2</span>,<span class="number">77</span>,<span class="number">29</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The contents of fifth are:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = fifth.begin(); it != fifth.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>数字转string: to_string()</p>
<p>string转int   </p>
<ul>
<li><p>atoi()用于c风格字符串    </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="built_in">std</span>::atoi( s.c_str() );</span><br></pre></td></tr></table></figure>
</li>
<li><p>stoi()用于string</p>
<ul>
<li>atoi()的参数是 const char<em> ,因此对于一个字符串str我们必须调用 c_str()的方法把这个string转换成 const char</em>类型的,而stoi()的参数是const string<em>,不需要转化为 const char</em>；</li>
<li>stoi()会做范围检查，默认范围是在int的范围内的，如果超出范围的话则会runtime error！而atoi()不会做范围检查，如果超出范围的话，超出上界，则输出上界，超出下界，则输出下界；</li>
</ul>
</li>
<li><p>stringstream  </p>
</li>
</ul>
<p>string类的大小写转换： transform(str.begin(),str.end(),str.begin(),::tolower)</p>
<h3 id="set-map"><a href="#set-map" class="headerlink" title="set map"></a>set map</h3><p>set  unordered_set仅存key （(each value is itself also the element’s key).）</p>
<p>map unordered_map存key和value</p>
<p>set map unordered_set unordered_map中key唯一</p>
<p>set  map 由红黑树实现</p>
<p>unordered_set unordered_map 由哈希表实现</p>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p><strong>Associative, Ordered, Set, Unique keys, Allocator-aware</strong></p>
<p>set 创建</p>
<p>(1) empty container constructor (default constructor)</p>
<ul>
<li>Constructs an <a href="http://www.cplusplus.com/set::empty" target="_blank" rel="noopener">empty</a> container, with no elements.</li>
</ul>
<p>(2) range constructor</p>
<ul>
<li>Constructs a container with as many elements as the range <code>[first,last)</code>, with each element constructed from its corresponding element in that range.</li>
</ul>
<p>(3) copy constructor</p>
<ul>
<li>Constructs a container with a copy of each of the elements in <em>x</em>.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constructing sets</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fncomp</span> <span class="params">(<span class="keyword">int</span> lhs, <span class="keyword">int</span> rhs)</span> </span>&#123;<span class="keyword">return</span> lhs&lt;rhs;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">classcomp</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; lhs, <span class="keyword">const</span> <span class="keyword">int</span>&amp; rhs)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;<span class="keyword">return</span> lhs&lt;rhs;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; first;                           <span class="comment">// empty set of ints</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> myints[]= &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; second (myints,myints+<span class="number">5</span>);        <span class="comment">// range</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; third (second);                  <span class="comment">// a copy of second</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; fourth (second.begin(), second.end());  <span class="comment">// iterator ctor.</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>,classcomp&gt; fifth;                 <span class="comment">// class as Compare</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span>(*fn_pt)(<span class="keyword">int</span>,<span class="keyword">int</span>) = fncomp;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>(*)(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; sixth (fn_pt);  <span class="comment">// function pointer as Compare</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>count   </p>
<ul>
<li><p>return 1 if an element with a value equivalent to <em>k</em> is found, or zero otherwise.</p>
</li>
<li><p>时间复杂度 Logarithmic in size</p>
</li>
</ul>
</li>
<li><p>find </p>
<ul>
<li>An iterator to the element, if <em>val</em> is found, or <a href="http://www.cplusplus.com/set::end" target="_blank" rel="noopener">set::end</a> otherwise.</li>
<li>时间复杂度  Logarithmic in size</li>
</ul>
</li>
</ul>
<p><a href="https://blog.csdn.net/yas12345678/article/details/52601454" target="_blank" rel="noopener">https://blog.csdn.net/yas12345678/article/details/52601454</a></p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p><strong>Associative, Ordered, Map, Unique keys, Allocator-aware</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unordered_map::operator[]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="built_in">std</span>::<span class="built_in">string</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">"Bakery"</span>]=<span class="string">"Barbara"</span>;  <span class="comment">// new element inserted</span></span><br><span class="line">  mymap[<span class="string">"Seafood"</span>]=<span class="string">"Lisa"</span>;    <span class="comment">// new element inserted</span></span><br><span class="line">  mymap[<span class="string">"Produce"</span>]=<span class="string">"John"</span>;    <span class="comment">// new element inserted</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name = mymap[<span class="string">"Bakery"</span>];   <span class="comment">// existing element accessed (read)</span></span><br><span class="line">  mymap[<span class="string">"Seafood"</span>] = name;              <span class="comment">// existing element accessed (written)</span></span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">"Bakery"</span>] = mymap[<span class="string">"Produce"</span>];   <span class="comment">// existing elements accessed (read/written)</span></span><br><span class="line"></span><br><span class="line">  name = mymap[<span class="string">"Deli"</span>];      <span class="comment">// non-existing element: new element "Deli" inserted!</span></span><br><span class="line"></span><br><span class="line">  mymap[<span class="string">"Produce"</span>] = mymap[<span class="string">"Gifts"</span>];    <span class="comment">// new element "Gifts" inserted, "Produce" written</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: mymap) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x.first &lt;&lt; <span class="string">": "</span> &lt;&lt; x.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h4><ul>
<li><p>创建</p>
<p>(1) empty container constructor (default constructor)</p>
<ul>
<li>Constructs an empty <a href="http://www.cplusplus.com/unordered_set" target="_blank" rel="noopener">unordered_set</a> object, containing no elements and with a <a href="http://www.cplusplus.com/unordered_set::size" target="_blank" rel="noopener">size</a> of zero.</li>
<li>It can construct the container with specific <em>hasher</em>, <em>key_equal</em> and <em>allocator</em> objects, along with a minimum number of hash buckets.</li>
</ul>
<p>(2) range constructor</p>
<ul>
<li>Constructs an <a href="http://www.cplusplus.com/unordered_set" target="_blank" rel="noopener">unordered_set</a> object containing copies of each of the elements in the range <code>[first,last)</code>.</li>
</ul>
<p>(3) copy constructor (and copying with allocator)</p>
<ul>
<li>The object is initialized to have the same contents and properties as the <em>ust</em> <a href="http://www.cplusplus.com/unordered_set" target="_blank" rel="noopener">unordered_set</a> object.</li>
</ul>
<p>(4) move constructor (and moving with allocator)</p>
<ul>
<li>The object acquires the contents of the rvalue <em>ust</em>.</li>
</ul>
<p>(5) initializer list</p>
<ul>
<li>Initializes the container with the contents of the list.</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constructing unordered_sets</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">cmerge</span> (<span class="title">T</span> <span class="title">a</span>, <span class="title">T</span> <span class="title">b</span>) &#123;</span> <span class="function">T <span class="title">t</span><span class="params">(a)</span></span>; t.insert(b.begin(),b.end()); <span class="keyword">return</span> t; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; first;                                <span class="comment">// empty</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; second ( &#123;<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>&#125; );    <span class="comment">// init list</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; third ( &#123;<span class="string">"orange"</span>,<span class="string">"pink"</span>,<span class="string">"yellow"</span>&#125; ); <span class="comment">// init list</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; fourth ( second );                    <span class="comment">// copy</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; fifth ( cmerge(third,fourth) );       <span class="comment">// move</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; sixth ( fifth.begin(), fifth.end() ); <span class="comment">// range</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sixth contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; x: sixth) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>insert</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unordered_set::insert</span></span><br><span class="line">include &lt;iostream&gt;</span><br><span class="line">include &lt;<span class="built_in">string</span>&gt;</span><br><span class="line">include &lt;<span class="built_in">array</span>&gt;</span><br><span class="line">include &lt;<span class="built_in">unordered_set</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::unordered_setstd::<span class="built_in">string</span> myset = &#123;<span class="string">"yellow"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::arraystd::<span class="built_in">string</span>,<span class="number">2</span> myarray = &#123;<span class="string">"black"</span>,<span class="string">"white"</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> mystring = <span class="string">"red"</span>;</span><br><span class="line">  myset.insert (mystring);                        <span class="comment">// copy insertion</span></span><br><span class="line">  myset.insert (mystring+<span class="string">"dish"</span>);                 <span class="comment">// move insertion</span></span><br><span class="line">  myset.insert (myarray.begin(), myarray.end());  <span class="comment">// range insertion</span></span><br><span class="line">  myset.insert ( &#123;<span class="string">"purple"</span>,<span class="string">"orange"</span>&#125; );           <span class="comment">// initializer list insertion</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myset contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; x: myset) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>count   </p>
<ul>
<li>return 1 if an element with a value equivalent to <em>k</em> is found, or zero otherwise.</li>
<li>时间复杂度  Average case: constant  | Worst case: linear in container size</li>
</ul>
</li>
<li><p>find </p>
<ul>
<li>An iterator to the element, if the specified value is found, or <a href="http://www.cplusplus.com/unordered_set::end" target="_blank" rel="noopener">unordered_set::end</a> if it is not found in the container.</li>
<li>时间复杂度  Average case: constant  | Worst case: linear in container size</li>
</ul>
</li>
</ul>
<h4 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h4><p><strong>Associative, Unordered, Map, Unique keys, Allocator-aware</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;Key,T&gt;::iterator it;</span><br><span class="line">(*it).first;             <span class="comment">// the key value (of type Key)</span></span><br><span class="line">(*it).second;            <span class="comment">// the mapped value (of type T)</span></span><br><span class="line">(*it);                   <span class="comment">// the "element value" (of type pair&lt;const Key,T&gt;)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">it-&gt;first;               <span class="comment">// same as (*it).first   (the key value)</span></span><br><span class="line">it-&gt;second;              <span class="comment">// same as (*it).second  (the mapped value)</span></span><br></pre></td></tr></table></figure>
<h3 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h3><p><a href="http://c.biancheng.net/view/481.html" target="_blank" rel="noopener">http://c.biancheng.net/view/481.html</a></p>
<p>priority_queue默认为大顶堆，即堆顶元素为堆中最大元素。</p>
<blockquote>
<p>priority_queue<int> q;</int></p>
<p>等价于：priority_queue<int, vector<int>, less<int> &gt; q;     // 大顶堆</int></int,></p>
</blockquote>
<p>如果我们想要用小顶堆的话需要增加使用两个参数：</p>
<blockquote>
<p> priority_queue<int, vector<int>, greater<int> &gt; q;  // 小顶堆</int></int,></p>
</blockquote>
<ul>
<li>pari的比较，先比较第一个元素，第一个相等比较第二个</li>
</ul>
<p>尽管提供了大小顶堆的模板，但是我们在实际应用过程中往往会使用更加复杂的数据结构构建堆，这时候我们就需要自定义数据结构的比较方式了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cell</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    Cell() &#123;&#125;</span><br><span class="line">    Cell(<span class="keyword">int</span> x,<span class="keyword">int</span> y, <span class="keyword">int</span> h): x(x),y(y),h(h) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Cell &amp; c1, <span class="keyword">const</span> Cell &amp; c2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c1.h &lt; c2.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Cell, <span class="built_in">vector</span>&lt;Cell&gt;, cmp&gt; q; <span class="comment">//template&lt;class_tp, class_sequence, class_cmp&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><h4 id="sort函数"><a href="#sort函数" class="headerlink" title="sort函数"></a>sort函数</h4><p><a href="http://www.cplusplus.com/reference/algorithm/sort/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/algorithm/sort/</a></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// sort algorithm example</span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;    // std::sort</span></span></span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;       // std::vector</span></span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">bool</span> <span class="title">myfunction</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j); &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="class"><span class="keyword">struct</span> <span class="title">myclass</span> &#123;</span></span><br><span class="line">&gt;   <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j);&#125;</span><br><span class="line">&gt; &#125; myobject;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;   <span class="keyword">int</span> myints[] = &#123;<span class="number">32</span>,<span class="number">71</span>,<span class="number">12</span>,<span class="number">45</span>,<span class="number">26</span>,<span class="number">80</span>,<span class="number">53</span>,<span class="number">33</span>&#125;;</span><br><span class="line">&gt;   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints, myints+<span class="number">8</span>);             <span class="comment">// 32 71 12 45 26 80 53 33</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="comment">// using default comparison (operator &lt;):</span></span><br><span class="line">&gt;   <span class="built_in">std</span>::sort (myvector.begin(), myvector.begin()+<span class="number">4</span>);         <span class="comment">//(12 32 45 71)26 80 53 33</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="comment">// using function as comp</span></span><br><span class="line">&gt;   <span class="built_in">std</span>::sort (myvector.begin()+<span class="number">4</span>, myvector.end(), myfunction); <span class="comment">// 12 32 45 71(26 33 53 80)</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="comment">// using object as comp</span></span><br><span class="line">&gt;   <span class="built_in">std</span>::sort (myvector.begin(), myvector.end(), myobject); <span class="comment">//(12 26 32 33 45 53 71 80)</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="comment">// print out content:</span></span><br><span class="line">&gt;   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">&gt;   <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)</span><br><span class="line">&gt;     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">&gt;   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="n-th-element"><a href="#n-th-element" class="headerlink" title="n-th element"></a>n-th element</h4><div class="table-container">
<table>
<thead>
<tr>
<th>default (1)</th>
<th><code>template &lt;class RandomAccessIterator&gt;   void nth_element (RandomAccessIterator first, RandomAccessIterator nth,                     RandomAccessIterator last);</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>custom (2)</td>
<td><code>template &lt;class RandomAccessIterator, class Compare&gt;   void nth_element (RandomAccessIterator first, RandomAccessIterator nth,                     RandomAccessIterator last, Compare comp);</code></td>
</tr>
</tbody>
</table>
</div>
<p>Rearranges the elements in the range <code>[first,last)</code>, in such a way that the element at the nth position is the element that would be in that position in a sorted sequence.<br>The other elements are left without any specific order, except that none of the elements preceding nth are greater than it, and none of the elements following it are less.<br>The elements are compared using <code>operator&lt;</code> for the first version, and comp for the second.</p>
<h4 id="transform-函数"><a href="#transform-函数" class="headerlink" title="transform 函数"></a>transform 函数</h4><p> transform() 可以将函数应用到序列(单个或一对)的元素上，并将这个函数返回的值保存到另一个序列中，它返回的迭代器指向输出序列所保存的最后一个元素的下一个位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">UnaryOperator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">OutputIterator</span> <span class="title">transform</span> (<span class="title">InputIterator</span> <span class="title">first1</span>, <span class="title">InputIterator</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">UnaryOperator</span> <span class="title">op</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (first1 != last1) &#123;</span><br><span class="line">    *result = op(*first1);  <span class="comment">// or: *result=binary_op(*first1,*first2++);</span></span><br><span class="line">    ++result; ++first1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">BinaryOperation</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">OutputIterator</span> <span class="title">transform</span> (<span class="title">InputIterator1</span> <span class="title">first1</span>, <span class="title">InputIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">InputIterator2</span> <span class="title">first2</span>, <span class="title">OutputIterator</span> <span class="title">result</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">BinaryOperation</span> <span class="title">binary_op</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (first1 != last1) &#123;</span><br><span class="line">    *result=binary_op(*first1,*first2);</span><br><span class="line">    ++result; ++first1; ++first2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transform algorithm example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;    // std::transform</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;       // std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;   // std::plus</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op_increase</span> <span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> ++i; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; foo;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bar;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set some values:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; i++)</span><br><span class="line">    foo.push_back (i*<span class="number">10</span>);                         <span class="comment">// foo: 10 20 30 40 50</span></span><br><span class="line"></span><br><span class="line">  bar.resize(foo.size());                         <span class="comment">// allocate space</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::transform (foo.begin(), foo.end(), bar.begin(), op_increase);</span><br><span class="line">                                                  <span class="comment">// bar: 11 21 31 41 51</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// std::plus adds together its two arguments:</span></span><br><span class="line">  <span class="built_in">std</span>::transform (foo.begin(), foo.end(), bar.begin(), foo.begin(), <span class="built_in">std</span>::plus&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">                                                  <span class="comment">// foo: 21 41 61 81 101</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=foo.begin(); it!=foo.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><p><a href="https://stackoverflow.com/questions/17484354/why-cant-i-do-stdmap-begin-1" target="_blank" rel="noopener">https://stackoverflow.com/questions/17484354/why-cant-i-do-stdmap-begin-1</a></p>
<blockquote>
<p><code>std::map&lt;T&gt;::iterator</code> is of the iterator-class <em>bidirectional iterator</em>. Those only have <code>++</code> and <code>--</code>operators. <code>+N</code> and <code>[]</code> is only available for <em>random access iterators</em> (which can be found in e.g. <code>std::vector&lt;T&gt;</code>).</p>
<p>The reason behind this is that adding <code>N</code> to a <em>random access iterator</em> is constant time (e.g. add <code>N*sizeof(T)</code> to a <code>T*</code>), whereas doing the same thing for a <em>bidirectional iterator</em> would require applying <code>++</code> <code>N</code> times.</p>
<p>What you can do though (if you have C++11) is:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::const_iterator pIterTwo = <span class="built_in">std</span>::next(pSomeMap.begin(),<span class="number">1</span>);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><p>无序array</p>
<ul>
<li>无序查找：find</li>
</ul>
<p>有序array</p>
<ul>
<li>无序变有序： sort</li>
<li>有序查找： search</li>
</ul>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p><a href="https://www.jianshu.com/p/6365818c10ad" target="_blank" rel="noopener">https://www.jianshu.com/p/6365818c10ad</a></p>
<p>插入排序</p>
<ul>
<li>稳定排序，输入敏感（最好情况顺序：O(n),最坏情况逆序：O(n^2), 平均时间复杂度：O(n^2)）</li>
</ul>
<p>选择排序</p>
<ul>
<li>不稳定排序（交换位置的时候可能使得重复元素相互跨越），输入不敏感（O(n^2)）</li>
</ul>
<p>冒泡排序</p>
<ul>
<li>稳定排序，输入敏感（最好情况顺序：O(n),最坏情况逆序：O(n^2), 平均时间复杂度：O(n^2)）</li>
</ul>
<p>归并排序</p>
<ul>
<li>稳定，输入不敏感（O(nlogn)）</li>
</ul>
<p>快速排序</p>
<ul>
<li>不稳定,输入敏感（最好情况：O(nlogn) 最坏情况：顺序或逆序O(n^2), 平均时间复杂度：O(nlogn)）</li>
<li>随机快排 </li>
</ul>
<p>堆排序: 不稳定，输入不敏感（O(nlogn)）</p>
<p>数字范围：[0,M)   eg:荷兰国旗问题</p>
<p>桶排序: 链表数组  </p>
<ul>
<li>稳定排序   时间复杂度：O(n+M)  空间复杂度：O(n)</li>
</ul>
<p>应用：MaxGap</p>
<p>计数排序：通过数组记录每个数字的count[],accun[]  </p>
<ul>
<li>稳定排序  时间复杂度：O(n+M)  空间复杂度：O(n)</li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; q, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> <span class="comment">// [lo, hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hi - lo &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mi = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">    merge_sort(q, lo, mi);</span><br><span class="line">    merge_sort(q, mi, hi);</span><br><span class="line">    merge(q, lo, mi, hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; q, <span class="keyword">int</span> lo, <span class="keyword">int</span> mi, <span class="keyword">int</span> hi)</span></span>&#123; <span class="comment">// [lo, mi) [mi, hi)</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = lo, j = mi;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(hi - lo, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; mi &amp;&amp; j &lt; hi)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = lo, j = <span class="number">0</span>; i &lt; hi; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mergeSort(q, 0, n);</span></span><br></pre></td></tr></table></figure>
<h4 id="逆序对的数量"><a href="#逆序对的数量" class="headerlink" title="逆序对的数量"></a>逆序对的数量</h4><blockquote>
<p>two element a[i] and a[j] form an inversion if a[i]&gt;a[j] and i&lt;j</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; q, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> <span class="comment">// [lo, hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hi - lo &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mi = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = merge_sort(q, lo, mi) + merge_sort(q, mi, hi);</span><br><span class="line">    merge(q, lo, mi, hi, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; q, <span class="keyword">int</span> lo, <span class="keyword">int</span> mi, <span class="keyword">int</span> hi, <span class="keyword">int</span> &amp; res)</span></span>&#123; <span class="comment">// [lo, mi) [mi, hi)</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = lo, j = mi;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(hi - lo, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; mi &amp;&amp; j &lt; hi)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res += (mi - i + <span class="number">1</span>); <span class="comment">// 逆序对</span></span><br><span class="line">            tmp[k ++ ] = q[j ++ ];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = lo, j = <span class="number">0</span>; i &lt; hi; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; q, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = q[lo];</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = lo; <span class="comment">// [0,i) [i,j) </span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[j] &lt;= pivot)</span><br><span class="line">            swap(q[i++], q[j++]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j++;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(q[i], q[lo]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------</span></span><br><span class="line"><span class="comment">// 1. 确定分界点x    随机</span></span><br><span class="line"><span class="comment">// 2. 调整区间   &lt;=x  pivot &gt;=x  </span></span><br><span class="line"><span class="comment">// 3. 递归处理左边和右边两段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 勤于拓展，懒于交换  [lo, hi]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; q, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    swap (q[lo], q[lo + rand() % (hi - lo + <span class="number">1</span>)])</span><br><span class="line">    <span class="keyword">int</span> pivot = q[lo];</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( (lo &lt; hi) <span class="keyword">and</span> (pivot &lt;= q[hi])) hi--;</span><br><span class="line">        q[lo] = q[hi]; <span class="comment">// if(lo &lt; hi) q[lo++] = q[hi]; </span></span><br><span class="line">        <span class="keyword">while</span>( (lo &lt; hi) <span class="keyword">and</span> (q[lo] &lt;= pivot)) lo++;</span><br><span class="line">        q[hi] = q[lo]; <span class="comment">// if( lo &lt; hi) q[hi--] = q[lo];</span></span><br><span class="line">    &#125;</span><br><span class="line">    q[lo] = pivot;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有(几乎所有)元素均重复，上述版本快排时间复杂度退化</span></span><br><span class="line"><span class="comment">// 懒于拓展， 勤于交换 [lo, hi]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; q, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    swap (q[lo], q[lo + rand() % (hi - lo + <span class="number">1</span>)]);</span><br><span class="line">    <span class="keyword">int</span> pivot = q[lo];</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( (lo &lt; hi) <span class="keyword">and</span> (pivot &lt; q[hi])) hi--;</span><br><span class="line">        <span class="keyword">if</span>(lo &lt; hi) q[lo++] = q[hi]; <span class="comment">// 保证挑出循环时 lo==hi</span></span><br><span class="line">        <span class="keyword">while</span>( (lo &lt; hi) <span class="keyword">and</span> (q[lo] &lt; pivot)) lo++;</span><br><span class="line">        <span class="keyword">if</span>( lo &lt; hi) q[hi--] = q[lo];</span><br><span class="line">    &#125;</span><br><span class="line">    q[lo] = pivot;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[lo, hi)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; q, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( hi - lo &lt; <span class="number">2</span> ) <span class="keyword">return</span>; <span class="comment">// 单元素区间自然有序</span></span><br><span class="line">    <span class="keyword">int</span> mi = partition(lo, hi - <span class="number">1</span>); <span class="comment">// 在[lo, hi-1]内构造轴点</span></span><br><span class="line">    quickSort(lo, mi);</span><br><span class="line">    quickSort(mi+<span class="number">1</span>, hi);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// quickSort(q, 0, n-1); // 调用快排接口</span></span><br><span class="line"><span class="comment">// 快排稳定的方法 对 pair &#123;qi,i&#125;排序</span></span><br></pre></td></tr></table></figure>
<h4 id="Patrition"><a href="#Patrition" class="headerlink" title="Patrition"></a>Patrition</h4><h5 id="位序为k的元素"><a href="#位序为k的元素" class="headerlink" title="位序为k的元素"></a>位序为k的元素</h5><ul>
<li>快排，归并排序 $O(nlogn)$</li>
<li>冒泡排序，选择排序 $O(kn)$</li>
<li>小顶堆  $O(n+klogn)$  // n个元素建小顶堆，pop k次</li>
<li>大顶堆  $O(k+2(n-k)logk)$  // 任取k个元素建大顶堆，然后将剩余的n-k个元素依次插入，并随即删除堆顶，使得堆的规模维持为k.</li>
<li>将全体元素分为两组，分别构建规模为n-k的小顶堆G和规模为k的大顶堆H，接下来反复比较它们的堆顶g和h,只要g&lt;h，则将二者交换并重新调整两个堆，如此则g将持续增大，h将持续减小，当g&lt;=h, 则h即为所求元素，$O(n-k)+O(k)+min(k,n-k)<em>2</em>(O(logk)+O(log(n-k))$</li>
<li>基于快速划分的选取</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSelect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; q, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> lo = <span class="number">0</span>, hi = q.size() <span class="number">-1</span>; lo &lt; hi; )&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi;</span><br><span class="line">        swap (q[i], q[i + rand() % (j - i + <span class="number">1</span>)])</span><br><span class="line">        <span class="keyword">int</span> pivot = q[i];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>( (i &lt; j) <span class="keyword">and</span> (pivot &lt;= q[j])) j--;</span><br><span class="line">            q[i] = q[j];</span><br><span class="line">            <span class="keyword">while</span>( (i&lt;j) <span class="keyword">and</span> (q[i] &lt;= pivot)) i++;</span><br><span class="line">            q[j] = q[i];</span><br><span class="line">        &#125;</span><br><span class="line">        q[i] = pivot;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= i) hi = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= k) lo = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// q[k];</span></span><br></pre></td></tr></table></figure>
<h5 id="sort-colors"><a href="#sort-colors" class="headerlink" title="sort colors"></a>sort colors</h5><p><a href="https://leetcode.com/problems/sort-colors/" target="_blank" rel="noopener">https://leetcode.com/problems/sort-colors/</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;<span class="comment">// [0,i) [i,j) [j,k]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;nums.size();k++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=nums[k];</span><br><span class="line">        nums[k]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(v&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            nums[j]=<span class="number">1</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v==<span class="number">0</span>)&#123;</span><br><span class="line">            nums[i]=<span class="number">0</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Wiggle-Sort-II"><a href="#Wiggle-Sort-II" class="headerlink" title="Wiggle Sort II"></a>Wiggle Sort II</h5><p>Given an unsorted array <code>nums</code>, reorder it such that <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>.</p>
<p><strong>Note:</strong><br>You may assume all input has valid answer.</p>
<p><strong>Follow Up:</strong><br>Can you do it in O(n) time and/or in-place with O(1) extra space?</p>
<p><a href="https://leetcode.com/problems/wiggle-sort-ii/discuss/77678/3-lines-Python-with-Explanation-Proof" target="_blank" rel="noopener">https://leetcode.com/problems/wiggle-sort-ii/discuss/77678/3-lines-Python-with-Explanation-Proof</a></p>
<p><a href="https://leetcode.com/problems/wiggle-sort-ii/discuss/77677/O(n)%2BO(1)-after-median-Virtual-Indexing" target="_blank" rel="noopener">https://leetcode.com/problems/wiggle-sort-ii/discuss/77677/O(n)%2BO(1)-after-median-Virtual-Indexing</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Find a median.</span></span><br><span class="line">    <span class="keyword">auto</span> midptr = nums.begin() + n / <span class="number">2</span>;</span><br><span class="line">    nth_element(nums.begin(), midptr, nums.end());</span><br><span class="line">    <span class="keyword">int</span> mid = *midptr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 偶数位局部小 偶数位填数组中较小的一半 </span></span><br><span class="line">    <span class="comment">// 边界情况 中位数挨在一起 -&gt; 尽量使得中位数离得远</span></span><br><span class="line">    <span class="comment">//  偶数位： 中    小</span></span><br><span class="line">    <span class="comment">//  奇数位：    大     中</span></span><br><span class="line">    <span class="comment">//大 中 小 按  13579....02468....排列</span></span><br><span class="line">    <span class="comment">// Index-rewiring.</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> A(i) nums[(1+2*(i)) % (n|1)]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3-way-partition-to-wiggly in O(n) time with O(1) space.</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = n - <span class="number">1</span>; <span class="comment">// [0,i) [i,j) (k,n-1]</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A(j) &gt; mid)</span><br><span class="line">            swap(A(i++), A(j++));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A(j) &lt; mid)</span><br><span class="line">            swap(A(j), A(k--));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Accessing <code>A(0)</code> actually accesses <code>nums[1]</code>. </p>
<p>Accessing <code>A(1)</code> actually accesses <code>nums[3]</code>.</p>
<p> Accessing <code>A(2)</code> actually accesses <code>nums[5]</code>.</p>
<p> Accessing <code>A(3)</code> actually accesses <code>nums[7]</code>. </p>
<p>Accessing <code>A(4)</code> actually accesses <code>nums[9]</code>. </p>
<p>Accessing <code>A(5)</code> actually accesses <code>nums[0]</code>. </p>
<p>Accessing <code>A(6)</code> actually accesses <code>nums[2]</code>. </p>
<p>Accessing <code>A(7)</code> actually accesses <code>nums[4]</code>. </p>
<p>Accessing <code>A(8)</code> actually accesses <code>nums[6]</code>. </p>
<p>Accessing <code>A(9)</code> actually accesses <code>nums[8]</code>.</p>
</blockquote>
<h2 id="Majority-Element-众数"><a href="#Majority-Element-众数" class="headerlink" title="Majority Element 众数"></a>Majority Element 众数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash  时间复杂度O(n)  空间复杂度O(n) </span></span><br><span class="line"><span class="comment">// Count the number of appearances for each distinct number in nums, once we see a number appear more than n / 2 times, it is the majority element.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; counter;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++counter[num] &gt; nums.size() / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序  时间复杂度：期望O(nlogn)  空间复杂度O(1)</span></span><br><span class="line"><span class="comment">// 中位数   时间复杂度：期望O(n)  空间复杂度O(1)</span></span><br><span class="line"><span class="comment">// Since the majority element appears more than n / 2 times, the n / 2-th element in the sorted nums must be the majority element. In this case, a partial sort by nth_element is enough.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    nth_element(nums.begin(), nums.begin() + nums.size() / <span class="number">2</span>, nums.end());</span><br><span class="line">    <span class="keyword">return</span> nums[nums.size() / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Randomization  时间复杂度：期望为O(n) , 空间复杂度为O(1)</span></span><br><span class="line"><span class="comment">// Pick an element randomly and check whether it is the majority one.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size(), candidate, counter;</span><br><span class="line">    srand(<span class="keyword">unsigned</span>(time(<span class="literal">NULL</span>)));</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        candidate = nums[rand() % n], counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == candidate) &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Divide and Conquer 时间复杂度O(nlogn) 空间复杂度O(logn) (系统栈)</span></span><br><span class="line"><span class="comment">//Recursively find the majority in the two halves of nums and combine the results. The base case is that the majority element of a single-element array is just that element.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> majority(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majority</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>, lm = majority(nums, l, m), rm = majority(nums, m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">if</span> (lm == rm) &#123;</span><br><span class="line">        <span class="keyword">return</span> lm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count(nums.begin() + l, nums.begin() + r + <span class="number">1</span>, lm) &gt; count(nums.begin() + l, nums.begin() + r + <span class="number">1</span>, rm) ? lm : rm;</span><br><span class="line">    <span class="comment">// std::count() returns number of occurrences of an element in a given range. Returns the number of elements in the range [first,last) that compare equal to val.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Moore Voting Algorithm  时间复杂度为O(n) 空间复杂度为O(1)</span></span><br><span class="line"><span class="comment">// 每次都找出一对不同的元素，从数组中删掉，直到数组为空或只有一种元素。 不难证明，如果存在元素e出现频率超过半数，那么数组中最后剩下的就只有e</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>, majority;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!counter) &#123;</span><br><span class="line">            majority = num;</span><br><span class="line">        &#125;</span><br><span class="line">        counter += num == majority ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> majority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bit Manipulation 时间复杂度为O(n) 空间复杂度为O(1)</span></span><br><span class="line"><span class="comment">// The bits in the majority are just the majority bits of all numbers.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> majority = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>, mask = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++, mask &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> bits = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &amp; mask) &#123;</span><br><span class="line">                bits++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bits &gt; nums.size() / <span class="number">2</span>) &#123;</span><br><span class="line">            majority |= mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> majority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.com/problems/majority-element/discuss/51612/6-Suggested-Solutions-in-C%2B%2B-with-Explanations" target="_blank" rel="noopener">https://leetcode.com/problems/majority-element/discuss/51612/6-Suggested-Solutions-in-C%2B%2B-with-Explanations</a></p>
<h2 id="shuffle算法"><a href="#shuffle算法" class="headerlink" title="shuffle算法"></a>shuffle算法</h2><h3 id="Brute-force-不断取出抽样"><a href="#Brute-force-不断取出抽样" class="headerlink" title="Brute force(不断取出抽样)"></a>Brute force(不断取出抽样)</h3><blockquote>
<p>The brute force algorithm essentially puts each number in the aforementioned “hat”, and draws them at random (without replacement) until there are none left. Mechanically, this is performed by copying the contents of <code>array</code> into a second auxiliary array named <code>aux</code> before overwriting each element of <code>array</code> with a randomly selected one from <code>aux</code>. After selecting each random element, it is removed from <code>aux</code> to prevent duplicate draws. </p>
<p>证明： the probability of a particular element ee being chosen on the kth iteration为</p>
<p>$\frac{n-1}{n}<em>\frac{n-2}{n-1}…..</em>\frac{1}{n-k}=\frac{1}{n}$</p>
</blockquote>
<h3 id="Fisher-Yates-Algorithm-洗牌算法"><a href="#Fisher-Yates-Algorithm-洗牌算法" class="headerlink" title="Fisher-Yates Algorithm(洗牌算法)"></a>Fisher-Yates Algorithm(洗牌算法)</h3><p>//每次交换当前元素和（包含当前之后的所有元素中的任意一个）</p>
<p><a href="https://www.cnblogs.com/zichi/p/Fisher-Yates-shuffle.html" target="_blank" rel="noopener">https://www.cnblogs.com/zichi/p/Fisher-Yates-shuffle.html</a></p>
<blockquote>
<p><strong>随机性的数学归纳法证明</strong></p>
<p>对 n 个数进行随机：</p>
<ol>
<li>首先我们考虑 n = 2 的情况，根据算法，显然有 1/2 的概率两个数交换，有 1/2 的概率两个数不交换，因此对 n = 2 的情况，元素出现在每个位置的概率都是 1/2，满足随机性要求。</li>
<li>假设有 i 个数， i &gt;= 2 时，算法随机性符合要求，即每个数出现在 i 个位置上每个位置的概率都是 1/i。</li>
<li>对于 i + 1 个数，按照我们的算法，在第一次循环时，每个数都有 1/(i+1) 的概率被交换到最末尾，所以每个元素出现在最末一位的概率都是 1/(i+1) 。而每个数也都有 i/(i+1) 的概率不被交换到最末尾，如果不被交换，从第二次循环开始还原成 i 个数随机，根据 2. 的假设，它们出现在 i 个位置的概率是 1/i。因此每个数出现在前 i 位任意一位的概率是 (i/(i+1)) * (1/i) = 1/(i+1)，也是 1/(i+1)。</li>
<li>综合 1. 2. 3. 得出，对于任意 n &gt;= 2，经过这个算法，每个元素出现在 n 个位置任意一个位置的概率都是 1/n。</li>
</ol>
</blockquote>
<h2 id="Ksum问题"><a href="#Ksum问题" class="headerlink" title="Ksum问题"></a>Ksum问题</h2><p>2sum   3sum  4sum</p>
<h3 id="2sum"><a href="#2sum" class="headerlink" title="2sum"></a>2sum</h3><p><strong>array中的值只能用一次 从中选出两个数  |   仅要求返回一个答案,没有遗漏的搜索即可，组合内部允许值的重复性</strong></p>
<ul>
<li>无序数组</li>
</ul>
<p>​      $O(n^2 )$ runtime, $O(1)$ space – Brute force</p>
<p>​      $O(n)$ runtime, $O(n)$ space – Hash table</p>
<ul>
<li><p>有序数组</p>
<p>O(n log n) runtime, O(1) space – Binary search</p>
<p>O(n) runtime, O(1) space – Two pointers</p>
</li>
</ul>
<h3 id="3-sum"><a href="#3-sum" class="headerlink" title="3 sum"></a>3 sum</h3><p>语义不同：</p>
<ol>
<li><blockquote>
<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.(仅要求返回一个答案)</p>
<p>————&gt;排序， 退化为2sum问题解决  $O(N^2)$</p>
<p>该语义下的ksum问题时间复杂度为 $O(N^{k-1})$ (k&gt;=3)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       sort(nums.begin(),nums.end());</span><br><span class="line">       <span class="keyword">int</span> result = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-2</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">int</span> k = nums.size()<span class="number">-1</span>;</span><br><span class="line">           <span class="keyword">while</span>(j&lt;k)&#123;</span><br><span class="line">               <span class="keyword">int</span> temp = nums[i] + nums[j] + nums[k];</span><br><span class="line">               <span class="keyword">if</span>(<span class="built_in">abs</span>(temp-target)&lt;<span class="built_in">abs</span>(result-target)) result = temp;</span><br><span class="line">               <span class="keyword">if</span>(temp &lt; target) j++;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(temp &gt; target) k--;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">return</span> target;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><blockquote>
<p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <code>nums</code> such that <em>a</em> + <em>b</em>+ <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.（找出所有不同的组合）</p>
</blockquote>
<p><strong>array中每个元素只能用一次 从中选出3个数| 不重不漏，返回值的组合种数（按递增排序相同的序列算一种 i&lt;=j&lt;=k）</strong></p>
</li>
</ol>
<blockquote>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate triplets.</p>
</blockquote>
<p>方法一：</p>
<p>哈希表不适合k很大的情况，很难判断array中是否存在 (i j k) 这样的组合</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">       <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; c;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> a : nums) c[a]++;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">auto</span> it : c)</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">auto</span> it2 : c) &#123;</span><br><span class="line">               <span class="keyword">int</span> i = it.first, j = it2.first, k = <span class="number">0</span> - i - j;</span><br><span class="line">               <span class="keyword">if</span> (!c.count(k)) <span class="keyword">continue</span>;</span><br><span class="line">               <span class="keyword">if</span> ((i == j &amp;&amp; j == k &amp;&amp; c[i]&gt;=<span class="number">3</span>) <span class="keyword">or</span> (i == j &amp;&amp; j != k &amp;&amp; c[i]&gt;=<span class="number">2</span>) <span class="keyword">or</span> (i &lt; j &amp;&amp; j &lt; k))&#123;</span><br><span class="line">                   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">                   tmp.push_back(i);</span><br><span class="line">                   tmp.push_back(j);</span><br><span class="line">                   tmp.push_back(k);</span><br><span class="line">                   result.push_back(tmp);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>方法2：</p>
<p>The idea is to sort an input array and then run through all indices of a possible first element of a triplet. For each possible first element we make a standard bi-directional 2Sum sweep of the remaining part of the array. Also we want to skip equal elements to avoid duplicates in the answer without making a set or smth like that.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">    <span class="comment">//三元组的顺序单调递增</span></span><br><span class="line">    Arrays.sort(num);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;(); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length-<span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//保证第一个数字（最小的数字）各异</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || (i &gt; <span class="number">0</span> &amp;&amp; num[i] != num[i-<span class="number">1</span>])) &#123;</span><br><span class="line">            <span class="keyword">int</span> lo = i+<span class="number">1</span>, hi = num.length-<span class="number">1</span>, sum = <span class="number">0</span> - num[i];</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num[lo] + num[hi] == sum) &#123;</span><br><span class="line">                    res.add(Arrays.asList(num[i], num[lo], num[hi]));</span><br><span class="line">                    <span class="comment">//保证后两个数字（最大和次大的数字）的组合各异</span></span><br><span class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; num[lo] == num[lo+<span class="number">1</span>]) lo++;</span><br><span class="line">                    <span class="keyword">while</span> (lo &lt; hi &amp;&amp; num[hi] == num[hi-<span class="number">1</span>]) hi--;</span><br><span class="line">                    lo++; hi--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num[lo] + num[hi] &lt; sum) lo++;</span><br><span class="line">                <span class="keyword">else</span> hi--;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><blockquote>
<p>3Sum With Multiplicity:Given an integer array A, and an integer target, return the number of tuples i, j, k  such that i &lt; j &lt; k and A[i] + A[j] + A[k] == target.（找出所有不同的排列）</p>
</blockquote>
</li>
</ol>
<blockquote>
<p><strong>As the answer can be very large, return it modulo 10^9 + 7</strong>.</p>
</blockquote>
<p><strong>array中每个元素只能用一次 从中选出3个数| 不重不漏，返回值的排列种数（k较小时，可以先组合再排列）</strong></p>
<p>Count the occurrence of each number.<br>using hashmap or array up to you.</p>
<p>Loop <code>i</code> on all numbers,<br>loop <code>j</code> on all numbers,<br>check if <code>k = target - i - j</code> is valid.</p>
<p>Add the number of this combination to result.<br>3 cases covers all possible combination(确定顺序 防止重复):</p>
<ol>
<li><code>i == j == k</code></li>
<li><code>i == j != k</code></li>
<li><code>i &lt; j &amp;&amp; j &lt; k</code></li>
</ol>
<p><strong>Time Complexity</strong>:<br><code>3 &lt;= A.length &lt;= 3000</code>, so N = 3000<br>But <code>0 &lt;= A[i] &lt;= 100</code><br>So my solution is <code>O(101^2)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threeSumMulti</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">long</span>&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a : A) c[a]++;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : c)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it2 : c) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = it.first, j = it2.first, k = target - i - j;</span><br><span class="line">            <span class="keyword">if</span> (!c.count(k)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == j &amp;&amp; j == k)</span><br><span class="line">                res += c[i] * (c[i] - <span class="number">1</span>) * (c[i] - <span class="number">2</span>) / <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == j &amp;&amp; j != k)</span><br><span class="line">                res += c[i] * (c[i] - <span class="number">1</span>) / <span class="number">2</span> * c[k];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; j &amp;&amp; j &lt; k)</span><br><span class="line">                res += c[i] * c[j] * c[k];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res % <span class="keyword">int</span>(<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ksum问题-降解为2sum问题"><a href="#ksum问题-降解为2sum问题" class="headerlink" title="ksum问题(降解为2sum问题)"></a>ksum问题(降解为2sum问题)</h3><p>4sum</p>
<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.</p>
<p><strong>array中每个元素只能用一次 从中选出k个数| 不重不漏，返回所有组合</strong></p>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate quadruplets.</p>
<p><a href="https://leetcode.com/problems/4sum/discuss/8545/Python-140ms-beats-100-and-works-for-N-sum-(Ngreater2)" target="_blank" rel="noopener">https://leetcode.com/problems/4sum/discuss/8545/Python-140ms-beats-100-and-works-for-N-sum-(Ngreater2)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    nums.sort()</span><br><span class="line">    results = []</span><br><span class="line">    self.findNsum(nums, target, <span class="number">4</span>, [], results)</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findNsum</span><span class="params">(self, nums, target, N, result, results)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt; N <span class="keyword">or</span> N &lt; <span class="number">2</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># solve 2-sum</span></span><br><span class="line">    <span class="keyword">if</span> N == <span class="number">2</span>:</span><br><span class="line">        l,r = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span> nums[l] + nums[r] == target:</span><br><span class="line">                results.append(result + [nums[l], nums[r]])</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l - <span class="number">1</span>]:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> r &gt; l <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[l] + nums[r] &lt; target:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(nums)-N+<span class="number">1</span>):   <span class="comment"># careful about range</span></span><br><span class="line">            <span class="keyword">if</span> target &lt; nums[i]*N <span class="keyword">or</span> target &gt; nums[<span class="number">-1</span>]*N:  <span class="comment"># take advantages of sorted list</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i<span class="number">-1</span>] != nums[i]:  <span class="comment"># recursively reduce N</span></span><br><span class="line">                self.findNsum(nums[i+<span class="number">1</span>:], target-nums[i], N<span class="number">-1</span>, result+[nums[i]], results)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(n^{k-1})$</p>
<h3 id="Combination-Sum-II"><a href="#Combination-Sum-II" class="headerlink" title="Combination Sum II"></a>Combination Sum II</h3><p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p>
<p>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including <code>target</code>) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p><strong>array中每个元素只能用一次 从中选出任意个数 | 不重不漏，返回所有组合</strong></p>
<h3 id="Combination-Sum-III"><a href="#Combination-Sum-III" class="headerlink" title="Combination Sum III"></a>Combination Sum III</h3><p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p><strong>array中元素的值互异，每个元素只能用一次 从中选出k个数|  返回所有组合</strong></p>
<h3 id="Combination-Sum"><a href="#Combination-Sum" class="headerlink" title="Combination Sum"></a>Combination Sum</h3><p>Given a <strong>set</strong> of candidate numbers (<code>candidates</code>) <strong>(without duplicates)</strong> and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p>
<p>The <strong>same</strong> repeated number may be chosen from <code>candidates</code> unlimited number of times.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including <code>target</code>) will be positive integers.(防止正数+负数=0,产生无数组合)</li>
<li><p>The solution set must not contain duplicate combinations.</p>
<p><strong>array中元素的值互异，每个元素可无限次取  从中选出任意个数|  返回所有组合</strong></p>
</li>
</ul>
<p>-&gt; 回溯 </p>
<p><strong>array中元素的值互异，每个元素可无限次取  从中选出任意个数|  返回组合种数</strong></p>
<p><strong>array中元素的值互异，每个元素可无限次取 从中选出任意个数|  返回排列的种数</strong></p>
<p>-&gt; 完全背包</p>
<p>总结：</p>
<p>组合：先排序，保证取值的顺序递增，</p>
<p>array中每个元素只能用一次： index递增</p>
<p>元素不互异：回溯过程中每取一个数字，保证该位互异</p>
<h3 id="Path-sum3"><a href="#Path-sum3" class="headerlink" title="Path sum3"></a>Path sum3</h3><p>You are given a binary tree in which each node contains an integer value.</p>
<p>Find the number of paths that sum to a given value.</p>
<p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p>
<p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p>
<p>//固定起始点，将问题分解   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> pathFromSource(root,sum)+pathSum(root-&gt;left,sum)+pathSum(root-&gt;right,sum);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//固定起始点，将问题分解</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathFromSource</span><span class="params">(TreeNode* root,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> path;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (root-&gt;val==sum) +  pathFromSource(root-&gt;left,sum-root-&gt;val)</span><br><span class="line">            + pathFromSource(root-&gt;right,sum-root-&gt;val);</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>//用哈希表保存路径的所有前缀和，以及保存当前sum(从根节点到当前节点的路径sum)，若哈希表中存在前缀和==当前sum-target,说明存在以当前节点结束节点的路径和为target   $O(n)$</p>
<p>So the idea is similar as Two sum, using HashMap to store ( key : the prefix sum, value : how many ways get to this prefix sum) , and whenever reach a node, we check if prefix sum - target exists in hashmap or not, if it does, we added up the ways of prefix sum - target into res. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; sum, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; counter, <span class="keyword">int</span> currentSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        currentSum += root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, target = currentSum - sum;</span><br><span class="line">        <span class="keyword">if</span> (counter.count(target)) res  +=counter[target];</span><br><span class="line">        counter[currentSum]++;</span><br><span class="line"></span><br><span class="line">        res +=countPathSum(root-&gt;left, sum, counter, currentSum);</span><br><span class="line">        res +=countPathSum(root-&gt;right, sum, counter, currentSum);</span><br><span class="line">        counter[currentSum]--;  <span class="comment">//记得要回溯</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; counter;</span><br><span class="line">        counter[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> countPathSum(root, sum, counter, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><blockquote>
<p>$A+B;    A-B;   A*\alpha;   A/\alpha;        len(A) = 10^6;    \alpha&lt;= 10000$</p>
</blockquote>
<p>将大整数的每一位存在数组里, 第0位存个位</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高精度存储</span></span><br><span class="line"><span class="built_in">string</span> a, b;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) A.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = b.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) B.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定两个正整数，计算它们的和</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; add(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size() <span class="keyword">or</span> i &lt; B.size(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.size()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------------------------------</span></span><br><span class="line"><span class="comment">// 减法</span></span><br><span class="line"><span class="comment">// 判断是否有A&gt;=B</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size() != B.size()) <span class="keyword">return</span> A.size() &gt; B.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// A==B</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if Ai-Bi-t &gt;= 0 =&gt; Ai-Bi-t; t=0;</span></span><br><span class="line"><span class="comment">// else Ai-Bi-t+10; t=1 // 借位</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sub(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.size(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t -= B[i];</span><br><span class="line">        C.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back(); <span class="comment">// 去掉高位无效的0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给定两个正整数，计算它们的差</span></span><br><span class="line"><span class="keyword">if</span> (cmp(A, B)) C = sub(A, B);</span><br><span class="line"><span class="keyword">else</span> C = sub(B, A), <span class="built_in">cout</span> &lt;&lt; <span class="string">'-'</span>;</span><br><span class="line"><span class="comment">//----------------------------------------</span></span><br><span class="line"><span class="comment">// 乘法 把b看做一个整体</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mul(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.size()) t += A[i] * b;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------</span></span><br><span class="line"><span class="comment">// 除法 商是C，余数是r</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; div(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.push_back(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(C.begin(), C.end());</span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h2><h3 id="子区间的和-子矩阵的和"><a href="#子区间的和-子矩阵的和" class="headerlink" title="子区间的和/ 子矩阵的和"></a>子区间的和/ 子矩阵的和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子区间的和</span></span><br><span class="line"><span class="keyword">for</span> i : <span class="number">1</span>~n</span><br><span class="line">    s[i] = s[i<span class="number">-1</span>] + a[i]</span><br><span class="line"><span class="comment">// 给定左右端点l,r 子区间的和</span></span><br><span class="line">s[r] - s[l<span class="number">-1</span>]</span><br><span class="line"><span class="comment">// -----------------------</span></span><br><span class="line"><span class="comment">// 子矩阵的和</span></span><br><span class="line"><span class="keyword">for</span> i : <span class="number">1</span>~n</span><br><span class="line">    <span class="keyword">for</span> j : <span class="number">1</span>~m</span><br><span class="line">        S[i][j] = S[i<span class="number">-1</span>][j] + S[i][j<span class="number">-1</span>] - S[i<span class="number">-1</span>][j<span class="number">-1</span>] + a[i][j];</span><br><span class="line"><span class="comment">// 左上角(x1,y1) 右下角(x2,y2)的子矩阵和  闭区间</span></span><br><span class="line">S[x2][y2] - S[x2][y1<span class="number">-1</span>] - S[x1<span class="number">-1</span>][y2] + S[x1<span class="number">-1</span>][y1<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="差分-差分矩阵"><a href="#差分-差分矩阵" class="headerlink" title="差分/ 差分矩阵"></a>差分/ 差分矩阵</h3><p>前缀和与差分是逆运算**</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a1 a2 a3 ... an  前缀和</span></span><br><span class="line"><span class="comment">// b1 b2 b3 ... bn  差分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a[l~r] += c                   O(n)</span></span><br><span class="line"><span class="comment">// b[l] += c; b[r+1] -= c;       O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差分</span></span><br><span class="line"><span class="comment">// 输入一个长度为n的整数序列。接下来输入m个操作，每个操作包含三个整数l, r, c，表示将序列中[l, r]之间的每个数加上c。请你输出进行完所有操作后的序列。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="comment">// 无需考虑构造，假定初始化 a[i],b[i]均为0； 只需考虑如何更新</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) insert(i, i, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">        insert(l, r, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) b[i] += b[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">printf</span>(<span class="string">"%d "</span>, b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------</span></span><br><span class="line"><span class="comment">// 差分矩阵</span></span><br><span class="line"><span class="comment">// aij   前缀和</span></span><br><span class="line"><span class="comment">// bij   差分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Two-pointers-双指针"><a href="#Two-pointers-双指针" class="headerlink" title="Two pointers  双指针"></a>Two pointers  双指针</h2><blockquote>
<p>用两个指针维护一段区间</p>
<p>用两个指针维护某种次序（如归并排序）</p>
</blockquote>
<h3 id="Reverse-Words-in-a-String"><a href="#Reverse-Words-in-a-String" class="headerlink" title="Reverse Words in a String"></a>Reverse Words in a String</h3><blockquote>
<p>Q: What constitutes a word?</p>
<p>A: A sequence of non-space characters constitutes a word.</p>
<p>Q: Does tab or newline character count as space characters?</p>
<p>A: Assume the input does not contain any tabs or newline characters.</p>
<p>Q: Could the input string contain leading or trailing spaces?</p>
<p>A: Yes. However, your reversed string should not contain leading or trailing spaces.</p>
<p>Q: How about multiple spaces between two words?</p>
<p>A: Reduce them to a single space in the reversed string.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Given an input string s, reverse the string word by word.</span></span><br><span class="line"><span class="comment">// For example, given s = "the sky is blue", return "blue is sky the".</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuilder reversed = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> j = s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">        	j = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span> || s.charAt(i - <span class="number">1</span>) == <span class="string">' '</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reversed.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            	reversed.append(<span class="string">' '</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            reversed.append(s.substring(i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reversed.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -----------------------------------------------------</span></span><br><span class="line"><span class="comment">// The input string does not contain leading or trailing spaces and the words are always separated by a single space.</span></span><br><span class="line"><span class="comment">// in place</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">	reverse(s, <span class="number">0</span>, s.length); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt;= s.length; j++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (j == s.length || s[j] == <span class="string">' '</span>) &#123; </span><br><span class="line">            reverse(s, i, j); </span><br><span class="line">            i = j + <span class="number">1</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (end - begin) / <span class="number">2</span>; i++) &#123; </span><br><span class="line">        <span class="keyword">char</span> temp = s[begin + i]; </span><br><span class="line">        s[begin + i] = s[end - i - <span class="number">1</span>]; </span><br><span class="line">        s[end - i - <span class="number">1</span>] = temp; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note: j记录当前单词之后紧邻的空格位置</p>
<h3 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a>Longest Substring Without Repeating Characters</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length_of_longest_substring</span><span class="params">(<span class="built_in">string</span> &amp; s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; table;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;s.size(); j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(table[s[j]]&gt;=i)&#123;</span><br><span class="line">            max_len = max(max_len,j-i);</span><br><span class="line">            i = table[s[j]]+<span class="number">1</span>; <span class="comment">// all substrings that start before or at index table[s[j]] would be less than your current maximum</span></span><br><span class="line">        &#125;</span><br><span class="line">        table[s[j]] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(max_len,j-i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><p>保序的离散化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假定有一个无限长的数轴，数轴上每个坐标上的数都是0。现在，我们首先进行 n 次操作，每次操作将某一位置x上的数加c。近下来，进行 m 次询问，每个询问包含两个整数l和r，你需要求出在区间[l, r]之间的所有数的和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序 去重  (所有的坐标：插入的坐标和查询的坐标)</span></span><br><span class="line"><span class="comment">// 二分查找x对应的离散化后的值  &gt;=x的最小的位置</span></span><br></pre></td></tr></table></figure>
<h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><h3 id="蓄水池采样"><a href="#蓄水池采样" class="headerlink" title="蓄水池采样"></a>蓄水池采样</h3><p>1）从 100000 份调查报告中抽取 1000 份进行统计</p>
<p>2） 从 Google 搜索 “Ken Thompson”，从中抽取 100 个结果查看哪些是今年的</p>
<ul>
<li>确定数据的整体规模： 随机打乱数据，取前k个</li>
<li>流数据，不确定数据整体规模，蓄水池采样</li>
</ul>
<p>​      假设需要采样的数量为k, 首先构建一个可容纳k个元素的数组，将序列的前k个元素放入数组中,然后从第k+1个元素开始，假设当前元素为序列中第M+1个元素，以k/(M+1)的概率来决定该元素是否被替换到数组中（数组中的元素被替换的概率是相同的）。 当遍历完所有元素之后，数组中剩下的元素即为所需采取的样本  <strong>数学归纳法可证明</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] sampling(<span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[K];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i++) &#123; <span class="comment">// 前 K 个元素直接放入数组中</span></span><br><span class="line">            result[i] = pool[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = K; i &lt; N; i++) &#123; <span class="comment">// K + 1 个元素开始进行概率采样</span></span><br><span class="line">            <span class="keyword">int</span> r = random.nextInt(i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (r &lt; K) &#123;</span><br><span class="line">                result[r] = pool[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/snowInPluto/p/5996269.html" target="_blank" rel="noopener">https://www.cnblogs.com/snowInPluto/p/5996269.html</a></p>
<h3 id="加权随机采样"><a href="#加权随机采样" class="headerlink" title="加权随机采样"></a>加权随机采样</h3><blockquote>
<p>一个集合里有 <code>n</code> 个元素，每个元素有不同的权重，现在要不放回地随机抽取 <code>m</code> 个元素，每个元素被抽中的概率为元素的权重占总权重的比例。要怎么做呢？</p>
</blockquote>
<p><a href="https://lotabout.me/2018/Weighted-Random-Sampling/" target="_blank" rel="noopener">https://lotabout.me/2018/Weighted-Random-Sampling/</a></p>
<h2 id="In-place"><a href="#In-place" class="headerlink" title="In place"></a>In place</h2><h3 id="First-Missing-Positive"><a href="#First-Missing-Positive" class="headerlink" title="First Missing Positive"></a>First Missing Positive</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 除去负数及零的干扰</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;nums.size(); j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums[i]=nums[j];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[j])&lt;=i &amp;&amp; nums[<span class="built_in">abs</span>(nums[j])<span class="number">-1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums[<span class="built_in">abs</span>(nums[j])<span class="number">-1</span>] *=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j]&gt;<span class="number">0</span>) <span class="keyword">return</span> j+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rotate-array"><a href="#rotate-array" class="headerlink" title="rotate array"></a>rotate array</h3><blockquote>
<p>Given an array, rotate the array to the right by <em>k</em> steps, where <em>k</em> is non-negative.</p>
</blockquote>
<p>leetcode 189</p>
<p>方法一：首先对整个数组逆序，然后分别对前k个数字和后n-k个数字逆序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.size();</span><br><span class="line">    k%=n;</span><br><span class="line">    reverse(nums,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    reverse(nums,<span class="number">0</span>,k<span class="number">-1</span>);</span><br><span class="line">    reverse(nums,k,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j) swap(nums[i++],nums[j--]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：依次处理被占位的数字  Using Cyclic Replacements</p>
<blockquote>
<p>We can directly place every number of the array at its required correct position. But if we do that, we will destroy the original element. Thus, we need to store the number being replaced in a temp variable. Then, we can place the replaced number(temp) at its correct position and so on, n times, where n is the length of array. We have chosen n to be the number of replacements since we have to shift all the elements of the array(which is n). But, there could be a problem with this method, if n%k=0. In this case, while picking up numbers to be placed at the correct position, we will eventually reach the number from which we originally started. Thus, in such a case, when we hit the original number’s index again, we start the same process with the number following it.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n和k互质，最小公倍数为nk,循环替换n次才会reach the number from which we originally started</span></span><br><span class="line"><span class="comment">// n和k不互质，中间会reach the number from which we originally started</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.size();</span><br><span class="line">    k=k%n;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(start=<span class="number">0</span>;count&lt;n;start++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cur_index=start;</span><br><span class="line">        <span class="keyword">int</span> cur_val=nums[start];</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> next_index=(cur_index+k)%n;<span class="comment">//下一个下标</span></span><br><span class="line">            <span class="keyword">int</span> tmp=nums[next_index];</span><br><span class="line">            nums[next_index]=cur_val;<span class="comment">//将上一个元素放到这个位置</span></span><br><span class="line">            <span class="comment">//更新pre,count,cur</span></span><br><span class="line">            cur_val=tmp;</span><br><span class="line">            cur_index=next_index;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">while</span>(start!=cur_index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rotate-image"><a href="#rotate-image" class="headerlink" title="rotate image"></a>rotate image</h3><p>You are given an <em>n</em> x <em>n</em> 2D matrix representing an image. Rotate the image by 90 degrees (clockwise).</p>
<p><strong>Note:</strong>  You have to rotate the image <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p>
<p><a href="https://leetcode.com/problems/rotate-image/" target="_blank" rel="noopener">https://leetcode.com/problems/rotate-image/</a></p>
<ul>
<li>not in place </li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; first row of source ------&gt; last column of destination</span><br><span class="line">&gt; second row of source ------&gt; last but-one column of destination</span><br><span class="line">&gt; so ... on</span><br><span class="line">&gt; last row of source ------&gt; first column of destination</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>in place</li>
</ul>
<blockquote>
<ol>
<li>Clockwise 90<ul>
<li>方法一  Find transpose of matrix. then reverse left to right</li>
<li>方法二 first reverse up to down, then transpose</li>
</ul>
</li>
<li>Anti clockwise 90<ul>
<li>方法一  Find transpose of matrix. then reverse up to down</li>
<li>方法二  first reverse left to right, then transpose</li>
</ul>
</li>
</ol>
<p>clockwise 180</p>
<ul>
<li>方法一  repeat clockwise 90 twice</li>
<li>方法二 first reverse up to down,  then reverse left to right</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * clockwise rotate</span></span><br><span class="line"><span class="comment"> * first reverse up to down, then swap the symmetry </span></span><br><span class="line"><span class="comment"> * 1 2 3     7 8 9     7 4 1</span></span><br><span class="line"><span class="comment"> * 4 5 6  =&gt; 4 5 6  =&gt; 8 5 2</span></span><br><span class="line"><span class="comment"> * 7 8 9     1 2 3     9 6 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">    reverse(matrix.begin(), matrix.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; matrix[i].size(); ++j)</span><br><span class="line">            swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * anticlockwise rotate</span></span><br><span class="line"><span class="comment"> * first reverse left to right, then swap the symmetry</span></span><br><span class="line"><span class="comment"> * 1 2 3     3 2 1     3 6 9</span></span><br><span class="line"><span class="comment"> * 4 5 6  =&gt; 6 5 4  =&gt; 2 5 8</span></span><br><span class="line"><span class="comment"> * 7 8 9     9 8 7     1 4 7</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">anti_rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> vi : matrix) reverse(vi.begin(), vi.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; matrix[i].size(); ++j)</span><br><span class="line">            swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h1><p><strong>二分的本质：性质的边界</strong></p>
<p>邓俊辉  数据结构</p>
<p>处置特殊情况应有语义约定（为了被其他部件调用），如有序向量的查找至少应该便于有序向量自身的维护</p>
<p>( v.insert(1+v.search(e),e) )</p>
<p>Search: 确定不大于e的最后一个元素</p>
<ul>
<li>[lo, hi)  e  尽量减少比较次数  保证base情况(1，2，3)问题能递减下去</li>
</ul>
<p>语义一： 若存在返回index, 若不存在返回-1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(hi-lo&gt;<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (hi+lo)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(e&lt;nums[mid])&#123; <span class="comment">// 判断条件要保证两种情况在数组长度为2，3时都能递减范围</span></span><br><span class="line">        hi = mid;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        lo = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[lo]==e? lo:<span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>语义二：确定不大于e的最后一个元素              lo) &lt;=e       [hi   &gt;e</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case 1 given k, find max(i,a[i]&lt;k)</span></span><br><span class="line"><span class="comment">// case 2 given k, find max(i,a[i]&lt;=k)</span></span><br><span class="line"><span class="comment">// case 3 given k, find min(i,a[i]&gt;k)</span></span><br><span class="line"><span class="comment">// case 4 given k, find min(i,a[i]&gt;=k)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.size();</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = n;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;h)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (h-l)/<span class="number">2</span> + l;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;k)&#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            h = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.size();</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = n;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;h)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (h-l)/<span class="number">2</span> + l;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;=k)&#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            h = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch3</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.size();</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = n;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;h)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (h-l)/<span class="number">2</span> + l;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;=k)&#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            h = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.size();</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = n;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;h)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (h-l)/<span class="number">2</span> + l;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;k)&#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            h = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分数二分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到x的三次方根, 注意，结果保留6位小数。</span></span><br><span class="line"><span class="keyword">double</span> lo = <span class="number">0</span>; hi = x;</span><br><span class="line"><span class="keyword">while</span>(hi - lo &gt; <span class="number">1e-8</span>)&#123;</span><br><span class="line">    <span class="keyword">double</span> mid = (hi+lo)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(mmid * mid * mid &gt;= x)&#123; </span><br><span class="line">        hi = mid;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        lo = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, lo);</span><br></pre></td></tr></table></figure>
<h2 id="二分搜索位置-单调"><a href="#二分搜索位置-单调" class="headerlink" title="二分搜索位置 (单调)"></a>二分搜索位置 (单调)</h2><h2 id="二分答案-（满足-不满足）"><a href="#二分答案-（满足-不满足）" class="headerlink" title="二分答案  （满足|不满足）"></a>二分答案  （满足|不满足）</h2><ul>
<li>二分答案的主要思想<ul>
<li>就是在答案的可能范围（区间）内二分枚举</li>
<li>并检查所穷举的答案是否符合题意。</li>
<li>可以将最优性问题（直接求解相对较难）</li>
<li>转化为可行性问题（答案是否符合题意相对容易）</li>
</ul>
</li>
<li>二分答案的适用范围（条件）<ul>
<li>二分答案当且仅当答案区间上下限确定且可行解满足区间单调性（若x是可行解，则在答案区间内x+1（也可能是x-1）也可行的时候）才可以使用。</li>
<li>一般也是求最优值问题</li>
<li>更多、更明显的标志是： “最大值最小化” 或者 “最小值最大化”</li>
</ul>
</li>
<li>如何检验当前的答案是否符合题目的要求（限制条件）？<ul>
<li>常见的方法：穷举、贪心、搜索、动态规划、图论、数据结构等</li>
</ul>
</li>
</ul>
<h3 id="最大值最小化-最小值最大化"><a href="#最大值最小化-最小值最大化" class="headerlink" title="最大值最小化/最小值最大化"></a>最大值最小化/最小值最大化</h3><p>Leetcode410</p>
<blockquote>
<p>Given an array which consists of non-negative integers and an integer <em>m</em>, you can split the array into <em>m</em> non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these <em>m</em> subarrays.</p>
<p><strong>Note:</strong><br>If <em>n</em> is the length of array, assume the following constraints are satisfied:</p>
<ul>
<li>1 ≤ <em>n</em> ≤ 1000</li>
<li>1 ≤ <em>m</em> ≤ min(50, <em>n</em>)</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minimize the largest sum among these m subarrays. </span></span><br><span class="line"><span class="comment">// 区间和的最大值 尽量小   </span></span><br><span class="line"><span class="comment">// 存在任何一种划分使得所有的区间和&lt;=k </span></span><br><span class="line"><span class="comment">// 区间和的范围 1, 2, 3, ..... ans-1, ans, ans+1, ..., sum </span></span><br><span class="line"><span class="comment">//            0  0  0          0     1     1           1 </span></span><br><span class="line"><span class="comment">// 找到&gt;0的最小值</span></span><br><span class="line"><span class="comment">// check 是否存在一种划分使得所有区间和&lt;=k</span></span><br><span class="line"><span class="comment">// 贪心，从左到右，每个区间和尽量接近k,且&lt;=k</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> m, <span class="keyword">long</span> <span class="keyword">long</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> curSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        curSum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(curSum &gt; k)&#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            curSum = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt ++;</span><br><span class="line">    <span class="keyword">return</span> cnt &lt;= m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i ++)&#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 二分答案 &lt;=0 &gt;0</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> lo = <span class="number">1</span>, hi = sum+<span class="number">1</span>; <span class="comment">// [lo,hi)</span></span><br><span class="line">    <span class="keyword">while</span>(lo&lt;hi)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mid = (hi + lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(!check(nums, m, mid))&#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(lo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Largest-Sum-of-Averages"><a href="#Largest-Sum-of-Averages" class="headerlink" title="Largest Sum of Averages"></a>Largest Sum of Averages</h3><p>Leetcode 813</p>
<blockquote>
<p>We partition a row of numbers <code>A</code> into at most <code>K</code> adjacent (non-empty) groups, then our score is the sum of the average of each group. What is the largest score we can achieve?</p>
<p>Note that our partition must use every number in A, and that scores are not necessarily integers.</p>
<p><strong>Note:</strong></p>
<ul>
<li><code>1 &lt;= A.length &lt;= 100</code>.</li>
<li><code>1 &lt;= A[i] &lt;= 10000</code>.</li>
<li><code>1 &lt;= K &lt;= A.length</code>.</li>
<li>Answers within <code>10^-6</code> of the correct answer will be accepted as correct.</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Median-of-two-sorted-arrays"><a href="#Median-of-two-sorted-arrays" class="headerlink" title="Median of two sorted arrays"></a>Median of two sorted arrays</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力 归并 O(n+m) </span></span><br><span class="line"><span class="comment">// 二分 O(log(n+m))</span></span><br><span class="line"><span class="comment">//  ----------++++++++            x            n-x   </span></span><br><span class="line"><span class="comment">//  --------++++++++++++++        half-x       m-(half-x)</span></span><br><span class="line"><span class="comment">// x: [0，n+1) 个数</span></span><br><span class="line"><span class="comment">// ------------------</span></span><br><span class="line"><span class="comment">// -+++++++++++++++++++</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// ---------------+++++++</span></span><br><span class="line"><span class="comment">// ----++++++++++++++++++++</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// +++++++++++++++++++++</span></span><br><span class="line"><span class="comment">// ---------------------</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// +++++++++++++++++++++</span></span><br><span class="line"><span class="comment">// -----------------------+++</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums1.size();</span><br><span class="line">    <span class="keyword">int</span> m = nums2.size();</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m) <span class="keyword">return</span> findMedianSortedArrays(nums2,nums1); <span class="comment">// 保证 n&lt;=m</span></span><br><span class="line">    <span class="keyword">int</span> half = (n+m+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo&lt;hi)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo+hi)/<span class="number">2</span>; <span class="comment">// len(left part of x)</span></span><br><span class="line">        <span class="keyword">int</span> leftx = mid<span class="number">-1</span>&lt;<span class="number">0</span>? INT_MIN:nums1[mid<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> lefty = half-mid<span class="number">-1</span>&lt;<span class="number">0</span> ? INT_MIN:nums2[half-mid<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> rightx = mid&gt;=n? INT_MAX:nums1[mid];</span><br><span class="line">        <span class="keyword">int</span> righty = half-mid&gt;=m? INT_MAX:nums2[half-mid];</span><br><span class="line">        <span class="comment">//cout&lt;&lt;mid&lt;&lt;" "&lt;&lt;leftx&lt;&lt;" "&lt;&lt;lefty&lt;&lt;" "&lt;&lt;rightx&lt;&lt;" "&lt;&lt;righty&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(max(leftx,lefty)&lt;=min(rightx,righty))&#123;</span><br><span class="line">            <span class="keyword">if</span>((n+m)%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">double</span>(max(leftx,lefty)+min(rightx,righty))/<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> max(leftx,lefty);</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(leftx&lt;righty)&#123;</span><br><span class="line">            lo = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            hi = mid; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="perfect-square"><a href="#perfect-square" class="headerlink" title="perfect square"></a>perfect square</h3><ul>
<li>A square number is 1+3+5+7+…,</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         num -= i;</span><br><span class="line">         i += <span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> num == <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>One thing to note is that we have to use <strong>long</strong> for mid to avoid <strong>mid*mid</strong> from overflow.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如何防止大数溢出</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> lo = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">long</span> hi = <span class="keyword">long</span>(num)+<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(hi-lo&gt;<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">long</span> mid = (lo+hi)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span>(num&lt;mid*mid) hi=mid;</span><br><span class="line">           <span class="keyword">else</span> lo=mid;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> (lo*lo==num)? <span class="literal">true</span>:<span class="literal">false</span>; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>And a third way is to use <strong>Newton Method</strong> to calculate the square root or num, refer to <a href="https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division" target="_blank" rel="noopener">Newton Method</a> for details.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> x = num;</span><br><span class="line">        <span class="keyword">while</span> (x * x &gt; num) &#123;</span><br><span class="line">            x = (x + num / x) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x * x == num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Smallest-good-base"><a href="#Smallest-good-base" class="headerlink" title="Smallest good base"></a>Smallest good base</h3><blockquote>
<p>For an integer n, we call k&gt;=2 a  <strong>good base</strong> of n, if all digits of n base k are 1.</p>
<p>Now given a string representing n, you should return the smallest good base of n in string format.</p>
<p><strong>Note:</strong></p>
<ol>
<li>The range of n is [3, 10^18].</li>
<li>The string representing n is always valid and will not have leading zeros.</li>
</ol>
</blockquote>
<p>按数学公式缩小搜索空间   注意整数存储类型   防止溢出</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6620351.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/6620351.html</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 + k + k^2 +... + k^(m-1) = (k^m -1)/(k-1) = n  </span></span><br><span class="line"><span class="comment">// 当n恒定时，k越小，m越大</span></span><br><span class="line"><span class="comment">// 由于k至少为2，n至少为3，那么肯定至少有两项，则 m&gt;=2。再来看m的上限该如何求？其实也不难，想要m最大，k就要最小，k最小是2，那么m最大只能为 log2(n + 1)</span></span><br><span class="line"><span class="comment">// n = 1 + k + k^2 + k^3 + ... + k^(m-1) &gt; k^(m-1) =&gt; k &lt; n^(1 / (m-1))</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">smallestGoodBase</span><span class="params">(<span class="built_in">string</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> num = stoll(n);</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">log</span>(num+<span class="number">1</span>)/<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m; i&gt;=<span class="number">2</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> left = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> right = <span class="built_in">pow</span>(num, <span class="number">1.0</span> / (i - <span class="number">1</span>))+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123; <span class="comment">//左闭右开</span></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                sum = sum * mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum == num) <span class="keyword">return</span> to_string(mid);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; num)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> to_string(num<span class="number">-1</span>);<span class="comment">// 当 k=n-1 时，一定能变成 11，所以实在找不到更小的情况下就返回 n-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a>Linked List</h1><h2 id="用数组模拟链表"><a href="#用数组模拟链表" class="headerlink" title="用数组模拟链表"></a>用数组模拟链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针+结构体  动态创建链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// new Node() 操作很慢</span></span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="comment">// 用数组模拟单链表：邻接表（存储树和图）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="comment">// dummyhead 表示头结点的下标:0</span></span><br><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针是多少 </span></span><br><span class="line"><span class="comment">// idx 存储当前已经用到了哪个点 </span></span><br><span class="line"><span class="keyword">int</span> dummyHead, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[<span class="number">0</span>]=<span class="number">0</span>; ne[<span class="number">0</span>]=<span class="number">-1</span>; dummyHead=<span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到头结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_head</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add(<span class="number">0</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_head_node</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    remove(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到下标是k的点后面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将下标是k的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"><span class="comment">// 用数组模拟双链表：用来优化某些问题</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"><span class="comment">// 0： dummyHead  1:dummyTail</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[<span class="number">0</span>]=<span class="number">0</span>, e[<span class="number">1</span>]=<span class="number">0</span>;  </span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>; </span><br><span class="line">    r[<span class="number">1</span>] = <span class="number">-1</span>, l[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a, r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x : insert(l[a],x)</span></span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链表总结：<a href="http://data2art.com/LinkedList.html" target="_blank" rel="noopener">http://data2art.com/LinkedList.html</a></p>
<h2 id="Floyd-Cycle-detection-algorithm"><a href="#Floyd-Cycle-detection-algorithm" class="headerlink" title="Floyd Cycle detection algorithm"></a>Floyd Cycle detection algorithm</h2><p><a href="https://cs.stackexchange.com/questions/10360/floyds-cycle-detection-algorithm-determining-the-starting-point-of-cycle" target="_blank" rel="noopener">https://cs.stackexchange.com/questions/10360/floyds-cycle-detection-algorithm-determining-the-starting-point-of-cycle</a></p>
<ul>
<li>Detecting start of a loop in singly linked list</li>
</ul>
<p>Meeting point, $𝑀=𝑥+𝑦+mL$</p>
<p>$2(𝑥+𝑦+mL)=𝑀+n𝐿$</p>
<p>Basically, distance travelled by the fast pointer is $𝑥+𝑦 $plus some multiple of loop length, 𝐿</p>
<p>$𝑥+𝑦=𝑘𝐿                        (k=n-m)$</p>
<p>$y=𝑘𝐿−x$ 必定有解</p>
<p>The above equation proves that  is the same as some multiple of loop length, 𝐿 minus 𝑦 So, if the fast pointer starts at the meeting point, 𝑀 or at 𝑥+𝑦(slow从head开始走，fast从meeting point开始走，速度均为1，因为meeting point和head到start of the loop的距离均为x), then it will end up at the start of the loop.</p>
<h3 id="Find-the-Duplicate-Number"><a href="#Find-the-Duplicate-Number" class="headerlink" title="Find the Duplicate Number"></a>Find the Duplicate Number</h3><p>leetcode 287</p>
<blockquote>
<p>Given an array <em>nums</em> containing <em>n</em> + 1 integers where each integer is between 1 and <em>n</em> (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<p><strong>Note:</strong></p>
<ol>
<li>You <strong>must not</strong> modify the array (assume the array is read only).</li>
<li>You must use only constant, <em>O</em>(1) extra space.</li>
<li>Your runtime complexity should be less than <em>O</em>(<em>n</em>^2).</li>
<li>There is only one duplicate number in the array, but it could be repeated more than once.</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组模拟链表</span></span><br><span class="line"><span class="comment">// Because each number in nums is between 1 and n, it will necessarily point to an index that exists. Therefore, the list can be traversed infinitely, which implies that there is a cycle. Additionally, because 00 cannot appear as a value in nums, nums[0] cannot be part of the cycle. Therefore, traversing the array in this manner from nums[0] is equivalent to traversing a cyclic linked list</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> fast=nums[nums[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">        slow=nums[slow];</span><br><span class="line">        fast=nums[nums[fast]];</span><br><span class="line">    &#125;</span><br><span class="line">    slow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">        slow=nums[slow];</span><br><span class="line">        fast=nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reverse-Linked-List-In-Place"><a href="#Reverse-Linked-List-In-Place" class="headerlink" title="Reverse Linked List  (In Place)"></a>Reverse Linked List  (In Place)</h2><p><a href="https://leetcode.com/problems/reverse-linked-list/discuss/58130/C%2B%2B-Iterative-and-Recursive" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/discuss/58130/C%2B%2B-Iterative-and-Recursive</a></p>
<p>先创建p节点,后创建p-&gt;next所指向的节点</p>
<p>先创建p-&gt;next所指向的节点，后创建p节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iterative</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode* next = head -&gt; next;</span><br><span class="line">            head -&gt; next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//recursice</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !(head -&gt; next)) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* node = reverseList(head -&gt; next);</span><br><span class="line">        head -&gt; next -&gt; next = head;</span><br><span class="line">        head -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="栈-和-队列"><a href="#栈-和-队列" class="headerlink" title="栈 和 队列"></a>栈 和 队列</h1><h2 id="用数组模拟栈和队列"><a href="#用数组模拟栈和队列" class="headerlink" title="用数组模拟栈和队列"></a>用数组模拟栈和队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用STL容器实现</span></span><br><span class="line">----------------------------</span><br><span class="line"><span class="comment">// 用数组模拟栈</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[N], tt;</span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"><span class="comment">//弹出</span></span><br><span class="line">tt--;</span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span>(tt&gt;<span class="number">0</span>)  <span class="keyword">not</span> empty</span><br><span class="line"><span class="keyword">else</span> empty</span><br><span class="line"><span class="comment">//栈顶</span></span><br><span class="line">stk[tt];</span><br><span class="line">--------------------------------</span><br><span class="line"><span class="comment">// 用数组模拟队列</span></span><br><span class="line"><span class="comment">// 在队尾插入元素，在队头弹出元素</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">q[++ tt] = x;</span><br><span class="line"><span class="comment">// 弹出</span></span><br><span class="line">hh ++;</span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span>(hh&lt;=tt) <span class="keyword">not</span> empty</span><br><span class="line"><span class="keyword">else</span> empty</span><br><span class="line"><span class="comment">// 取出队头元素</span></span><br><span class="line">q[hh];</span><br></pre></td></tr></table></figure>
<h2 id="单调栈和单调队列"><a href="#单调栈和单调队列" class="headerlink" title="单调栈和单调队列"></a>单调栈和单调队列</h2><p><strong>单调栈解决的是以某个值为最小（最大）值的最大区间</strong></p>
<p><strong>单调队列解决的是区间最小（最大）值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调栈： 给定一个序列，找到这个序列中每一个数的左边离它最近的且比它小(大)的数-&gt; 找当前元素即将入栈时的栈顶元素; </span></span><br><span class="line"><span class="comment">// 给定一个序列，找到这个序列中每一个数的左边离它最近的且比它小(大)的数和右边离他最最近的且比它小(大)的数 -&gt; 栈顶元素出栈时，可确定栈顶下面一个元素一定是它左边第一个比栈顶小的元素，当前元素一定是右边第一个小于等于栈顶的元素。</span></span><br><span class="line"><span class="comment">// 序列： 3  4  2 7 5</span></span><br><span class="line"><span class="comment">//      -1  3 -1 2 2</span></span><br><span class="line"><span class="comment">// 暴力 循环  对每一个元素向左遍历之前的元素 (0,1,2,..., i-1) &lt;- i    O(N2)</span></span><br><span class="line"><span class="comment">//              若j&lt;k &amp;&amp; a[j]&gt;=a[k] 则肯定不会是第j个元素，把这些没用的元素删掉会得到单调性</span></span><br><span class="line"><span class="comment">// 单调递增栈：从栈底到栈顶单调递增，当新来一个元素比栈顶元素大or栈为空，则直接将该元素入栈；当新来一个元素比栈顶元素的小，则递归的将栈顶元素出栈直到栈顶元素小于该元素或栈为空，再将该元素入栈</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[N], tt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// 若循环内用cin读取输入，可开启ios::sync_stdio(false);加速</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        <span class="keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= x) tt -- ;</span><br><span class="line">        <span class="keyword">if</span> (!tt) <span class="built_in">printf</span>(<span class="string">"-1 "</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>, stk[tt]);</span><br><span class="line">        stk[ ++ tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单调队列  </span></span><br><span class="line"><span class="comment">// 求滑动窗口中的最小值(最大值)</span></span><br><span class="line"><span class="comment">// 1 3 -1 -3 5 3 6 7</span></span><br><span class="line"><span class="comment">// 3 -1 -3 </span></span><br><span class="line"><span class="comment">//  暴力  维护队列 每次计算队列内部最值     O(NK)</span></span><br><span class="line"><span class="comment">// 只要当-3进入队列，队列中的3，-1一定没用，因此可以删除，把这些没用的元素删掉会得到单调性</span></span><br><span class="line"><span class="comment">// 单调队列队头对应的即为窗口的最小值  (存储下标)</span></span><br><span class="line"><span class="comment">// 出队时，判断单调队列队头是否被弹出</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], q[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh ++ ; <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt -- ;</span><br><span class="line">        q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><h4 id="Largest-Rectangle-in-Histogram"><a href="#Largest-Rectangle-in-Histogram" class="headerlink" title="Largest Rectangle in Histogram"></a>Largest Rectangle in Histogram</h4><p>Given <em>n</em> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p>方法一： 暴力枚举起始点  one by one consider all bars as starting points and calculate area of all rectangles starting with every bar. Finally return maximum of all possible areas. Time complexity of this solution would be O(n^2).</p>
<p>方法二：<a href="https://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/</a></p>
<p> 分治 We can use <strong>Divide and Conquer</strong> to solve this in O(nLogn) time. The idea is to find the minimum value in the given array. Once we have index of the minimum value, the max area is maximum of following three values. <strong>a)</strong> Maximum area in left side of minimum value (Not including the min value) <strong>b)</strong> Maximum area in right side of minimum value (Not including the min value) <strong>c)</strong> Number of bars multiplied by minimum value.</p>
<p>The areas in left and right of minimum value bar can be calculated recursively. If we use linear search to find the minimum value, then the worst case time complexity of this algorithm becomes O(n^2). In worst case, we always have (n-1) elements in one side and 0 elements in other side and if the finding minimum takes O(n) time, we get the recurrence similar to worst case of Quick Sort. How to find the minimum efficiently? <a href="https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/" target="_blank" rel="noopener">Range Minimum Query using Segment Tree</a> can be used for this. We build segment tree of the given histogram heights. Once the segment tree is built, all <a href="https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/" target="_blank" rel="noopener">range minimum queries take O(Logn) time</a>. So over all complexity of the algorithm becomes.</p>
<p>Overall Time = Time to build Segment Tree + Time to recursively find maximum area</p>
<p><a href="https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/" target="_blank" rel="noopener">Time to build segment tree is O(n)</a>. Let the time to recursively find max area be T(n). It can be written as following.<br>T(n) = O(Logn) + T(n-1)<br>The solution of above recurrence is O(nLogn). So overall time is O(n) + O(nLogn) which is O(nLogn).</p>
<p>方法三： <a href="https://www.geeksforgeeks.org/largest-rectangle-under-histogram/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/largest-rectangle-under-histogram/</a>  单调栈</p>
<p>For every bar ‘x’, we calculate the area with ‘x’ as the smallest bar in the rectangle. If we calculate such area for every bar ‘x’ and find the maximum of all areas, our task is done. How to calculate area with ‘x’ as smallest bar? We need to know index of the first smaller (smaller than ‘x’) bar on left of ‘x’ and index of first smaller bar on right of ‘x’. Let us call these indexes as ‘left index’ and ‘right index’ respectively.</p>
<p>We traverse all bars from left to right, maintain a stack of bars. Every bar is pushed to stack once. A bar is popped from stack when a bar of smaller height is seen. When a bar is popped, we calculate the area with the popped bar as smallest bar. How do we get left and right indexes of the popped bar – the current index tells us the ‘right index’ and index of previous item in stack is the ‘left index’. Following is the complete algorithm.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前点作为区间最小值能扩展的矩形</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(heights.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        heights.push_back(<span class="number">0</span>); <span class="comment">// to pop all th bars</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st; <span class="comment">// 需要知道左右边界的位置-&gt;存储坐标</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;heights.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.empty() <span class="keyword">and</span> heights[st.top()]&gt;=heights[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> top = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">int</span> leftIndex = st.empty()? <span class="number">0</span>: st.top()+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> rightIndex = i<span class="number">-1</span>;</span><br><span class="line">                res = max(res,(rightIndex-leftIndex+<span class="number">1</span>)*heights[top]);</span><br><span class="line">                <span class="comment">//cout&lt;&lt;top&lt;&lt;" "&lt;&lt;res&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Trapping-Rain-Water"><a href="#Trapping-Rain-Water" class="headerlink" title="Trapping Rain Water"></a>Trapping Rain Water</h4><p>Given <em>n</em> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p> <a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">https://leetcode.com/problems/trapping-rain-water/</a></p>
<p>方法一: 动态规划求出当前点的左边最大值和右边最大值</p>
<p>方法二： 单调栈</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前点作为区间最大值能装下的水</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(height.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;height.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty() <span class="keyword">and</span> height[st.top()]&lt;=height[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> top = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span>(st.empty()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> distance = i-st.top()<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;top&lt;&lt;" "&lt;&lt;height[top]&lt;&lt;endl;</span></span><br><span class="line">            res += (min(height[i],height[st.top()])-height[top])*distance;</span><br><span class="line">        &#125;</span><br><span class="line">        st.push(i);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;i&lt;&lt;" "&lt;&lt;st.size()&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Sum-of-Subarray-Minimums-Maximums"><a href="#Sum-of-Subarray-Minimums-Maximums" class="headerlink" title="Sum of Subarray Minimums/Maximums"></a>Sum of Subarray Minimums/Maximums</h4><p>Hulu码率  </p>
<blockquote>
<p>hulu 有一系列的视频文件，每个文件都有对应的码率，为整数，输入长度为n的视频码率数组arr,现在定义两个文件区段之间的最大码率为：$p[i][j] = max(arr[i], arr[i+1],…,arr[j]), 0&lt;=i&lt;=j&lt;=n-1$</p>
<p>针对所有满足条件的$ 0&lt;=i&lt;=j&lt;=n-1$的$(i,j$)对, 求$p[i][j]$的总和(%1000000000007)</p>
</blockquote>
<p><strong>考虑点：如果以当前点作为区间最大点，哪些区间符合？这些区间可以为区间的全集？</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nums.push_back(INT_MAX); <span class="comment">// 使得所有点都会被pop</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">st.push(<span class="number">-1</span>); <span class="comment">// 保证栈里至少有一个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(st.size()&gt;<span class="number">1</span> <span class="keyword">and</span> nums[st.top()]&lt;=nums[i])&#123; <span class="comment">//栈里有一个有效元素</span></span><br><span class="line">        <span class="keyword">int</span> mid = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        <span class="keyword">int</span> l = mid-st.top()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = i-mid<span class="number">-1</span>;</span><br><span class="line">        res = (res+nums[mid]*(l+r+l*r+<span class="number">1</span>))%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    st.push(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>leetcode 907 Sum of Subarray Minimums</p>
<h4 id="叶值的最小代价生成树"><a href="#叶值的最小代价生成树" class="headerlink" title="叶值的最小代价生成树"></a>叶值的最小代价生成树</h4><p>Leetcode 1130</p>
<blockquote>
<p>给你一个正整数数组 arr，考虑所有满足以下条件的二叉树：</p>
<p>每个节点都有 0 个或是 2 个子节点。<br>数组 arr 中的值与树的中序遍历中每个叶节点的值一一对应。（知识回顾：如果一个节点有 0 个子节点，那么该节点为叶节点。）<br>每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。<br>在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个 32 位整数。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果不考虑叶子节点的顺序</span></span><br><span class="line"><span class="comment">// 代价为两数乘积，合并节点为大值数  (代价为两数和，合并节点为两数和，huffman,合并果子)</span></span><br><span class="line">A.sort();</span><br><span class="line"><span class="keyword">for</span>()&#123;</span><br><span class="line">    res += A[i]*A[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">A = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">A = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span> ,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 考虑叶子节点顺序为树的中序遍历</span></span><br><span class="line"><span class="comment">// 每个节点与其最近的大值数合并  单调栈</span></span><br><span class="line"><span class="keyword">int</span> mctFromLeafValues(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr) &#123;</span><br><span class="line">    arr.push_back(INT_MAX);</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty() <span class="keyword">and</span> st.top()&lt;= arr[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> u = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">int</span> v = arr[i];</span><br><span class="line">            <span class="keyword">if</span>(!st.empty()) v = min(v, st.top());</span><br><span class="line">            <span class="keyword">if</span>(v != INT_MAX) res += v*u;</span><br><span class="line">        &#125;</span><br><span class="line">        st.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="132-pattern"><a href="#132-pattern" class="headerlink" title="132 pattern"></a>132 pattern</h4><p>Leetcode 456</p>
<blockquote>
<p>给定一个整数序列 a1,a2,…,an，132模式是a的子序列 ai,aj,ak，满足 i&lt;j&lt;k，并且 ai&lt;ak&lt;aj。设计一个算法，读入n个整数的数字序列，判断是否存在132模式。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right_min(n, INT_MAX);</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!st.empty() &amp;&amp; nums[i] &gt; nums[st.top()]) &#123;</span><br><span class="line">            right_min[i] = nums[st.top()];</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        st.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left_min = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; left_min)</span><br><span class="line">            left_min = nums[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (left_min &lt; right_min[i] &amp;&amp; right_min[i] &lt; nums[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><h3 id="max-sliding-window"><a href="#max-sliding-window" class="headerlink" title="max sliding window"></a>max sliding window</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调队列</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!q.empty() &amp;&amp; i-k+<span class="number">1</span>&gt;q.front()) q.pop_front(); <span class="comment">// 出队</span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty() &amp;&amp; nums[q.back()]&lt;nums[i]) q.pop_back();</span><br><span class="line">        q.push_back(i); <span class="comment">// 入队</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>) res.push_back(nums[q.front()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>木桶问题： 在solution空间二分      单调队列</p>
<h3 id="最大子序和-长度不超过M"><a href="#最大子序和-长度不超过M" class="headerlink" title="最大子序和(长度不超过M)"></a>最大子序和(长度不超过M)</h3><blockquote>
<p>输入一个长度为n的整数序列，从中找出一段长度不超过M的连续子序列，使得整个序列的和最大</p>
</blockquote>
<p>求区间和问题就相当于找前缀和的最大差值，在这道问题中，原问题就可以转换为找到两个位置x，y，使得sum[y]-sum[x]最大并且y-x≤m。 我们一重循环枚举右端点x，那么问题就转化为：找到左端点j，j∈[i-m,i-1]且sum[j]最小。=&gt; max sliding window</p>
<h3 id="Shortest-Subarray-with-Sum-at-Least-K"><a href="#Shortest-Subarray-with-Sum-at-Least-K" class="headerlink" title="Shortest Subarray with Sum at Least K"></a>Shortest Subarray with Sum at Least K</h3><p>leetcode 862</p>
<blockquote>
<p>Return the <strong>length</strong> of the shortest, non-empty, contiguous subarray of <code>A</code> with sum at least <code>K</code>.</p>
<p>If there is no non-empty subarray with sum at least <code>K</code>, return <code>-1</code>.</p>
</blockquote>
<p>Calculate prefix sum <code>B</code> of list <code>A</code>. <code>B[j] - B[i]</code> represents the sum of subarray <code>A[i] ~ A[j-1]</code> Deque <code>d</code> will keep indexes of increasing <code>B[i]</code>. For every <code>B[i]</code>, we will compare <code>B[i] - B[d[0]]</code> with <code>K</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shortestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = A.size(), res = N + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) B[i + <span class="number">1</span>] = B[i] + A[i];</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (d.size() &gt; <span class="number">0</span> &amp;&amp; B[i] - B[d.front()] &gt;= K)</span><br><span class="line">            res = min(res, i - d.front()), d.pop_front();</span><br><span class="line">        <span class="keyword">while</span> (d.size() &gt; <span class="number">0</span> &amp;&amp; B[i] &lt;= B[d.back()]) d.pop_back();</span><br><span class="line">        d.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res &lt;= N ? res : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="迭代与递归"><a href="#迭代与递归" class="headerlink" title="迭代与递归"></a>迭代与递归</h1><p>迭代：时间复杂度（级数求和）</p>
<p>算数级数：与末项平方同阶 $T(n)=1+2+…+n=n(n+1)/2=O(n^2)$</p>
<p>幂方级数：比幂次高出一阶（积分）</p>
<p>$T_2(n)=1^2+2^2+…n^2=O(n^3)$</p>
<p>$T_3(n)=1^3+2^3+…n^3=O(n^4)$</p>
<p>几何级数：与末项同阶 $T(n)=a_0(1+q+…+q^n)=a_0(q^n-1)/(q-1)$</p>
<p>收敛级数：O(1)</p>
<p>调和级数：$1+1/2+1/3+…+1/n=\theta(logn)$</p>
<p>对数级数：$log1+log2+…+logn=log(n!)=\theta(nlogn)$</p>
<h2 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h2><p>如下图所示，从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间只有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数</p>
<p><img src="https://images2015.cnblogs.com/blog/1026866/201610/1026866-20161016022859889-2055402664.jpg" alt="img"></p>
<p>实现这个算法可以简单分为三个步骤：</p>
<p>　　　　（1）     把n-1个盘子由A 移到 B；</p>
<p>　　　　（2）     把第n个盘子由 A移到 C；</p>
<p>　　　　（3）     把n-1个盘子由B 移到 C；</p>
<p>$H(n) = 1+2H(n-1) = 1+2+4H(n-2) = 1+2+4+8H(n-3)  = …. = 1+2+4+….+ 2^{n-1}  = 2^{n}-1$</p>
<h2 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h2><p><a href="https://cloud.tencent.com/developer/article/1164728" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1164728</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/35487124" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35487124</a></p>
<blockquote>
<p>设有编号为1，2，……，n的n(n&gt;0)个人围成一个圈，从第1个人开始报数，报到m时停止报数，报m的人出圈，再从他的下一个人起重新报数，报到m时停止报数，报m的出圈，……，如此下去，直到所有人全部出圈为止。当任意给定n和m后，复现这个过程（各成员的离席次序），或者求最后一个在座的成员编号。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列模拟</span></span><br><span class="line"><span class="comment">// 首先所有人入队，队头报数，(&lt;m)，从队头移到队尾； (==m)从队列中移除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用递归求得最后一个在座的成员编号</span></span><br><span class="line"><span class="comment">//   0     1       ... (m-2)%n,(m-1)%n,m%n,..., n-2, n-1</span></span><br><span class="line"><span class="comment">//   0     1       ... (m-2)%n,       ,m%n,..., n-2, n-1</span></span><br><span class="line"><span class="comment">//   n-m%n n-m%n+1 ...   n-2,         ,0,...,n-2-m%n,n-1-m%n</span></span><br><span class="line"><span class="comment">// F(1) = 0  |  F(n) = [F(n - 1) + m] % n      (n&gt;1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">josephus</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> <span class="comment">// 递推</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == n)</span><br><span class="line">  n<span class="number">-2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (josephus(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">josephus</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> <span class="comment">//循环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> out = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        out = (out + m) % i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表-递归-非递归"><a href="#链表-递归-非递归" class="headerlink" title="链表  递归  非递归"></a>链表  递归  非递归</h2><h2 id="树-递归-非递归"><a href="#树-递归-非递归" class="headerlink" title="树  递归  非递归"></a>树  递归  非递归</h2><h4 id="Binary-Tree-Upside-Down"><a href="#Binary-Tree-Upside-Down" class="headerlink" title="Binary Tree Upside Down"></a>Binary Tree Upside Down</h4><h4 id="Increasing-Order-Search-Tree"><a href="#Increasing-Order-Search-Tree" class="headerlink" title="Increasing Order Search Tree"></a>Increasing Order Search Tree</h4><blockquote>
<p>Given a tree, rearrange the tree in <strong>in-order</strong> so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child.</p>
</blockquote>
<p>leetcode 897</p>
<p>Straigh forward idea:<br><code>res = inorder(root.left) + root + inorder(root.right)</code></p>
<p>Several tips here:</p>
<ol>
<li>I pass a tail part to the function, so it can link it to the last node.<br>This operation takes <code>O(1)</code>, instead of <code>O(N)</code>.<br>Otherwise the whole time complexity will be <code>O(N^2)</code>.</li>
<li>Also, remember to set <code>root.left = null</code>.<br>Otherwise it will be TLE for Leetcode to traverse your tree.</li>
<li>Should arrange the old tree, not create a new tree.<br>The judgement won’t take it as wrong answer, but it is.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">increasingBST</span><span class="params">(TreeNode* root, TreeNode* tail = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> tail;</span><br><span class="line">    TreeNode* res = increasingBST(root-&gt;left, root);</span><br><span class="line">    root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    root-&gt;right = increasingBST(root-&gt;right, tail);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>哈希表的存储结构：开放寻址法，拉链法</p>
<h2 id="模拟哈希"><a href="#模拟哈希" class="headerlink" title="模拟哈希"></a>模拟哈希</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护一个集合，支持如下几种操作：</span></span><br><span class="line"><span class="comment">// “I x”，插入一个数x；</span></span><br><span class="line"><span class="comment">// “Q x”，询问数x是否在集合中出现过；</span></span><br><span class="line"><span class="comment">// 现在要进行N次操作，对于每个询问操作输出对应的结果</span></span><br><span class="line"><span class="comment">// 1≤N≤10^5  −10^9≤x≤10^9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拉链法</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100003</span>;<span class="comment">// 100003为大于100000的第一个质数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N; <span class="comment">// 防止出现负数</span></span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h); <span class="comment">// 初始化h, -1表示空指针</span></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">insert(x);</span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="keyword">if</span>(find(x))</span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line"><span class="comment">// 开放寻址法</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200003</span>, null = <span class="number">0x3f3f3f3f</span>;<span class="comment">// 根据经验开到题目数据范围的2-3倍，200003为大于200000的第一个质数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果x在哈希表中存在返回其在哈希表中的位置，否则返回x应该存储的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        t ++ ;</span><br><span class="line">        <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">h[find(x)] = x; </span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="keyword">if</span>(h[find(x)] == null)</span><br></pre></td></tr></table></figure>
<p>0x3f3f3f3f: 无穷大   0xcfcfcfcf:无穷小</p>
<blockquote>
<p>0x3f3f3f3f的十进制是1061109567，也就是10^9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。</p>
<p>另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷大”），事实上0x3f3f3f3f+0x3f3f3f3f=2122219134，这非常大但却没有超过32-bit int的表示范围，所以0x3f3f3f3f还满足了我们“无穷大加无穷大还是无穷大”的需求。</p>
<p>最后，0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的初始化），就不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），我们知道这是因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0，现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。</p>
</blockquote>
<p><a href="https://blog.csdn.net/tcherry/article/details/37606277" target="_blank" rel="noopener">https://blog.csdn.net/tcherry/article/details/37606277</a></p>
<h1 id="String-1"><a href="#String-1" class="headerlink" title="String"></a>String</h1><p><strong>如果不是一个字符一个字符的处理，采用python语言</strong></p>
<h2 id="strStr"><a href="#strStr" class="headerlink" title="strStr()"></a>strStr()</h2><h3 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h3><p>$O(NM)​$：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="built_in">string</span> &amp; p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">int</span> m = p.size();</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;=n-m; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;m <span class="keyword">and</span> s[i+j]==p[j]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j==m)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到所有下标</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; strStr2(<span class="built_in">string</span>&amp; s, <span class="built_in">string</span> &amp; p)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">int</span> m = p.size();</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;=n-m; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;m <span class="keyword">and</span> s[i+j]==p[j]) j++；</span><br><span class="line">        <span class="keyword">if</span>(j==m)&#123;</span><br><span class="line">            res.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>$O(N+M)$:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="keyword">char</span> s[M], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求nex数组  next[i]等于P[1]...P[i]最长的相同真前后缀的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i ++ ) <span class="comment">// j为ne[i-1]</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// kmp j零下标匹配的为空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">        <span class="keyword">if</span> (j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, i - n); <span class="comment">// 输出所有出现位置的起始下标（下标从0开始计数）</span></span><br><span class="line">            j = ne[j];<span class="comment">// 完成一次匹配，j指向其最长的相同真前后缀，返回所有下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sliding-window-algorithm"><a href="#Sliding-window-algorithm" class="headerlink" title="Sliding window algorithm"></a>Sliding window algorithm</h2><ul>
<li>Sliding window algorithm (substring search problem)</li>
</ul>
<p><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/description/" target="_blank" rel="noopener">https://leetcode.com/problems/find-all-anagrams-in-a-string/description/</a></p>
<p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a></p>
<p><a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-window-substring/</a></p>
<p><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/" target="_blank" rel="noopener">https://leetcode.com/problems/substring-with-concatenation-of-all-words/</a></p>
<p><a href="https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/</a></p>
<p>模板： <a href="https://www.cnblogs.com/hygeia/p/6477177.html" target="_blank" rel="noopener">https://www.cnblogs.com/hygeia/p/6477177.html</a></p>
<p>搜索的substring长度固定： iterate i </p>
<p>搜索的substring长度不固定， iterate begin、end</p>
<p>哈希key有限： 动态维护hash/数组</p>
<p>哈希key无限：动态维护hash、count</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">slidingWindowTemplateByHarryChaoyangHe</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//init a collection or int value to save the result according the question.</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(t.length()&gt; s.length()) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//create a hashmap to save the Characters of the target substring.</span></span><br><span class="line">        <span class="comment">//(K, V) = (Character, Frequence of the Characters)</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : t.toCharArray())&#123;</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//maintain a counter to check whether match the target string.</span></span><br><span class="line">        <span class="keyword">int</span> counter = map.size();<span class="comment">//must be the map size, NOT the string size because the char may be duplicate.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Two Pointers: begin - left pointer of the window; end - right pointer of the window</span></span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//the length of the substring which match the target string.</span></span><br><span class="line">        <span class="keyword">int</span> len = Integer.MAX_VALUE; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//loop at the begining of the source string</span></span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(end);<span class="comment">//get a character</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>( map.containsKey(c) )&#123;</span><br><span class="line">                map.put(c, map.get(c)-<span class="number">1</span>);<span class="comment">// plus or minus one</span></span><br><span class="line">                <span class="keyword">if</span>(map.get(c) == <span class="number">0</span>) counter--;<span class="comment">//modify the counter according the requirement(different condition).</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//increase begin pointer to make it invalid/valid again</span></span><br><span class="line">            <span class="keyword">while</span>(counter == <span class="number">0</span> <span class="comment">/* counter condition. different question may have different condition */</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">char</span> tempc = s.charAt(begin);<span class="comment">//***be careful here: choose the char at begin pointer, NOT the end pointer</span></span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(tempc))&#123;</span><br><span class="line">                    map.put(tempc, map.get(tempc) + <span class="number">1</span>);<span class="comment">//plus or minus one</span></span><br><span class="line">                    <span class="keyword">if</span>(map.get(tempc) &gt; <span class="number">0</span>) counter++;<span class="comment">//modify the counter according the requirement(different condition).</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/* save / update(min/max) the result if find a target*/</span></span><br><span class="line">                <span class="comment">// result collections or result int value</span></span><br><span class="line">                </span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="string-hash"><a href="#string-hash" class="headerlink" title="string hash"></a>string hash</h2><p>字符串前缀哈希法</p>
<p><a href="https://blog.csdn.net/pengwill97/article/details/80879387" target="_blank" rel="noopener">https://blog.csdn.net/pengwill97/article/details/80879387</a></p>
<p>给定一个字符串$S=s_1s_2s_3..s_n$，对字母x，我们规定$idx(x)=x−′a′+1$（当然也可以直接用$s_i$的ASCII值）</p>
<h3 id="自然溢出"><a href="#自然溢出" class="headerlink" title="自然溢出"></a>自然溢出</h3><p>unsigned long long Hash[n]</p>
<p>$hash[i]=hash[i−1]∗p+id(s[i])$</p>
<p>利用unsigned long long的范围自然溢出，相当于自动对$2^{64}$取模</p>
<blockquote>
<p>经验值： p = 131 or 13331  mod = 2^64</p>
</blockquote>
<h3 id="单Hash方法"><a href="#单Hash方法" class="headerlink" title="单Hash方法"></a>单Hash方法</h3><p>$hash[i]=(hash[i−1])∗p+idx(s[i])  \%  mod$<br>其中p和mod均为质数，且有p&lt;mod</p>
<p>对于此种Hash方法，将p和mod尽量取大即可，这种情况下，冲突的概率是很低的</p>
<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>若已知一个|S|=n 的字符串的hash值，hash[i],1≤i≤n，其子串$s_l..s_r,1≤l≤r≤n$对应的hash值为：</p>
<p>$hash=hash[r]−hash[l−1]∗p^{r−l+1}$</p>
<blockquote>
<p>1  2 …. l-1 l ……r</p>
<p>hash[r]   p^{r-1} </p>
<p>hash[l-1]   p^{l-2}   对齐到hash[r]  hash[l-1]*p^{r-l+1}</p>
</blockquote>
<p>考虑到hash[i]每次对p取模，进一步得到：$hash=(hash[r]−hash[l−1]∗p^{r−l+1})\%mod$</p>
<p>看起来这个式子人畜无害，但是对于取模运算要谨慎再谨慎，注意到括号里面是减法，即有可能是负数，故做如下的修正：$hash=((hash[r]−hash[l−1]∗p^{r−l+1})\%mod+mod)\%mod$</p>
<p>至此得到求子串hash值公式。</p>
<p>值得一提的是，如果需要反复对子串求解hash值，预处理p的n次方效果更佳。</p>
<h3 id="Hash素数的选取"><a href="#Hash素数的选取" class="headerlink" title="Hash素数的选取"></a>Hash素数的选取</h3><p>为了防止冲突，要选择合适的素数，像1e9+7,1e9+9的一些素数，出题人一般会卡一下下，所以尽量选择其他的素数，防止被卡。下面是一些可供选择的素数。 </p>
<p><a href="https://leetcode.com/problems/group-anagrams/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/group-anagrams/submissions/</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定一个长度为n的字符串，再给定m个询问，每个询问包含四个整数l1,r1,l2,r2，请你判断[l1,r1]和[l2,r2]这两个区间所包含的字符串子串是否完全相同。 字符串中只包含大小写英文字母和数字。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, P = <span class="number">131</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line">ULL h[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l1, r1, l2, r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (get(l1, r1) == get(l2, r2)) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串转化"><a href="#字符串转化" class="headerlink" title="字符串转化"></a>字符串转化</h2><p>Leetcode1153</p>
<blockquote>
<p>给出两个长度相同的字符串，分别是 str1 和 str2。请你帮忙判断字符串 str1 能不能在 零次 或 多次 转化后变成字符串 str2。</p>
<p>每一次转化时，将会一次性将 str1 中出现的 所有 相同字母变成其他任何小写英文字母。</p>
<p>只有在字符串 str1 能够通过上述方式顺利转化为字符串 str2 时才能返回 True，否则返回 False。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canConvert</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str1 == str2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> n1 = str1.size();</span><br><span class="line">    <span class="keyword">int</span> n2 = str2.size();</span><br><span class="line">    <span class="keyword">if</span>(n1!=n2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; table;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n2; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(table.count(str1[i]) <span class="keyword">and</span> table[str1[i]]!=str2[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        table[str1[i]] = str2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">set</span>(str2.begin(), str2.end()).size() &lt; <span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc -&gt; baa</span></span><br><span class="line"><span class="comment">// 先转换为对应模式 abc-&gt;abb (a,b-&gt;b,a问题) -&gt;cbb-&gt;caa-&gt;baa</span></span><br><span class="line"><span class="comment">// a,b -&gt; b,a (tmp=a, a=b, b=tmp)</span></span><br><span class="line"><span class="comment">// 循环移位 a,b,c-&gt;b,c,a (tmp=a, a=b, b=c, c=tmp)</span></span><br></pre></td></tr></table></figure>
<h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><p>递归！！！！ 节点和它的子树</p>
<p>递归时会有栈的空间复杂度</p>
<p>递归前对节点进行操作，并将操作的结果传给子树：自上向下</p>
<p>递归后利用子树传递的结果对节点进行操作：自下向上</p>
<p>树的分析： 完全平衡 $T(n) = aT(n/b) + f(n)$（主方法） 完全不平衡 $T(n) = T(n-1) + f(n)$（退化为array）</p>
<p>当f(n) = 1时，$T(n)=1$,即为遍历树的时间</p>
<h2 id="Balanced-Binary-Tree"><a href="#Balanced-Binary-Tree" class="headerlink" title="Balanced Binary Tree"></a>Balanced Binary Tree</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bfs</span></span><br><span class="line"><span class="comment">// 平衡二叉树的定义1：最深叶子节点和最浅叶子节点，深度差不超过1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    Node* left, right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_balance</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;Node*, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> dmin = INT_MAX, dmax = <span class="number">0</span>;</span><br><span class="line">    q.push(make_pair(root,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">auto</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        Node* u = now.first;</span><br><span class="line">        <span class="keyword">int</span> d = now.second;</span><br><span class="line">        <span class="keyword">if</span>(u-&gt;left) q.push(make_pair(u-&gt;left,d+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(u-&gt;right) q.push(make_pair(u-&gt;right,d+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(!u-&gt;left <span class="keyword">and</span> !u-&gt;right)&#123;<span class="comment">//叶子节点</span></span><br><span class="line">            dmin = min(dmin,d);</span><br><span class="line">            dmax = max(dmax,d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dmax-dmin&lt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平衡二叉树的定义2: a binary tree in which the depth of the two subtrees of every node never differ by more than 1. </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> balance(root)!=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回值包含信息：当前子树深度以及当前子树是否为平衡二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">balance</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = balance(node-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> r = balance(node-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(l!=<span class="number">-1</span> &amp;&amp; r!=<span class="number">-1</span> &amp;&amp; <span class="built_in">abs</span>(l-r)&lt;=<span class="number">1</span>) <span class="keyword">return</span> max(l,r)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCA-Lowest-Common-Ancestor"><a href="#LCA-Lowest-Common-Ancestor" class="headerlink" title="LCA(Lowest Common Ancestor)"></a>LCA(Lowest Common Ancestor)</h2><h3 id="LCA-在线算法"><a href="#LCA-在线算法" class="headerlink" title="LCA 在线算法"></a>LCA 在线算法</h3><p><a href="https://blog.csdn.net/hackbuteer1/article/details/8022138" target="_blank" rel="noopener">https://blog.csdn.net/hackbuteer1/article/details/8022138</a></p>
<blockquote>
<p> 情况一：root未知，但是每个节点都有parent指针</p>
<p>此时可以分别从两个节点开始，沿着parent指针走向根节点，得到两个链表，然后求两个链表的第一个公共节点，这个方法很简单，不需要详细解释的。</p>
<p> 情况二：节点只有左、右指针，没有parent指针，root已知</p>
<p>思路：有两种情况，一是要找的这两个节点（a, b），在要遍历的节点（root）的两侧，那么这个节点就是这两个节点的最近公共父节点；</p>
<p>二是两个节点在同一侧，则 root-&gt;left 或者 root-&gt;right 为 NULL，另一边返回a或者b。那么另一边返回的就是他们的最小公共父节点。</p>
<p>递归有两个出口，一是没有找到a或者b，则返回NULL；二是只要碰到a或者b，就立刻返回。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">findLca</span><span class="params">(TreeNode* root , TreeNode* p , TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">	TreeNode* left = findLca(root-&gt;left , p , q);</span><br><span class="line">	TreeNode* right = findLca(root-&gt;right , p , q);</span><br><span class="line">	<span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">	<span class="keyword">return</span> left ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如需N 次查询，则总体复杂度会扩大N 倍，故这种暴力解法仅适合一次查询，不适合多次查询。</p>
<p>总体来说，由于可以把LCA问题看成是询问式的，即给出一系列询问，程序对每一个询问尽快做出反应。故处理这类问题一般有两种解决方法：</p>
<ul>
<li>一种是在线算法，相当于循序渐进处理；</li>
<li>另外一种则是离线算法，如Tarjan算法，相当于一次性批量处理，一开始就知道了全部查询，只待询问。</li>
</ul>
<h3 id="二叉搜索树的最近公共父节点"><a href="#二叉搜索树的最近公共父节点" class="headerlink" title="二叉搜索树的最近公共父节点"></a>二叉搜索树的最近公共父节点</h3><p>Lowest Common Ancestor of a <strong>Binary Search Tree</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//递归</span><br><span class="line">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==NULL) <span class="keyword">return</span> NULL;</span><br><span class="line">        if((p-&gt;val-root-&gt;val)*(q-&gt;val-root-&gt;val)&lt;=0) return root;</span><br><span class="line">        else if(p-&gt;val-root-&gt;val&lt;0) return lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">        else return lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//循环</span><br><span class="line">TreeNode* findLowestCommonAncestor(TreeNode* root , TreeNode* a , TreeNode* b)</span><br><span class="line">&#123;</span><br><span class="line">	char min  , max;</span><br><span class="line">	if(a-&gt;val &lt; b-&gt;val)</span><br><span class="line">		min = a-&gt;val , max = b-&gt;val;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		min = b-&gt;val , max = a-&gt;val;</span><br><span class="line">	<span class="keyword">while</span>(root)</span><br><span class="line">	&#123;</span><br><span class="line">		if(root-&gt;val &gt;= min &amp;&amp; root-&gt;val &lt;= max)</span><br><span class="line">			<span class="keyword">return</span> root;</span><br><span class="line">		else if(root-&gt;val &lt; min)</span><br><span class="line">			root = root-&gt;right;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			root = root-&gt;left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最深叶节点的最近公共父节点"><a href="#最深叶节点的最近公共父节点" class="headerlink" title="最深叶节点的最近公共父节点"></a>最深叶节点的最近公共父节点</h3><blockquote>
<p>给你一个有根节点的二叉树，找到它最深的叶节点的最近公共祖先</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;TreeNode*, <span class="keyword">int</span>&gt; dfs(TreeNode* root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> &#123;<span class="literal">NULL</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    pair&lt;TreeNode*, <span class="keyword">int</span>&gt; pl = dfs(root-&gt;left);</span><br><span class="line">    pair&lt;TreeNode*, <span class="keyword">int</span>&gt; pr = dfs(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(pl.second&lt;pr.second)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;pr.first,pr.second+<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pl.second&gt;pr.second)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;pl.first, pl.second+<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;root,pr.second+<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">lcaDeepestLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(root).first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完全二叉树的最近公共父节点"><a href="#完全二叉树的最近公共父节点" class="headerlink" title="完全二叉树的最近公共父节点"></a>完全二叉树的最近公共父节点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b) a&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br></pre></td></tr></table></figure>
<h1 id="堆-优先队列"><a href="#堆-优先队列" class="headerlink" title="堆 优先队列"></a>堆 优先队列</h1><h2 id="用数组模拟堆"><a href="#用数组模拟堆" class="headerlink" title="用数组模拟堆"></a>用数组模拟堆</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一个数         heap[++size] = x; up(size);</span></span><br><span class="line"><span class="comment">// 求集合中的最小值    heap[1]</span></span><br><span class="line"><span class="comment">// 删除最小值         heap[1] = heap[size]; size--; down(1);</span></span><br><span class="line"><span class="comment">// 删除任意一个元素    heap[k] = heap[size]; size--; up(k); down(k);</span></span><br><span class="line"><span class="comment">// 修改任意一个元素    heap[k] = x; up(k); down(k);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆 完全二叉树， 除最后一层节点都是满的，最后一层节点从左到右排列</span></span><br><span class="line"><span class="comment">// 小根堆： 每个节点的值都 &lt;= 其左儿子和右儿子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="keyword">int</span> h[N], ph[N], hp[N], size, idx; <span class="comment">// idx表示共插入多少个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    swap(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    swap(hp[a], hp[b]);</span><br><span class="line">    swap(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(u, t);</span><br><span class="line">        down(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;h[i]);</span><br><span class="line">size = n; idx = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i; i -- ) down(i);</span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">size ++ ;</span><br><span class="line">idx ++ ;</span><br><span class="line">ph[idx] = size, hp[size] = idx;</span><br><span class="line">h[size] = x;</span><br><span class="line">up(size);</span><br><span class="line"><span class="comment">// 删除第k个插入的元素</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">k = ph[k];</span><br><span class="line">heap_swap(k, size);</span><br><span class="line">size -- ;</span><br><span class="line">up(k);</span><br><span class="line">down(k);</span><br><span class="line"><span class="comment">//删除第k个插入的元素</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;k, &amp;x);</span><br><span class="line">k = ph[k];</span><br><span class="line">h[k] = x;</span><br><span class="line">up(k);</span><br><span class="line">down(k);</span><br></pre></td></tr></table></figure>
<h2 id="merge-k-sorted-list"><a href="#merge-k-sorted-list" class="headerlink" title="merge k sorted list"></a>merge k sorted list</h2><p>k is the number of linked lists. </p>
<p>N is the number of nodes in the final linked list.   </p>
<p><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-k-sorted-lists/</a></p>
<ul>
<li>优先队列  <ul>
<li>Time complexity : $O(Nlogk) $<ul>
<li>The comparison cost will be reduced to $O(logk)$ for every pop and insertion to priority queue. But finding the node with the smallest value just costs $O(1)$ time.</li>
</ul>
</li>
<li>Space complexity :<ul>
<li>$O(k)$ The code above present applies in-place method which cost $O(1)$ space. And the priority queue (often implemented with heaps) costs $O(k)$ space (it’s far less than N in most situations). </li>
</ul>
</li>
</ul>
</li>
<li>分治  <ul>
<li>Time complexity : $O(Nlogk)$ where <ul>
<li>We can merge two sorted linked list in $O(N)$ time where nn is the total number of nodes in two lists.</li>
<li>Sum up the merge process and we can get: $O\big(\sum_{i=1}^{log_{2}{k}}N \big)= O(N\log k)$</li>
</ul>
</li>
<li>Space complexity : $O(1)$<ul>
<li>We can merge two sorted linked lists in $O(1)$ space.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><ul>
<li>高效的存储和查找字符串集合的数据结构</li>
</ul>
<p>边上为对应字符</p>
<h3 id="字符串统计"><a href="#字符串统计" class="headerlink" title="字符串统计"></a>字符串统计</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], cnt[N], idx;<span class="comment">// 下标为0的节点既为根节点，又为空节点</span></span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="IP合并"><a href="#IP合并" class="headerlink" title="IP合并"></a>IP合并</h3><p>字典树，添加字符串，沿路节点cnt++; 记录节点深度 dfs</p>
<h2 id="Trie树-1"><a href="#Trie树-1" class="headerlink" title="Trie树"></a>Trie树</h2><p>kmp+字典树</p>
<p>判断字符串S中，是否存在字符串集合PP中任意一个字符串</p>
<p>当前节点的next指向当前节点所有应字符串的后缀与树中所有字符串的前缀中重合最大的那个前缀所对应的节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trie树   字典树+kmp</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    Node* son[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    Node* next;</span><br><span class="line">    Node()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++) son[i]=<span class="literal">NULL</span>;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">buildTrie1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; pp)</span></span>&#123;</span><br><span class="line">    Node* dummyRoot = <span class="keyword">new</span> Node();</span><br><span class="line">    Node* root = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++) dummyRoot-&gt;son[i] = root;</span><br><span class="line">    <span class="comment">//dummyRoot-&gt;next = dummyRoot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pp.size(); i++)&#123;</span><br><span class="line">        Node* p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;pp[i].size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;son[pp[i][j]-<span class="string">'a'</span>]) p-&gt;son[pp[i][j]-<span class="string">'a'</span>] = <span class="keyword">new</span> Node();</span><br><span class="line">            p = p-&gt;son[pp[i][j]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bfs get next</span></span><br><span class="line">    root-&gt;next = dummyRoot;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        Node* u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(u-&gt;son[i])&#123;</span><br><span class="line">                Node* v = u;</span><br><span class="line">                <span class="keyword">while</span>(v!=dummyRoot <span class="keyword">and</span> !v-&gt;next-&gt;son[i])&#123;</span><br><span class="line">                    v = v-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                u-&gt;son[i]-&gt;next = v-&gt;next-&gt;son[i];</span><br><span class="line">                </span><br><span class="line">                q.push(u-&gt;son[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check3</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; pp)</span></span>&#123;</span><br><span class="line">    Node* root = buildTrie1(pp);</span><br><span class="line">    Node* p = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=root <span class="keyword">and</span> !p-&gt;son[s[i]-<span class="string">'a'</span>]) p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;son[s[i]-<span class="string">'a'</span>]) p = p-&gt;son[s[i]-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;flag) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>字符串集合PP中每个字符串对应一个分值</p>
<p>问字符串S中，共包含多少分（可重叠，出现几次算几次分）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">buildTrie2</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt;&amp; pp)</span></span>&#123;</span><br><span class="line">    Node* dummyRoot = <span class="keyword">new</span> Node();</span><br><span class="line">    Node* root = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++) dummyRoot-&gt;son[i] = root;</span><br><span class="line">    <span class="comment">//dummyRoot-&gt;next = dummyRoot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pp.size(); i++)&#123;</span><br><span class="line">        Node* p = root;</span><br><span class="line">        <span class="built_in">string</span> pi = pp[i].first;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;pi.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;son[pi[j]-<span class="string">'a'</span>]) p-&gt;son[pi[j]-<span class="string">'a'</span>] = <span class="keyword">new</span> Node();</span><br><span class="line">            p = p-&gt;son[pi[j]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;flag += pp[i].second; <span class="comment">// 允许重复</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bfs get next</span></span><br><span class="line">    root-&gt;next = dummyRoot;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        Node* u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(u-&gt;son[i])&#123;</span><br><span class="line">                Node* v = u-&gt;next;</span><br><span class="line">                u-&gt;flag += v-&gt;flag; <span class="comment">// 累加next的分数</span></span><br><span class="line">                <span class="keyword">while</span>(v!=dummyRoot <span class="keyword">and</span> !v-&gt;son[i])&#123;</span><br><span class="line">                    v = v-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                u-&gt;son[i]-&gt;next = v-&gt;son[i];</span><br><span class="line">                </span><br><span class="line">                q.push(u-&gt;son[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">getScore3</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt;&amp; pp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">    Node* root = buildTrie2(pp);</span><br><span class="line">    Node* p = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=root <span class="keyword">and</span> !p-&gt;son[s[i]-<span class="string">'a'</span>]) p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;son[s[i]-<span class="string">'a'</span>]) p = p-&gt;son[s[i]-<span class="string">'a'</span>];</span><br><span class="line">        score += p-&gt;flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Trie-图（ac-自动机）"><a href="#Trie-图（ac-自动机）" class="headerlink" title="Trie 图（ac 自动机）"></a>Trie 图（ac 自动机）</h2><p>自动补全trie树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trie图 得到字符串S中包含的分数</span></span><br><span class="line"><span class="function">Node* <span class="title">buildTrieGraph</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt;&amp; pp)</span></span>&#123;</span><br><span class="line">    Node* dummyRoot = <span class="keyword">new</span> Node();</span><br><span class="line">    Node* root = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++) dummyRoot-&gt;son[i] = root;</span><br><span class="line">    <span class="comment">//dummyRoot-&gt;next = dummyRoot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pp.size(); i++)&#123;</span><br><span class="line">        Node* p = root;</span><br><span class="line">        <span class="built_in">string</span> pi = pp[i].first;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;pi.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;son[pi[j]-<span class="string">'a'</span>]) p-&gt;son[pi[j]-<span class="string">'a'</span>] = <span class="keyword">new</span> Node();</span><br><span class="line">            p = p-&gt;son[pi[j]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;flag += pp[i].second; <span class="comment">// 允许重复</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bfs get next</span></span><br><span class="line">    root-&gt;next = dummyRoot;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        Node* u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)&#123;</span><br><span class="line">            Node* v = u-&gt;next; <span class="comment">// v的所有边都已补全</span></span><br><span class="line">            u-&gt;flag += v-&gt;flag;</span><br><span class="line">            <span class="keyword">if</span>(!u-&gt;son[i])&#123;</span><br><span class="line">                u-&gt;son[i] = v-&gt;son[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                u-&gt;son[i]-&gt;next = v-&gt;son[i];</span><br><span class="line">                q.push(u-&gt;son[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getScore4</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt;&amp; pp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">    Node* root = buildTrieGraph(pp);</span><br><span class="line">    Node* p = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.size(); i++)&#123;</span><br><span class="line">        p = p-&gt;son[s[i]-<span class="string">'a'</span>];</span><br><span class="line">        score += p-&gt;flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p>整数表示范围：</p>
<p>unsigned   int   0～4294967295<br>int   2147483648～2147483647<br>unsigned long 0～4294967295<br>long   2147483648～2147483647<br>long long的最大值：9223372036854775807<br>long long的最小值：-9223372036854775808<br>unsigned long long的最大值：1844674407370955161</p>
<p><strong>int64的最大值：9223372036854775807
</strong>int64的最小值：-9223372036854775808<br>unsigned __int64的最大值：18446744073709551615</p>
<h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><h4 id="取模-取余"><a href="#取模-取余" class="headerlink" title="取模 取余"></a>取模 取余</h4><p>对于整型数a，b来说，取模运算或者求余运算的方法都是：</p>
<p>1.求 整数商： c = a/b;</p>
<p>2.计算模或者余数： r = a - c*b.</p>
<p>求模运算和求余运算在第一步不同: 取余运算在取c的值时，向0 方向舍入(fix()函数)；而取模运算在计算c的值时，向负无穷方向舍入(floor()函数)</p>
<p>例如计算：-7 Mod 4</p>
<p>那么：a = -7；b = 4；</p>
<p>第一步：求整数商c，如进行求模运算c = -2（向负无穷方向舍入），求余c = -1（向0方向舍入）；</p>
<p>第二步：计算模和余数的公式相同，但因c的值不同，求模时r = 1，求余时r = -3。</p>
<p>归纳：<strong>当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致</strong></p>
<p>当符号不一致时，结果不一样。求模运算结果的符号和b一致，求余运算结果的符号和a一致。</p>
<p>另外各个环境下%运算符的含义不同，比如c/c++，java 为取余，而python则为取模</p>
<p>$(A+B)\%p = (A\%p + B\%p)\%p$</p>
<p>$(A-B)\%p = (A\%p -B\%p+p)\%p$</p>
<p>$(A<em>B)\%p = (A\%p </em> B\%p)\%p$</p>
<p>$(A/B)\%p     !=  (A\%p / B\%p)\%p$</p>
<p>$(A/B)\%p     =  (A\%p*inv(B\%p,p)\%p$</p>
<h3 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h3><p><a href="https://www.geeksforgeeks.org/prime-numbers/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/prime-numbers/</a> </p>
<blockquote>
<p>在大于1的整数中，如果只包含1和本身这两个约数，就被称为质数，或者叫做素数</p>
</blockquote>
<h4 id="质数的判定"><a href="#质数的判定" class="headerlink" title="质数的判定"></a>质数的判定</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 试除法判定是否是质数   O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; x; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  试除法优化： 如果 d能整除n,则 d/n也能整除n;  O(sqrt(n))</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h4><p>$x = p_1^{a_1}p_2^{a_2}p_3^{a_3}…..$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 试除法   O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="comment">// x中此时不包括任何2~i-1的质因子，若i能整除x ,则i也一定不包括任何2~i-1的质因子(i为质数)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化：n中最多只包含一个大于sqrt(n)的质因子    时间复杂度： logn~sqrt(n)  </span></span><br><span class="line"><span class="comment">// n=2^k时 -&gt;复杂度为k   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定一个正整数n，请你求出1~n中质数的个数</span></span><br><span class="line"><span class="comment">// 质数定理： 1~n中有ln(n)个质数</span></span><br><span class="line"><span class="comment">// 时间复杂度为O(nloglogn) 埃氏筛法</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N= <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> primes[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            primes[cnt ++ ] = i; <span class="comment">// 2~i-1都没有把i筛掉，i一定为质数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += i) <span class="comment">// 把质数的所有倍数筛掉</span></span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性筛法 时间复杂度为O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123; </span><br><span class="line">            primes[cnt ++ ] = i; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ ) </span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>; <span class="comment">// 合数只会被其最小质因子筛掉</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;  </span><br><span class="line">            <span class="comment">//i % primes[j] == 0: primes[j]是i的最小质因子=&gt; primes[j]是primes[j]*i的最小质因子</span></span><br><span class="line">            <span class="comment">//i % primes[j] != 0: primes[j]&lt;i的最小质因子=&gt; primes[j]是primes[j]*i的最小质因子</span></span><br><span class="line">            <span class="comment">// 对于一个合数x，假设pj为其最小质因子，当i枚举到x/pj，会被筛掉</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 试除法求约数 (类似判断质数)  时间复杂度为 O(sqrt(n))</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; get_divisors(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="comment">// 约数成对出现</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.push_back(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    sort(res.begin(), res.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="约数个数-amp-约数之和"><a href="#约数个数-amp-约数之和" class="headerlink" title="约数个数 &amp; 约数之和"></a>约数个数 &amp; 约数之和</h4><p>$x = p_1^{a_1}p_2^{a_2}p_3^{a_3}…..$</p>
<p>约数个数  $(a_1+1)(a_2+1)….$<br> 约数之和  $(p_1^0+p_1^1…+p_1^{a_1})(p_2^0+p_2^1…+p_2^{a_2})…$</p>
<blockquote>
<p>给定n个正整数ai，请你输出这些数的乘积的约数个数，答案对10^9+7取模</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; primes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (n -- )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">while</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x /= i;</span><br><span class="line">            primes[i] ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) primes[x] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : primes) res = res * (p.second + <span class="number">1</span>) % mod;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>给定n个正整数ai，请你输出这些数的乘积的约数之和，答案对10^9+7取模。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; primes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (n -- )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">while</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x /= i;</span><br><span class="line">            primes[i] ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) primes[x] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : primes)</span><br><span class="line">&#123;</span><br><span class="line">    LL a = p.first, b = p.second;</span><br><span class="line">    LL t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b -- ) t = (t * a + <span class="number">1</span>) % mod;</span><br><span class="line">    res = res * t % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最大公约数-最小公倍数-欧几里得算法"><a href="#最大公约数-最小公倍数-欧几里得算法" class="headerlink" title="最大公约数 最小公倍数 (欧几里得算法)"></a>最大公约数 最小公倍数 (欧几里得算法)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 欧几里得算法</span></span><br><span class="line"><span class="comment">// 辗转相除法 最大公约数 gcd(a,b) = gcd(b,a%b) = gcd(a%b, b%(a%b))</span></span><br><span class="line"><span class="comment">// 若a%b &gt; b/2  b%(a%b) = b-a%b &lt; b/2 规模减半</span></span><br><span class="line"><span class="comment">// 若a%b == b/2 直接结束</span></span><br><span class="line"><span class="comment">// 若a%b &lt; b/2  b%(a%b) &lt; a%b &lt; b/2 规模减半</span></span><br><span class="line"><span class="comment">// 时间复杂度O(logn)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最小公倍数 gcd(a, b) * lcm(a, b) = ab</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b/gcd(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为$\phi(N)$。 若在算数基本定理中，$N = p_1^{a_1}p_2^{a_2}p_3^{a_3}…..p_m^{a_m}$，则： $\phi(N) = N <em> \frac{p_1-1}{p_1} </em> \frac{p_2-1}{p_2}…* \frac{p_m-1}{p_m}$</p>
<p>容斥原理</p>
<ol>
<li>从1~N中，把$p_1,…,p_k$ 的倍数去掉</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求x的欧拉函数 分解质因数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给定一个正整数n，求1~n中每个数的欧拉函数之和。</span></span><br><span class="line"><span class="keyword">int</span> primes[N], cnt;</span><br><span class="line"><span class="keyword">int</span> euler[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_eulers</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123; </span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            euler[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="comment">// i中包含primes[j]的因数</span></span><br><span class="line">            &#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>); <span class="comment">// i中不包含primes[j]的因数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 欧拉定理</span></span><br><span class="line"><span class="comment">// 若a与</span></span><br></pre></td></tr></table></figure>
<h4 id="欧拉定理-费马定理"><a href="#欧拉定理-费马定理" class="headerlink" title="欧拉定理 费马定理"></a>欧拉定理 费马定理</h4><p>若a与n互质，则$a^{\phi(n)} \% n = 1$</p>
<p>假设1~n中，与n互质的数为$a_1, a_2,…,a_{\phi(n)}$</p>
<p>则$a<em>a_1, a</em>a_2,…,a*a_{\phi(n)}$ 也与n互质且各不相同</p>
<p>$ (a_1<em>a_</em>…<em>a_{\phi(n)} )\%n = ((a</em>a_1)\%n <em>  (a</em>a_2)\%n <em>…</em> (a<em>a{\phi(n)})\%n = (a^{\phi(n)}(a_1</em>a_<em>…</em>a_{\phi(n)}))\%n $</p>
<p>=&gt; $a^{\phi(n)} \% n = 1$</p>
<p>若n为质数，则$a^{n-1} \% n = 1$ (费马定理)</p>
<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定a,b,p，求出(a^b)%p的值。</span></span><br><span class="line"><span class="comment">// 暴力循环 O(b)</span></span><br><span class="line"><span class="comment">// 快速幂 O(logb) </span></span><br><span class="line"><span class="comment">// 反复平方法  把b拆成2的幂次数之和=&gt; 转换为2进制</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % p;</span><br><span class="line">        a = a * (LL)a % p; <span class="comment">// 当前位为第位时，a为a^&#123;2^i&#125;</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, qmi(a, b, p));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速幂求逆元</span></span><br><span class="line"><span class="comment">// 给定a,p，其中p是质数,求a模p的乘法逆元，若逆元不存在则输出impossible</span></span><br><span class="line"><span class="keyword">if</span> (a % p == <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, qmi(a, p - <span class="number">2</span>, p));</span><br></pre></td></tr></table></figure>
<h5 id="乘法逆元的定义"><a href="#乘法逆元的定义" class="headerlink" title="乘法逆元的定义"></a>乘法逆元的定义</h5><blockquote>
<p>若整数b，m互质，并且a%b==0，则存在一个整数x，使得a/b≡a∗x(mod m)，则称x为b的模m乘法逆元，记为$b^{−1}$(mod m)。<br>b存在乘法逆元的充要条件是b与模数m互质。当模数m为质数时，$b^{m−2}$即为b的乘法逆元。</p>
</blockquote>
<p>a/b≡a∗x(mod m) =&gt; a≡a*b*x =&gt; b<em>x≡1  (mod m) (若b%m=0,则b\</em>x≡0,无解)</p>
<p>若m为质数，则$b^{m-1}$≡ 1</p>
<h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p><strong>裴署定理</strong></p>
<p>对于任意正整数a,b，一定存在非零整数x,y, 使得ax+by=gcd(a,b)</p>
<p>(a和b的最大公约数是a和b能凑出来的最小正整数) </p>
<p>(a和b能凑出来的一定是gcd(a,b)的倍数) </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ax+by=1 返回一组整数解 </span></span><br><span class="line"><span class="comment">// O(logn) </span></span><br><span class="line"><span class="comment">// ax+by = 1 = gcd(a,b) = gcd(b,a%b) = by'+(a%b)x‘</span></span><br><span class="line"><span class="comment">// ax+by = by'+(a-(a/b)b)x'</span></span><br><span class="line"><span class="comment">// ax = ax'  |   by = by'-(a/b)bx'</span></span><br><span class="line"><span class="comment">// x = x'| y = y'-(a/b)x' 不断递推可得1x'+0y'= 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ax+by=k ab 互质   解为(ax+by=1)的解的k倍</span></span><br><span class="line"><span class="comment">// ax+by=1 ab 不互质   无解</span></span><br><span class="line"><span class="comment">// ax+by=k ab 不互质  看k是否有gcd(a,b)的因数，若无则无解，否则公式两边除以gcd(a,b)转化为ab互质时的问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------</span></span><br><span class="line"><span class="comment">// 给定正整数a,b，求出一组x,y，使其满足ax+by=gcd(a,b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = exgcd(b, a % b, y, x); <span class="comment">// 得到 gcd(b,a%b) = by'+(a%b)x‘的解</span></span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通解：x0-k*(b/d)  y0+k*(a/d)</span></span><br></pre></td></tr></table></figure>
<h4 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定a,b,m，求出一个x，使其满足a∗x≡b(mod m)，如果无解则输出impossible</span></span><br><span class="line"><span class="comment">// a∗x≡b(mod m)有解 &lt;=&gt; a*x + m*k = b 有解 &lt;=&gt; b是gcd(a,m)的倍数</span></span><br><span class="line"><span class="keyword">int</span> d = exgcd(a, m, x, y);</span><br><span class="line"><span class="keyword">if</span> (b % d) <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)b / d * x % m);</span><br></pre></td></tr></table></figure>
<h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><blockquote>
<p>$x\%m_1 = a_1,   x\%m_2 = a_2,  …… ,x\%m_n = a_n$  求x</p>
<p> 若 $m_1,….m_n$两两互质，则一定有解</p>
<p> $M = m_1<em>m_2</em>…*m_n,  M_i = M/m_i,   M_i^{-1} $表示$M_i$模$m_i$的逆</p>
<p>则x的通解为$x=a_1M_1M_1^{-1}+a_2M_2M_2^{-1}…+a_nM_nM_n^{-1} $</p>
<p>$x\%m_1 = a_1,   x\%m_2 = a_2 $ &lt;=&gt; x = m1*k1 + a1 = m2*k2 + a2  &lt;=&gt; m1*k1-m2*k2 = a2-a1 有解</p>
<p>&lt;=&gt; a2-a1是gcd(m1,m2)的倍数</p>
<p>k1的通解为 k1’ + k*m2/gcd(m1,m2)   </p>
<p>x的通解为m1*( k1’ + k*m2/gcd(m1,m2)) + a1 = a1 + m1*k1’ + k*lcm(m1,m2)  = x’ + k*m</p>
<p>x%a’ = x’ 将两个方程合并为1个</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">LL x = <span class="number">0</span>, m1, a1;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m1 &gt;&gt; a1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    LL m2, a2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m2 &gt;&gt; a2;</span><br><span class="line">    LL k1, k2;</span><br><span class="line">    LL d = exgcd(m1, m2, k1, k2);</span><br><span class="line">    <span class="keyword">if</span> ((a2 - a1) % d)  <span class="comment">// 无解</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    k1 *= (a2 - a1) / d; <span class="comment">// k1的特解</span></span><br><span class="line">    k1 = (k1 % (m2/d) + m2/d) % (m2/d); <span class="comment">// 最小的正整数解</span></span><br><span class="line"></span><br><span class="line">    x = k1 * m1 + a1; <span class="comment">// k1&lt;= m2/d - 1, a1&lt;m1; k1*m1+a1 &lt;= m1*m2/d - m1 + a1 &lt; m1*m2/d</span></span><br><span class="line"></span><br><span class="line">    LL m = <span class="built_in">abs</span>(m1 / d * m2); <span class="comment">// 最小公倍数</span></span><br><span class="line">    a1 = x;</span><br><span class="line">    m1 = m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><h3 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数"></a>组合计数</h3><p>$C_m^n\%p$</p>
<p>m,n 数量级为$10^{18}$</p>
<p>方法一： 动态规划 $C_m^n = C_{m-1}^{n-1}+C_{m-1}^n$  $O(n^2)$</p>
<p>方法二： $C_m^n = \frac{m!}{n!(m-n)!} = \frac{(m-n+1)…m}{1…n} = \frac{A}{B}$</p>
<p>$a = A\%p, b = B\%p$</p>
<p>(A/B)%p = (a*inv(b,p))%p</p>
<p>(b*inv(b,p))%p = 1 =&gt; bx%p = 1 =&gt; bx=py+1 =&gt; bx+py’=1  若p为质数 则可求解 (x=b^{p-1})</p>
<p>若p不为质数，将p分解为质数，中国剩余定理求解</p>
<h1 id="Bit-Manipulation"><a href="#Bit-Manipulation" class="headerlink" title="Bit Manipulation"></a>Bit Manipulation</h1><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>正数和0的补码就是将该数字本身。负数的补码则是将其对应正数按位取反再加1：</p>
<p>最大数(0 + 若干个1)-&gt;0(0+若干个0)-&gt; -1(1+ 若干个1)-&gt; 最小数（1+若干个0）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>0</strong></th>
<th><strong>1</strong></th>
<th><strong>1</strong></th>
<th><strong>1</strong></th>
<th><strong>1</strong></th>
<th><strong>1</strong></th>
<th><strong>1</strong></th>
<th><strong>1</strong></th>
<th><strong>=</strong></th>
<th style="text-align:center"><strong>127</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>=</strong></td>
<td style="text-align:center"><strong>2</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td><strong>=</strong></td>
<td style="text-align:center"><strong>1</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>=</strong></td>
<td style="text-align:center"><strong>0</strong></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>=</strong></td>
<td style="text-align:center"><strong>−1</strong></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>=</strong></td>
<td style="text-align:center"><strong>−2</strong></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td><strong>=</strong></td>
<td style="text-align:center"><strong>−127</strong></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>0</strong></td>
<td><strong>=</strong></td>
<td style="text-align:center"><strong>−128</strong></td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A             .......1 (000000)</span></span><br><span class="line"><span class="comment">// A-1           .......0 (111111)</span></span><br><span class="line"><span class="comment">// A&amp;(A-1)       .......0 (000000)  去掉A中最右边的1</span></span><br><span class="line"><span class="comment">// A&amp; ~(A-1)     00000001 (000000)  提取A中最右边的1所代表的数 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A |= 1 &lt;&lt; bit                    A中右边数第bit位置1</span></span><br><span class="line"><span class="comment">// A &amp;= ~(1 &lt;&lt; bit)                 A中右边数第bit位置0</span></span><br><span class="line"><span class="comment">// (A &amp; 1 &lt;&lt; bit) != 0              检验A中右边数第bit为0还是1</span></span><br><span class="line"><span class="comment">// ~0                               Get all 1-bits</span></span><br></pre></td></tr></table></figure>
<h2 id="左移右移"><a href="#左移右移" class="headerlink" title="左移右移"></a>左移右移</h2><blockquote>
<p> 对于无符号数来说，左移1位，相当于乘以一个2，右移一位相当于除以一个2;</p>
<p>对于有符号数则没有上述规律</p>
</blockquote>
<p><a href="https://blog.csdn.net/yusliao/article/details/39152671" target="_blank" rel="noopener">https://blog.csdn.net/yusliao/article/details/39152671</a></p>
<p><a href="https://blog.csdn.net/e3399/article/details/7526230" target="_blank" rel="noopener">https://blog.csdn.net/e3399/article/details/7526230</a></p>
<blockquote>
<p>在c 中左移也就是所说的逻辑移位，右端补0，而右移是算数移位，左端补齐的是最高位的符号位。</p>
</blockquote>
<p>1)负数的右移：负数右移的话，由于要保持它是负数，所以左端补齐的是最高位的符号位1。如果一直右移的话，最后就就变成0xFFFFFFFF 即-1</p>
<p>2)负数的左移：跟正整数左移一样，右边补0，一直左移的话，最后就是0啦。-2&lt;&lt;1 为-4 ； -2&lt;&lt;31为0</p>
<p>故负数左移，有可能变成正数，但负数右移，肯定还是负数。 </p>
<h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><h3 id="single-Number"><a href="#single-Number" class="headerlink" title="single Number"></a>single Number</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Given a non-empty array of integers, every element appears **twice** except for one. Find that single one.</span></span><br><span class="line"><span class="comment">// x^x = 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">        result ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="single-Number-ii"><a href="#single-Number-ii" class="headerlink" title="single Number ii"></a>single Number ii</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Given a non-empty array of integers, every element appears **k**(k&gt;=2) times except for one, which appears exactly once. Find that single one.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> count[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">        count[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;nums.size();j++)&#123;</span><br><span class="line">            count[i]+= (nums[j]&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;count[i]&lt;&lt;endl;</span></span><br><span class="line">        res |= ((count[i]%k)&lt;&lt;i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="single-Number-iii"><a href="#single-Number-iii" class="headerlink" title="single Number iii"></a>single Number iii</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; singleNumber(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">        n^=nums[i];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> m = n&amp;(~(n<span class="number">-1</span>));</span><br><span class="line">    <span class="comment">//cout&lt;&lt;n&lt;&lt;" "&lt;&lt;m&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">int</span> x1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&amp;m) x1^=nums[i];</span><br><span class="line">        <span class="keyword">else</span> x2^=nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line">    res.push_back(x1);</span><br><span class="line">    res.push_back(x2);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="给定范围的重复与缺失问题"><a href="#给定范围的重复与缺失问题" class="headerlink" title="给定范围的重复与缺失问题"></a>给定范围的重复与缺失问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N+1个数，范围在1~N，其中仅有一个数出现两次，其他出现一次，求出出现两次的数</span></span><br><span class="line"><span class="comment">// 1. hash                       空间O(N)  时间O(N)</span></span><br><span class="line"><span class="comment">// 2. 数学方法: sum-N(1+N)/2      空间O(1)  时间O(N)</span></span><br><span class="line"><span class="comment">// 3. 异或 index,val             空间O(1)  时间O(N)</span></span><br><span class="line">---------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// N个数，范围在0-N，每个数出现一次，求缺失的数</span></span><br><span class="line"><span class="comment">// 数学方法：N(1+N)/2-sum</span></span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数</span></span><br><span class="line"><span class="comment">// 1.排序</span></span><br><span class="line"><span class="comment">// 2. hash</span></span><br><span class="line"><span class="comment">// 3. 循环检测</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> fast=nums[nums[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">        slow=nums[slow];</span><br><span class="line">        fast=nums[nums[fast]];</span><br><span class="line">    &#125;</span><br><span class="line">    slow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">        slow=nums[slow];</span><br><span class="line">        fast=nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Count-set-bits-in-an-integer-正整数"><a href="#Count-set-bits-in-an-integer-正整数" class="headerlink" title="Count set bits in an integer(正整数)"></a>Count set bits in an integer(正整数)</h2><p>Simple method:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countSetBits</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">while</span> (n) </span><br><span class="line">  &#123; </span><br><span class="line">    count += n &amp; <span class="number">1</span>; </span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> count; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Brian Kernighan’s Algorithm</strong></p>
<blockquote>
<p><strong>When we do bitwise AND between (number) &amp; (number-1), Right most SET bit of “number” will be unset.</strong></p>
<p>The beauty of this solution is the number of times it loops is equal to the number of set bits in a given integer.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countSetBits</span><span class="params">(<span class="keyword">unsigned</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (n) </span><br><span class="line">    &#123; </span><br><span class="line">      n &amp;= (n<span class="number">-1</span>) ; </span><br><span class="line">      count++; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> count; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Number-Complement"><a href="#Number-Complement" class="headerlink" title="Number Complement"></a>Number Complement</h2><blockquote>
<p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>
<p>Eg:  5(101)-&gt;2(010)</p>
</blockquote>
<p>Simple method</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            result += (<span class="number">1</span>-(num&amp;<span class="number">1</span>))*i;</span><br><span class="line">            i=i&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            num=num&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Mask </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> mask = ~<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &amp; mask) mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ~mask &amp; ~num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Bitmap-Bitset"><a href="#Bitmap-Bitset" class="headerlink" title="Bitmap Bitset"></a>Bitmap Bitset</h2><p>大数据排序，查询以及去重</p>
<h3 id="Partition-Equal-Subset-Sum"><a href="#Partition-Equal-Subset-Sum" class="headerlink" title="Partition Equal Subset Sum"></a>Partition Equal Subset Sum</h3><p>Leetcode 416</p>
<blockquote>
<p>Given a <strong>non-empty</strong> array containing <strong>only positive integers</strong>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>
<p><strong>Note:</strong></p>
<ol>
<li>Each of the array element will not exceed 100.</li>
<li>The array size will not exceed 200.</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> MAX_NUM = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = <span class="number">200</span>;</span><br><span class="line">        <span class="built_in">bitset</span>&lt;MAX_NUM * MAX_ARRAY_SIZE / 2 + 1&gt; bits(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">            sum += n;</span><br><span class="line">            bits |= bits &lt;&lt; n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !(sum % <span class="number">2</span>) &amp;&amp; bits[sum / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;// explanation</span><br><span class="line">&gt;num = 5</span><br><span class="line">&gt;0 -&gt; 5 (set 5&apos;s bit, since we can achieve sum 5.)</span><br><span class="line">&gt;Now we can achieve 0 and 5 with [ ] and [ 5 ]. So by the union of both, we have 000000100001</span><br><span class="line">&gt;</span><br><span class="line">&gt;num = 2</span><br><span class="line">&gt;0-&gt;2</span><br><span class="line">&gt;5-&gt;7</span><br><span class="line">&gt;We can achieve 0,2,5,7 from [5,2] ==&gt; [ ], [5], [2], [5,2]</span><br><span class="line">&gt;After union our bitset is 000010100101</span><br><span class="line">&gt;</span><br><span class="line">&gt;num = 4</span><br><span class="line">&gt;0-&gt;4</span><br><span class="line">&gt;2-&gt;6</span><br><span class="line">&gt;5-&gt;9</span><br><span class="line">&gt;7-&gt;11</span><br><span class="line">&gt;We can achieve 0,2,4,5,6,7,11 from [5,2] ==&gt; [ ], [5], [2], [4], [5,2], [2,4], [5,4], [5,2,4]</span><br><span class="line">&gt;After union our bitset is 101011110101</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>Energy stone 贪心+背包</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N个能量石，i-th能量石有三个特性</span></span><br><span class="line"><span class="comment">// 初始能量Ei, 吃掉该能量石用时Si, 能量石每秒损失能量Li (开始吃能量石的瞬间获得能量，但需等Si才能吃下一个)</span></span><br><span class="line"><span class="comment">// 求吃能量石最大可获得的能量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Si/Li 贪心排序+背包dp</span></span><br><span class="line"><span class="comment">// 贪心，比较序列...,i,j,...和序列...,j,i,...</span></span><br><span class="line"><span class="comment">// ... +   max(0,E[i]-C*L[i]) + max(0, E[j]-(C+S[i])*L[j]) + ....</span></span><br><span class="line"><span class="comment">// ... +   max(0,E[j]-C*L[j]) + max(0, E[i]-(C+S[j])*L[i]) + ...</span></span><br><span class="line"><span class="comment">// 1) E均足够大 则S[i]/L[i]小的优先吃</span></span><br><span class="line"><span class="comment">// 2) 若4个式子中有取0， 则存在序列...,i,....或...,j,...更优</span></span><br><span class="line"><span class="comment">// 因此最优序列一定满足S[i]/L[i]的排序</span></span><br><span class="line"><span class="comment">// 至于选择哪些能量石吃或不吃转移为背包问题</span></span><br></pre></td></tr></table></figure>
<p>Code-eat switcher   贪心+二分</p>
<p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050edb/00000000001707b8" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050edb/00000000001707b8</a></p>
<h2 id="合并果子-huffman"><a href="#合并果子-huffman" class="headerlink" title="合并果子  huffman"></a>合并果子  huffman</h2><blockquote>
<p>在一个果园里，达达已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。</p>
<p>达达决定把所有的果子合成一堆。</p>
<p>每一次合并，达达可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。</p>
<p>可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。求最小的体力耗费值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        heap.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (heap.size() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = heap.top(); heap.pop();</span><br><span class="line">        <span class="keyword">int</span> b = heap.top(); heap.pop();</span><br><span class="line">        res += a + b;</span><br><span class="line">        heap.push(a + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h2><h3 id="离线区间merge"><a href="#离线区间merge" class="headerlink" title="离线区间merge"></a>离线区间merge</h3><p><a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-intervals/</a></p>
<ul>
<li><p>给出若干闭合区间，合并所有重叠的部分</p>
<p>按照区间的 start 大小进行排序</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// 首先对区间开始的位置做排序</span></span><br><span class="line">        sort(intervals.begin(),intervals.end(),compare);</span><br><span class="line">        <span class="keyword">int</span> begin = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(end&lt;intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; interval = &#123;begin,end&#125;;</span><br><span class="line">                res.push_back(interval);</span><br><span class="line">                begin = intervals[i][<span class="number">0</span>];</span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end = max(end,intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; interval = &#123;begin,end&#125;;</span><br><span class="line">        res.push_back(interval);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间选点-最大的不相交区间的数量"><a href="#区间选点-最大的不相交区间的数量" class="headerlink" title="区间选点|最大的不相交区间的数量"></a>区间选点|最大的不相交区间的数量</h3><blockquote>
<p> 给定N个闭区间[ai,biai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。</p>
<p>输出选择的点的最小数量。位于区间端点上的点也算作区间内。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对每个区间的结束位置做排序</span></span><br><span class="line"><span class="comment">// 从前往后一次枚举每个区间</span></span><br><span class="line"><span class="comment">//      1) 如果当前区间中已经包含点，则直接pass</span></span><br><span class="line"><span class="comment">//      2) 否则，选择当前区间的右端点</span></span><br><span class="line">--------</span><br><span class="line">    --------</span><br><span class="line">           -------</span><br></pre></td></tr></table></figure>
<p>等价于求最大的不相交区间的数量</p>
<blockquote>
<p>给定N个闭区间[ai,biai,bi]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。</p>
<p>输出可选取区间的最大数量。</p>
</blockquote>
<h3 id="区间分组"><a href="#区间分组" class="headerlink" title="区间分组"></a>区间分组</h3><blockquote>
<p>给定N个闭区间[ai,biai,bi]，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">-------</span><br><span class="line">    ---------</span><br><span class="line">          -----</span><br><span class="line"><span class="comment">// 对每个区间的开始位置做排序</span></span><br><span class="line"><span class="comment">// 从前往后枚举每个区间</span></span><br><span class="line"><span class="comment">//       判断能否将其放到现有的某个组(维护每个组的最靠右的点)</span></span><br><span class="line"><span class="comment">//             若不能则开新组，并将其放进去</span></span><br><span class="line"><span class="comment">//             否则，将其放进去，更新这个组的max_r</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Range &amp;W)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; W.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        range[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(range, range + n);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> r = range[i];</span><br><span class="line">        <span class="keyword">if</span> (heap.empty() || heap.top() &gt;= r.l) heap.push(r.r);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            heap.pop();</span><br><span class="line">            heap.push(r.r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, heap.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间覆盖"><a href="#区间覆盖" class="headerlink" title="区间覆盖"></a>区间覆盖</h3><blockquote>
<p>给定N个闭区间[ai,bi]以及一个线段区间[s,t]，请你选择尽量少的区间，将指定线段区间完全覆盖。</p>
<p>输出最少区间数，如果无法完全覆盖则输出-1。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对每个区间的开始位置做排序</span></span><br><span class="line"><span class="comment">// 从前往后枚举每个区间，在所有能够覆盖start的区间，选择右端点最大的，然后将start更新为最大的右端点</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Range &amp;W)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; W.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st, ed;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;st, &amp;ed);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        range[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(range, range + n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i, r = <span class="number">-2e9</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; range[j].l &lt;= st)</span><br><span class="line">        &#123;</span><br><span class="line">            r = max(r, range[j].r);</span><br><span class="line">            j ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r &lt; st)</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res ++ ;</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= ed)</span><br><span class="line">        &#123;</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        st = r;</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!success) res = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Maximum-Length-of-Pair-Chain"><a href="#Maximum-Length-of-Pair-Chain" class="headerlink" title="Maximum Length of Pair Chain"></a>Maximum Length of Pair Chain</h3><p><a href="https://leetcode.com/problems/maximum-length-of-pair-chain/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-length-of-pair-chain/</a></p>
<p><a href="https://leetcode.com/problems/maximum-length-of-pair-chain/discuss/105617/C%2B%2B-Clean-Code" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-length-of-pair-chain/discuss/105617/C%2B%2B-Clean-Code</a></p>
<ol>
<li>sort the pairs by their end in increasing order;</li>
<li>at any point, choose the pair that start after the tail end, then use it as the new tail;</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        sort(pairs.begin(), pairs.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pair = pairs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || pairs[i][<span class="number">0</span>] &gt; pair[<span class="number">1</span>]) &#123;</span><br><span class="line">                pair = pairs[i];</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>] || a[<span class="number">1</span>] == b[<span class="number">1</span>] &amp;&amp; a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="区间重叠-扫描线算法"><a href="#区间重叠-扫描线算法" class="headerlink" title="区间重叠 扫描线算法"></a>区间重叠 扫描线算法</h3><p>事件往往是以区间的形式存在</p>
<p>区间的两端代表事件的开始和结束</p>
<p>将起点和终点打散排序，[[1,3], [2,4]] =&gt; [[1,start],[2,start],[3,end],[4,end]</p>
<blockquote>
<p>[lintcode 920]给定一系列区间，代表一系列会议时间间隔，求一个人能否参加所有的会议。</p>
<p>=&gt; 第一步，打散区间，第二步，sequence 排 序，第三步，扫描，要是大于 1 就 return False</p>
<p>[lintcode 919] 给定一系列区间，代表一系列会议的时间间隔，求所需的最小的会议室数量。</p>
<p>=&gt; 在扫描过程中，记录扫描到的最大值</p>
<p>[lintcode 391] 给定 N 架飞机起飞降落的时间，求天上最多时有多少架飞机。</p>
<p>如果多架飞机降落起飞在同一时刻，我们认为先降落再起飞。</p>
<p>=&gt; 用 -1 代表降落， +1 代表起飞   </p>
</blockquote>
<p> 821  <a href="https://www.lintcode.com/problem/time-intersection/description" target="_blank" rel="noopener">https://www.lintcode.com/problem/time-intersection/description</a>  </p>
<p> 131  <a href="https://www.lintcode.com/problem/the-skyline-problem/description" target="_blank" rel="noopener">https://www.lintcode.com/problem/the-skyline-problem/description</a> </p>
<h3 id="动态维护区间"><a href="#动态维护区间" class="headerlink" title="动态维护区间"></a>动态维护区间</h3><p><a href="https://leetcode.com/problems/data-stream-as-disjoint-intervals/" target="_blank" rel="noopener">https://leetcode.com/problems/data-stream-as-disjoint-intervals/</a></p>
<p>Set hash</p>
<h2 id="Jump-Game2"><a href="#Jump-Game2" class="headerlink" title="Jump Game2"></a>Jump Game2</h2><p>leetcode 45</p>
<blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p><strong>Note:</strong> You can assume that you can always reach the last index.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次选择跳到能扩展范围最大的index</span></span><br><span class="line"><span class="comment">// BFS 记录下一层能到达的范围</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, curMax = <span class="number">0</span>, nextMax=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(curMax-i+<span class="number">1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        level++;</span><br><span class="line">        <span class="keyword">for</span>(; i&lt;=curMax; i++)&#123;</span><br><span class="line">            nextMax = max(nextMax,i+nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(nextMax&gt;=n<span class="number">-1</span>) <span class="keyword">return</span> level;</span><br><span class="line">        &#125;</span><br><span class="line">        curMax = nextMax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><blockquote>
<p>给定一个数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++ )</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i + <span class="number">1</span>; j ++ )</span><br><span class="line">        f[i][j] = -INF;</span><br><span class="line"></span><br><span class="line">f[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++ )</span><br><span class="line">        f[i][j] = max(f[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j], f[i - <span class="number">1</span>][j] + a[i][j]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = -INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = max(res, f[n][i]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<h3 id="Longest-common-subsequence-substring"><a href="#Longest-common-subsequence-substring" class="headerlink" title="Longest  common subsequence/substring"></a>Longest  common subsequence/substring</h3><p>Longest common substring of $S_1$ and $S_2$ :  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base case  lcs[i][-1] = 0   lcs[-1][j] = 0</span></span><br><span class="line"><span class="comment">// dp  iterate 0&lt;=i&lt;N 0&lt;=j&lt;M</span></span><br><span class="line"><span class="keyword">if</span>(S1[i]==S2[j]) lcs[i][j] = lcs[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span> lcs[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//result: max of lcs[i][j]  iterate 0&lt;=i&lt;N 0&lt;=j&lt;M</span></span><br></pre></td></tr></table></figure>
<p>Longest common subsequence of $S_1$ and $S_2$ :  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base case  lcs[i][-1] = 0 lcs[-1][j] = 0</span></span><br><span class="line"><span class="comment">// dp iterate 0&lt;=i&lt;N 0&lt;=j&lt;M</span></span><br><span class="line"><span class="keyword">if</span>(S1[i]==S2[j]) lcs[i][j] = lcs[i<span class="number">-1</span>,j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> lcs[i][j] = max(lcs[i][j<span class="number">-1</span>], lcs[i<span class="number">-1</span>][j])</span><br><span class="line"><span class="comment">// result: lcs[N][M]</span></span><br></pre></td></tr></table></figure>
<h3 id="Edit-Distance"><a href="#Edit-Distance" class="headerlink" title="Edit Distance"></a>Edit Distance</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base case</span></span><br><span class="line">ed[i][<span class="number">-1</span>] = i;  ed[<span class="number">-1</span>][j] = j;</span><br><span class="line"><span class="comment">// dp iterate 0&lt;=i&lt;N 0&lt;=j&lt;M</span></span><br><span class="line"><span class="keyword">if</span>(S1[i]==S2[j]) ed[i][j] = ed[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">else</span> ed[i][j] = min(min(ed[i<span class="number">-1</span>][j<span class="number">-1</span>],ed[i<span class="number">-1</span>][j]),ed[i][j<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// result: ed[N][M]</span></span><br></pre></td></tr></table></figure>
<h3 id="Longest-palindromic-subsequence"><a href="#Longest-palindromic-subsequence" class="headerlink" title="Longest palindromic subsequence"></a>Longest palindromic subsequence</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base case </span></span><br><span class="line">lps[i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// dp iterate 2&lt;=len&lt;=n   len: length of [i,j]  iterate i </span></span><br><span class="line"><span class="keyword">if</span>(s[i]==s[j] <span class="keyword">and</span> len==<span class="number">2</span>) lps[i][j] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[i]==s[j]) lps[i][j] = lps[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> lps[i][j] = max(lps[i+<span class="number">1</span>][j], lps[i][j<span class="number">-1</span>]);</span><br><span class="line"><span class="comment">// result: lps[0][n-1]</span></span><br></pre></td></tr></table></figure>
<h3 id="Longest-palindromic-substring"><a href="#Longest-palindromic-substring" class="headerlink" title="Longest palindromic substring"></a>Longest palindromic substring</h3><ul>
<li><p>$O(n^3)$ runtime, $O(1)$ space – Brute force:</p>
<p>The obvious brute force solution is to pick all possible starting and ending positions for a<br>substring, and verify if it is a palindrome. </p>
</li>
<li><p>$O(n^2)$ runtime, $O(n^2)$ space – Dynamic programming:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base case </span></span><br><span class="line">lps[i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// dp iterate 2&lt;=len&lt;=n   len: length of [i,j]</span></span><br><span class="line"><span class="keyword">if</span>(s[i]==s[j] <span class="keyword">and</span> len==<span class="number">2</span>) lps[i][j] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[i]==s[j]) lps[i][j] = lps[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> lps[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// result: max(lps[i][j]) iterate 0&lt;=i&lt;N 0&lt;=j&lt;N</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>$O(n^2)$ runtime, $O(1)$ space – Simpler solution:<br>In fact, we could solve it in $O(n^2)$ time using only constant space.<br>We observe that a palindrome mirrors around its center. Therefore, a palindrome can be<br>expanded from its center, and there are only 2n – 1 such centers.<br>You might be asking why there are 2n – 1 but not n centers? The reason is the center of a<br>palindrome can be in between two letters. Such palindromes have even number of letters<br>(such as “abba”) and its center are between the two ‘b’s.<br>Since expanding a palindrome around its center could take O(n) time, the overall<br>complexity is $O(n^2)$.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i);</span><br><span class="line">        <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">            start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            end = i + len / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">    <span class="keyword">while</span> (L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class="line">        L--;</span><br><span class="line">        R++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R - L - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>O(n) runtime, O(n) space – Manacher’s algorithm <a href="https://www.felix021.com/blog/read.php?2040" target="_blank" rel="noopener">https://www.felix021.com/blog/read.php?2040</a></p>
<blockquote>
<p>首先用一个非常巧妙的方式，将所有可能的奇数/偶数长度的回文子串都转换成了奇数长度：在每个字符的两边都插入一个特殊的符号。比如 abba 变成 #a#b#b#a#， aba变成 #a#b#a#。 为了进一步减少编码的复杂度，可以在字符串的开始加入另一个特殊字符，这样就不用特殊处理越界问题，比如$#a#b#a#（注意，下面的代码是用C语言写就，由于C语言规范还要求字符串末尾有一个’\0’所以正好OK，但其他语言可能会导致越界）</p>
<p>然后用一个数组 P[i] 来记录以字符S[i]为中心的最长回文子串向左/右扩张的长度（包括S[i]，也就是把该回文串“对折”以后的长度），比如S和P的对应关系</p>
<p>S  #  1  #  2  #  2  #  1  #  2  #  3  #  2  #  1  # </p>
<p>P  1   2  1  2  5  2  1  4  1  2  1   6  1  2  1  2  1 (p.s. 可以看出，P[i]-1正好是原字符串中回文串的总长度）</p>
<p>那么怎么计算P[i]呢？该算法增加两个辅助变量（其实一个就够了，两个更清晰）id和mx，其中 id 为已知的 {右边界最大} 的回文子串的中心，mx则为id+P[id]，也就是这个子串的右边界。  然后可以得到一个非常神奇的结论，这个算法的关键点就在这里了：如果mx &gt; i，那么P[i] &gt;= MIN(P[2 * id - i], mx - i)</p>
<p>实际上如果把它写得复杂一点，理解起来会简单很多：</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记j = 2 * id - i，也就是说 j 是 i 关于 id 的对称点(j = id - (i - id))</span></span><br><span class="line"><span class="keyword">if</span> (mx - i &gt; P[j]) </span><br><span class="line">    P[i] = P[j];</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* P[j] &gt;= mx - i */</span></span><br><span class="line">    P[i] = mx - i; <span class="comment">// P[i] &gt;= mx - i，取最小值，之后再匹配更新。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当 mx - i &gt; P[j] ，以S[j]为中心的回文子串包含在以S[id]为中心的回文子串中，由于 i 和 j 对称，以S[i]为中心的回文子串必然包含在以S[id]为中心的回文子串中，所以必有 P[i] = P[j]</li>
<li>当 P[j] &gt;= mx - i ，以S[j]为中心的回文子串不一定完全包含于以S[id]为中心的回文子串中，但是基于对称性可知，下图中两个绿框所包围的部分是相同的，也就是说以S[i]为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 P[i] &gt;= mx - i。至于mx之后的部分是否对称，就只能老老实实去匹配了。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入，并处理得到字符串s</span></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">1000</span>], mx = <span class="number">0</span>, id = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; s[i] != <span class="string">'\0'</span>; i++) &#123;</span><br><span class="line">    p[i] = mx &gt; i ? min(p[<span class="number">2</span>*id-i], mx-i) : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[i + p[i]] == s[i - p[i]]) p[i]++;</span><br><span class="line">    <span class="keyword">if</span> (i + p[i] &gt; mx) &#123;</span><br><span class="line">        mx = i + p[i];</span><br><span class="line">        id = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找出p[i]中最大的</span></span><br></pre></td></tr></table></figure>
<p>算法复杂度：<a href="https://segmentfault.com/a/1190000008484167" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008484167</a></p>
<h3 id="Longest-increasing-subsequence"><a href="#Longest-increasing-subsequence" class="headerlink" title="Longest increasing subsequence"></a>Longest increasing subsequence</h3><p><a href="https://leetcode.com/problems/longest-increasing-subsequence/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-increasing-subsequence/solution/</a></p>
<p>DP    $O(N^2)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lis[i] 所有以第i个数结尾的上升子序列   的长度的最大值</span></span><br><span class="line"><span class="comment">// 状态转移  以倒数第二个数分类</span></span><br><span class="line"><span class="comment">// base case + 初始化 iterate 0&lt;=i&lt;N</span></span><br><span class="line"><span class="comment">// lis[i] = 1;</span></span><br><span class="line"><span class="comment">// dp iterate 1&lt;=i&lt;N  0&lt;=j&lt;i</span></span><br><span class="line"><span class="comment">// if(num[j]&lt;nums[i]) lis[i] = max(lis[i], lis[j]+1);</span></span><br><span class="line"><span class="comment">// result: max(lis[0~N-1])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lis(n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[j]) lis[i] = max(lis[i], lis[j] + <span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        result =max(result, lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DP+ BS  $O(NlogN)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护DP数组，dp[i]为num[1:j]中使得递增序列长度为i+1的最小元素</span></span><br><span class="line"><span class="comment">// input: [0, 8, 4, 12, 2]</span></span><br><span class="line"><span class="comment">// dp: [0]</span></span><br><span class="line"><span class="comment">// dp: [0, 8]</span></span><br><span class="line"><span class="comment">// dp: [0, 4]</span></span><br><span class="line"><span class="comment">// dp: [0, 4, 12]</span></span><br><span class="line"><span class="comment">// dp: [0 , 2, 12] which is not the longest increasing subsequence, but length of dp array results in length of Longest Increasing Subsequence.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp; <span class="comment">// dp[i]为num[1:j]中使得递增序列长度为i+1的最小元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i ++)&#123;</span><br><span class="line">        <span class="comment">// 二分找到dp中&gt;=nums[i]的最小位置</span></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = dp.size();</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>( dp[mid] &lt; nums[i])&#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lo &lt; dp.size())&#123;</span><br><span class="line">            dp[lo] = nums[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Increasing-Triplet-Subsequence"><a href="#Increasing-Triplet-Subsequence" class="headerlink" title="Increasing Triplet Subsequence"></a>Increasing Triplet Subsequence</h3><p><a href="https://leetcode.com/problems/increasing-triplet-subsequence/" target="_blank" rel="noopener">https://leetcode.com/problems/increasing-triplet-subsequence/</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录当前最小的i和最小的j</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">increasingTriplet</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> minVal = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> minSecondVal = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;minSecondVal) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&gt;minVal) minSecondVal = nums[i]; <span class="comment">//minSecondVal only gets updated when there exists a minVal that comes before it.</span></span><br><span class="line">        <span class="keyword">else</span> minVal = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><a href="https://www.bilibili.com/video/av33930433?from=search&amp;seid=9210859877463751216" target="_blank" rel="noopener">https://www.bilibili.com/video/av33930433?from=search&amp;seid=9210859877463751216</a></p>
<p><a href="https://www.cnblogs.com/jbelial/articles/2116074.html" target="_blank" rel="noopener">https://www.cnblogs.com/jbelial/articles/2116074.html</a></p>
<h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><blockquote>
<p>有N件物品和一个容量为M的背包。第i件物品的体积是v[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大</p>
</blockquote>
<ul>
<li>每种物品仅有一件，可以选择放或不放</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f[i][j]表示只看前i件物品，总体积**刚**好为j时的最大价值</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line"><span class="comment">iterate i from 1 to N, j from 1 to M</span></span><br><span class="line"><span class="comment">f[i][j]:</span></span><br><span class="line"><span class="comment">      1.不选第i件物品，f[i][j]=f[i-1][j]</span></span><br><span class="line"><span class="comment">      2.选第i件物品，f[i][j]=w[i]+f[i-1][j-v[i]]  // 要判断 j&gt;=v[i]</span></span><br><span class="line"><span class="comment">f[i][j]= max(1,2)</span></span><br><span class="line"><span class="comment">-----------</span></span><br><span class="line"><span class="comment">初始化：f[i][j]=INT_MIN, f[i][0]=0,     0&lt;=i&lt;=N, 0&lt;=j&lt;=M</span></span><br><span class="line"><span class="comment">result = max(f[N][0-M])</span></span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"><span class="comment">时间复杂度：O(NM)</span></span><br><span class="line"><span class="comment">空间复杂度：O(NM)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">空间复杂度优化：O(M)</span></span><br><span class="line"><span class="comment">iterate i from 1 to N, j from M to v[i] //j逆序：为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f[i-1][v-c[i]]</span></span><br><span class="line"><span class="comment">f[j]:</span></span><br><span class="line"><span class="comment">      1.不选第i件物品，f[j]=f[j]</span></span><br><span class="line"><span class="comment">      2.选第i件物品，f[j]=w[i]+f[j-v[i]]  //j&gt;=v[i]</span></span><br><span class="line"><span class="comment">f[j]= max(1,2)</span></span><br><span class="line"><span class="comment">-----------</span></span><br><span class="line"><span class="comment">初始化： f[j]=INT_MIN   f[0]=0</span></span><br><span class="line"><span class="comment">result = max(f[0-M])</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><ul>
<li>每种物品有无穷多件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f[j]表示总体积刚好为j时的最大价值</span></span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"><span class="comment">iterate i from 1 to N, j from v[i] to M //j顺序：在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][j-v[i]]，所以就可以并且必须采用顺序循环</span></span><br><span class="line"><span class="comment">f[j]:</span></span><br><span class="line"><span class="comment">      1.不选第i件物品，f[j]=f[j]</span></span><br><span class="line"><span class="comment">      2.选第i件物品，f[j]=w[i]+f[j-v[i]]  //j&gt;=v[i]</span></span><br><span class="line"><span class="comment">f[j]= max(1,2) </span></span><br><span class="line"><span class="comment">------</span></span><br><span class="line"><span class="comment">初始化： f[j]=INT_MIN   f[0]=0</span></span><br><span class="line"><span class="comment">result = max(f[0-M])</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="coin-change"><a href="#coin-change" class="headerlink" title="coin change"></a>coin change</h4><p>Leetcode322</p>
<blockquote>
<p>You are given coins of different denominations and a total amount of money <em>amount</em>. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全背包 </span></span><br><span class="line"><span class="comment">// dp[i] 表示前j件硬币，每件硬币可选无数次，刚好组成amout的选法  的最小值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = coins.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount+<span class="number">1</span>,INT_MAX);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=amount; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(coins[j]&lt;=i <span class="keyword">and</span> dp[i-coins[j]]!=INT_MAX)&#123;</span><br><span class="line">                    dp[i] = min(dp[i], dp[i-coins[j]]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount]==INT_MAX? <span class="number">-1</span>:dp[amount];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><ul>
<li>第i种物品最多有n[i]件可用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f[j]表示总体积刚好为j时的最大价值</span></span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"><span class="comment">iterate i from 1 to N, j from M to 0, k from 0 to (k*v[i]&lt;=j,k&lt;=n[i]) </span></span><br><span class="line"><span class="comment">f[j] = max(f[j-k*v[i]]+k*w[i])</span></span><br><span class="line"><span class="comment">------</span></span><br><span class="line"><span class="comment">初始化： f[j]=INT_MIN   f[0]=0</span></span><br><span class="line"><span class="comment">result = max(f[0-M])</span></span><br><span class="line"><span class="comment">------</span></span><br><span class="line"><span class="comment">时间复杂度：O(N*sum(n[i]))</span></span><br><span class="line"><span class="comment">空间复杂度：O(M)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二进制优化方法</span></span><br><span class="line"><span class="comment">将多重背包拆成二进制的01背包  倍增思想</span></span><br><span class="line"><span class="comment">7 = 4 + 2 + 1</span></span><br><span class="line"><span class="comment">10 = 4 + 2 + 1 + 3</span></span><br><span class="line"><span class="comment">iterate i from 1 to N, iterate k from 1 to (k&lt;=n[i],k*=2)  </span></span><br><span class="line"><span class="comment">添加物体(体积为k,价值为k*w[i]), n[i]-=k;</span></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"><span class="comment">if(n[i]&gt;0) 添加物体(体积为n[i],价值为n[i]*w[i])</span></span><br><span class="line"><span class="comment">转化为01背包问题</span></span><br><span class="line"><span class="comment">-----------------------</span></span><br><span class="line"><span class="comment">时间复杂度：O(M*sum(log(n[i])))</span></span><br><span class="line"><span class="comment">空间复杂度：O(M*sum(log(n[i])))</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">单调队列优化 O(MN)</span></span><br><span class="line"><span class="comment">&lt;男人八题，楼天城&gt;</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line"><span class="comment">// f[v] = max(f[v-v[i]]+w[i],f[v-2*v[i]]+2*w[i],...f[v-k*v[i]]+k*w[i]</span></span><br><span class="line"><span class="comment">// f[v+v[i]] = max(f[v]+w[i], f[v-v[i]]+2*w[i],...)</span></span><br><span class="line"><span class="comment">// 将f按照%v[i]的值分为v[i]类，每一类是独立的</span></span><br><span class="line"><span class="comment">itertate i from 1 to N</span></span><br><span class="line"><span class="comment">   g = f；</span></span><br><span class="line"><span class="comment">   iterate j from 0 to v[i]-1</span></span><br><span class="line"><span class="comment">       deque&lt;int&gt; q // 单调递减队列</span></span><br><span class="line"><span class="comment">       iterate v from j to M(v+=v[i])</span></span><br><span class="line"><span class="comment">          f[v] = g[v]；</span></span><br><span class="line"><span class="comment">          if(!q.empty() and v - v[i]*n[i] &gt; q.front()) q.pop_front()</span></span><br><span class="line"><span class="comment">          if(!q.empty()) f[v] = max(f[v], g[q.front()]+(v-q.front())/v[i]*w[i]);</span></span><br><span class="line"><span class="comment">          while(!q.empty() and g[q.front()]-(q.front()-j)/v[i]*w[i] &lt;= g[v] - (v-j)/v[i]*w[i]) q.pop_back();</span></span><br><span class="line"><span class="comment">          q.push_back(k);</span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment">(经典单调队列问题，sliding window maximum,差分)</span></span><br><span class="line"><span class="comment">对每个j, 单调下降队列按f[v]-k*w[i]排序</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h3><ul>
<li>有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">n[i]: -1(只能取1次)  0(无限次)  &gt;0(多重)</span></span><br><span class="line"><span class="comment">首先多重背包拆成01背包=&gt; 01背包+完全背包</span></span><br><span class="line"><span class="comment">iterate i from 1 to N*(拆解后的物品总数) //对每个物品采用不同的转移方式</span></span><br><span class="line"><span class="comment">if(01背包) j逆序</span></span><br><span class="line"><span class="comment">if(完全背包) j顺序</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h3><ul>
<li>对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">背包体积M，承重G</span></span><br><span class="line"><span class="comment">f[j][k]: 体积为j,重量为k的最大价值  01背包</span></span><br><span class="line"><span class="comment">------</span></span><br><span class="line"><span class="comment">iterate i from 1 to N, j from M to v[i], k from G to g[i]</span></span><br><span class="line"><span class="comment">f[j][k] = max(f[j][k],f[j-v[i]][k-g[i]]+w[i])</span></span><br><span class="line"><span class="comment">-----</span></span><br><span class="line"><span class="comment">初始化f[j][k]=INT_MIN, f[0][0]=0</span></span><br><span class="line"><span class="comment">result = max(f[0-M][0-G])</span></span><br><span class="line"><span class="comment">-----</span></span><br><span class="line"><span class="comment">时间复杂度：O(NMG)</span></span><br><span class="line"><span class="comment">空间复杂度：O(MG)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><ul>
<li>这些物品被划分为若干组，每组中的物品互相冲突，最多选一件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">每组物品有若干决策：全不选or选择任意一件物品// 多重背包是分组背包的特殊情况，打包选一件，两件，...的情况</span></span><br><span class="line"><span class="comment">N:物品组，M:背包容量</span></span><br><span class="line"><span class="comment">每个物品组：S[i]:第i组内物品数量</span></span><br><span class="line"><span class="comment">v[i][k]，w[i][k]:第i组第k件物品的体积，价值</span></span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"><span class="comment">iterate i from 1 to N, j from M to 0, k from 0 to S[i]-1</span></span><br><span class="line"><span class="comment">if(j&gt;=v[i][k]) f[j]=max(f[j],f[j-v[i][k]]+w[i][k])</span></span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"><span class="comment">初始化：f[j]=INT_MIN, f[0]=0</span></span><br><span class="line"><span class="comment">result = max(f[0-M])</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><blockquote>
<p>设有N堆石子排成一排，其编号为1，2，3，…，N。</p>
<p>每堆石子有一定的质量，可以用一个整数来描述，现在要将这N堆石子合并成为一堆。</p>
<p>每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。</p>
<p>找出一种合理的方法，使总的代价最小，输出最小代价。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有将第i堆石子到第j堆石子合并到一堆的方式 的代价的最小值</span></span><br><span class="line"><span class="comment">// 状态转移 按照最后一次合并的分界线分类</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;s[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) s[i] += s[i - <span class="number">1</span>]; <span class="comment">// 前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len ++ ) <span class="comment">// 循环长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i ++ ) <span class="comment">// 循环左端点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = i, r = i + len - <span class="number">1</span>;</span><br><span class="line">        f[l][r] = <span class="number">1e8</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt; r; k ++ )</span><br><span class="line">            f[l][r] = min(f[l][r], f[l][k] + f[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[<span class="number">1</span>][n]);</span><br></pre></td></tr></table></figure>
<h2 id="计数类DP"><a href="#计数类DP" class="headerlink" title="计数类DP"></a>计数类DP</h2><h3 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h3><blockquote>
<p>一个正整数n可以表示成若干个正整数之和，形如：$n=n_1+n_2+…+n_k=n_1+n_2+…+n_k$，其中$n_1≥n_2≥…≥n_k,k≥1,n_1≥n_2≥…≥n_k,k≥1$。</p>
<p>我们将这样的一种表示称为正整数n的一种划分。</p>
<p>现在给定一个正整数n，请你求出n共有多少种不同的划分方法</p>
<p>由于答案可能很大，输出结果请对10^9+7取模。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全背包</span></span><br><span class="line"><span class="comment">// f[i][j] 表示从1~i中选，和恰好为j的选法  的数量</span></span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j ++ )</span><br><span class="line">        f[j] = (f[j] + f[j - i]) % mod;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------</span></span><br><span class="line"><span class="comment">// f[i][j] 表示，和为i, 并且恰好表示为i个数的选法  的数量</span></span><br><span class="line"><span class="comment">// f[i][j] 的选法分为  最小值是1 和  最小值大于1 </span></span><br><span class="line"><span class="comment">// f[i][j] = f[i-1][j-1] + f[i-j][j]</span></span><br><span class="line"><span class="comment">// ans = f[n][1] + f[n][2] + ... f[n][n]</span></span><br><span class="line">f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++ )</span><br><span class="line">        f[i][j] = (f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - j][j]) % mod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = (res + f[n][i]) % mod;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="coin-change2"><a href="#coin-change2" class="headerlink" title="coin change2"></a>coin change2</h3><blockquote>
<p>You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全背包</span></span><br><span class="line"><span class="comment">// array中元素的值互异，每个元素可无限次取  从中选出任意个数|  返回组合种数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(amount+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j:coins)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=amount; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line">                f[i] += f[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;i&lt;&lt;" "&lt;&lt;f[i]&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Combination-Sum-IV"><a href="#Combination-Sum-IV" class="headerlink" title="Combination Sum IV"></a>Combination Sum IV</h3><blockquote>
<p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>
</blockquote>
<p><strong>array中元素的值互异，每个元素可无限次取 从中选出任意个数|  返回排列的种数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合：先循环每个元素，再循环target     元素的顺序固定</span></span><br><span class="line"><span class="comment">// 排列：先循环target, 再循环每个元素     元素的顺序不固定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(target+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=target; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j:nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(INT_MAX-f[i]&lt;=f[i-j])&#123; <span class="comment">// 防止中间的f[i]溢出</span></span><br><span class="line">                        f[i] = INT_MAX;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        f[i] += f[i-j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;i&lt;&lt;" "&lt;&lt;f[i]&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[target];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h2><h3 id="计数问题"><a href="#计数问题" class="headerlink" title="计数问题"></a>计数问题</h3><blockquote>
<p>给定两个整数 a 和 b，求 a 和 b 之间的所有数字中0~9的出现次数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// count(n,x) 1~n中x出现的次数</span></span><br><span class="line"><span class="comment">// [a,b]中x出现的次数 = count(b,x) - count(a-1,x)</span></span><br></pre></td></tr></table></figure>
<h3 id="No-Nine"><a href="#No-Nine" class="headerlink" title="No Nine"></a>No Nine</h3><h2 id="鸡蛋问题"><a href="#鸡蛋问题" class="headerlink" title="鸡蛋问题"></a>鸡蛋问题</h2><blockquote>
<p>一幢 100 层的大楼,给你两个鸡蛋. 如果在第 n 层扔下鸡蛋,鸡蛋不碎,那么从前 n-1 层扔鸡蛋都不碎. 这两只鸡蛋一模一样，不碎的话可以扔无数次. 已知鸡蛋在0层扔不会碎. 提出一个策略, 要保证能测出鸡蛋恰好不会碎的楼层, 并使此策略在<strong>最坏</strong>情况下所扔次数<strong>最少</strong>.</p>
</blockquote>
<p><a href="http://datagenetics.com/blog/july22012/index.html" target="_blank" rel="noopener">http://datagenetics.com/blog/july22012/index.html</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有n层楼，2个鸡蛋</span></span><br><span class="line"><span class="comment">// f[i]  表示i层楼, 2个鸡蛋，没有摔碎的最少尝试次数  f[0] = 0  </span></span><br><span class="line">itertate i from <span class="number">1</span> to n, j from <span class="number">1</span> to i</span><br><span class="line"><span class="comment">// f[i]   决策：从第j层扔第一个鸡蛋， 1&lt;=j&lt;=i 决策的最小值，对决策取最小  </span></span><br><span class="line"><span class="comment">//        情况： 第一个鸡蛋碎了，则第二个鸡蛋，需要从第一层开始试验，还需要扔j-1次</span></span><br><span class="line"><span class="comment">//              第一个鸡蛋没碎，则还有i-j层，还需要扔f[i-j]次</span></span><br><span class="line"><span class="comment">//        情况最坏，对情况取最大值</span></span><br><span class="line">f[i] = min(<span class="number">1</span> + max(j - <span class="number">1</span>, f[i - j]))</span><br><span class="line"><span class="comment">// ---------------------------------------</span></span><br><span class="line"><span class="comment">// 假设有n层楼，m个鸡蛋</span></span><br><span class="line"><span class="comment">// f[i][j]  表示i层楼, j个鸡蛋，没有摔碎的最少尝试次数  f[0][j] = 0  f[i][1] = i</span></span><br><span class="line">itertate i from <span class="number">1</span> to n, j from <span class="number">2</span> to m</span><br><span class="line"><span class="comment">// f[i][j]   决策：从第k层扔第一个鸡蛋， 1&lt;=k&lt;=i 决策的最小值，对决策取最小  </span></span><br><span class="line"><span class="comment">//        情况： 第一个鸡蛋碎了，则还有k-1层，j-1个鸡蛋，还需要扔f[k-1][j-1]次</span></span><br><span class="line"><span class="comment">//              第一个鸡蛋没碎，则还有i-k层, j个鸡蛋，还需要扔f[i-k][j]次</span></span><br><span class="line"><span class="comment">//        情况最坏，对情况取最大值</span></span><br><span class="line">f[i][j] = min(<span class="number">1</span> + max(f[k - <span class="number">1</span>][j - <span class="number">1</span>], f[i - k][j]))</span><br></pre></td></tr></table></figure>
<p><strong>Remember we need to mimimize the number of drops in the worst case, so we take the higher (max) of these two situations, and select the floor which yields the minimum number of drops.</strong></p>
<blockquote>
<p> 基于数学方程的方法 </p>
<p>假设最少尝试次数为x，那么，第一个鸡蛋必须要从第x层扔下，因为：如果碎了，前面还有x - 1层楼可以尝试，如果没碎，后面还有x-1次机会。如果没碎，第一个鸡蛋，第二次就可以从x +（x - 1）层进行尝试，为什么是加上x - 1，因为，当此时，第一个鸡蛋碎了，第二个鸡蛋还有可以从x+1 到 x + (x - 1) - 1层进行尝试，有x - 2次。如果还没碎，那第一个鸡蛋，第三次从 x + (x - 1) + (x - 2)层尝试。碎或者没碎，都有x - 3次尝试机会，依次类推。那么，x次的最少尝试，可以确定的最高的楼层是多少呢？ x + (x - 1) + (x - 2) + … + 1 = x(x+1) / 2 那反过来问，当最高楼层是100层，最少需要多少次呢？x(x+1)/2 &gt;= 100, 得到x&gt;=14，最少要尝试14次。</p>
</blockquote>
<h2 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h2><p>状态</p>
<ul>
<li>天数 i</li>
<li>交易次数限制 k</li>
<li>当前是否持有股票 </li>
</ul>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/</a></p>
<h2 id="最大子区间求和"><a href="#最大子区间求和" class="headerlink" title="最大子区间求和"></a>最大子区间求和</h2><h3 id="最大子区间求和-1"><a href="#最大子区间求和-1" class="headerlink" title="最大子区间求和"></a>最大子区间求和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the contiguous subarray within an array (containing at least one number) that has the largest sum.</span></span><br><span class="line"><span class="comment">// 动态规划 </span></span><br><span class="line"><span class="comment">// 状态定义：f(k) = Maximum sum of subarray ending at index k.</span></span><br><span class="line"><span class="comment">// 状态转移： f(k) = max( f(k-1) + A[k], A[k] ) </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_sub_array</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> max_ending_here = A[<span class="number">0</span>], max_so_far = A[<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.size(); i++) &#123; </span><br><span class="line">        max_ending_here = max(max_ending_here + A[i], A[i]); </span><br><span class="line">        max_so_far = max(max_ending_here, max_so_far); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> max_so_far; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大子区间求积"><a href="#最大子区间求积" class="headerlink" title="最大子区间求积"></a>最大子区间求积</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the contiguous subarray within an array(containing at least one number) of integers that has the largest product.</span></span><br><span class="line"><span class="comment">// f(k) = Largest product subarray, from index 0 up to k.</span></span><br><span class="line"><span class="comment">// g(k) = Smallest product subarray, from index 0 up to k.</span></span><br><span class="line"><span class="comment">// f(k) = max( f(k-1) * A[k], A[k], g(k-1) * A[k] )</span></span><br><span class="line"><span class="comment">// g(k) = min( g(k-1) * A[k], A[k], f(k-1) * A[k] )</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> maxP = A[<span class="number">0</span>], minP = A[<span class="number">0</span>], maxAns = A[<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> mx = maxP, mn = minP;</span><br><span class="line">        maxP = max(max(A[i], mx * A[i]), mn * A[i]);</span><br><span class="line">        minP = min(min(A[i], mx * A[i]), mn * A[i]);</span><br><span class="line">        maxAns = max(max, maxAns); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> maxAns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Maximum-Sum-Circular-Subarray"><a href="#Maximum-Sum-Circular-Subarray" class="headerlink" title="Maximum Sum Circular Subarray"></a>Maximum Sum Circular Subarray</h3><p><a href="https://leetcode.com/problems/maximum-sum-circular-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-sum-circular-subarray/</a></p>
<p><a href="https://leetcode.com/problems/maximum-sum-circular-subarray/discuss/178422/One-Pass" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-sum-circular-subarray/discuss/178422/One-Pass</a></p>
<p><img src="https://assets.leetcode.com/users/motorix/image_1538888300.png" alt="image"></p>
<p>So the max subarray circular sum equals to<br><code>max(the max subarray sum, the total sum - the min subarray sum)</code></p>
<p>One <strong>corner case</strong>  to pay attention:</p>
<p>If all number are negative,<br>return the maximum one,<br>(which equals to the max subarray sum)</p>
<p>(因为case2必须要保证MinSubarray是真subarray,从而保证有对应的MaxSubarray存在，假设MinSubarray即为整个subarray,则the total sum - the min subarray sum==0，只要array不是全部非负，则the max subarray sum必然大于等于0)</p>
<h3 id="最大子矩阵求和"><a href="#最大子矩阵求和" class="headerlink" title="最大子矩阵求和"></a>最大子矩阵求和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 矩阵中子矩阵最大和</span></span><br><span class="line"><span class="comment">// 预处理每一行 从0-j列的前缀和</span></span><br><span class="line"><span class="comment">// 1) 枚举j1,j2列，枚举i1,i2 O(N^4)</span></span><br><span class="line"><span class="comment">// 2) 枚举j1,j2列, 转化为最大子区间求和  O(N^3)</span></span><br></pre></td></tr></table></figure>
<h3 id="两个不重叠子区间最大和"><a href="#两个不重叠子区间最大和" class="headerlink" title="两个不重叠子区间最大和"></a>两个不重叠子区间最大和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到两个不相交的子区间A,B 使得sumA+sumB最大</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_max_sum</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s1(n,<span class="number">0</span>); <span class="comment">// s1[i]表示以a[0:i+1]的最大子区间</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s2(n,<span class="number">0</span>); <span class="comment">// s2[i]表示以a[i:n]的最大子区间</span></span><br><span class="line">    s1[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max_ending_here = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">		max_ending_here = max(max_ending_here+a[i], a[i]);</span><br><span class="line">        s1[i] = max(max_ending_here, s1[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    s2[n<span class="number">-1</span>] = a[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> max_begin_here = a[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        max_begin_here = max(max_begin_here+a[i], a[i]);</span><br><span class="line">        s2[i] = max(max_begin_here, s2[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++) ans  = max(ans, s1[i]+s2[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="固定长度，k个不重叠子区间最大和"><a href="#固定长度，k个不重叠子区间最大和" class="headerlink" title="固定长度，k个不重叠子区间最大和"></a>固定长度，k个不重叠子区间最大和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 2 3 4 5 6 5 4 3 2 1 10</span></span><br><span class="line"><span class="comment">// find 3 sub lenght=K seq, no overlap, make the sum of 3*K number max.  </span></span><br><span class="line"><span class="comment">// 1. O (N^3) 前缀和，ijk枚举三段</span></span><br><span class="line"><span class="comment">// 2. O (N)  </span></span><br><span class="line"><span class="comment">// f(i,1) 1~i </span></span><br><span class="line"><span class="comment">// f(i,2) 1~i = max(f(i-1,2),f(i-k,1)+s[i]-s[i-k]) </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">function</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> k = <span class="number">3</span>)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">int</span> n = a.size();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; f(<span class="number">4</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));<span class="comment">// 下标从1开始</span></span><br><span class="line">  	<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; s(n+<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 下标从1开始</span></span><br><span class="line">  	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) s[i] = s[i<span class="number">-1</span>] + a[i<span class="number">-1</span>]; <span class="comment">//s[i] = a[0] + ... + a[i-1]</span></span><br><span class="line">  	<span class="comment">// f[j][i]: [1, i]  </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=k; i&lt;=n; i++)</span><br><span class="line">    	f[<span class="number">1</span>][i] = max(f[<span class="number">1</span>][i<span class="number">-1</span>], s[i]-s[i-k]); </span><br><span class="line">  	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>*k; i&lt;=n; i++)</span><br><span class="line">    	f[<span class="number">2</span>][i] = max(f[<span class="number">2</span>][i<span class="number">-1</span>], f[<span class="number">1</span>][i-k]+s[i]-s[i-k]);</span><br><span class="line">  	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">3</span>*k; i&lt;=n; i++)</span><br><span class="line">    	f[<span class="number">3</span>][i] = max(f[<span class="number">3</span>][i<span class="number">-1</span>], f[<span class="number">2</span>][i-k]+s[i]-s[i-k]);</span><br><span class="line">  	<span class="keyword">return</span> f[<span class="number">3</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h1><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p><strong>越早被访问到的顶点，其邻居结点优先被访问</strong></p>
<p>广度优先搜索的通常用法是指定一个source,广度优先的遍历这个source所能到达的所有节点。<strong>相关的算法有：Prim’s minimum-spanning- tree algorithm and Dijkstra’s single-source shortest-paths algorithm </strong></p>
<h3 id="多源BFS"><a href="#多源BFS" class="headerlink" title="多源BFS"></a>多源BFS</h3><p><a href="https://leetcode.com/problems/01-matrix/" target="_blank" rel="noopener">https://leetcode.com/problems/01-matrix/</a></p>
<p>Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多源BFS</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; updateMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">-1</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; move = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    res[i][j]=<span class="number">0</span>;</span><br><span class="line">                    q.push(make_pair(i,j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> ux = q.front().first;</span><br><span class="line">            <span class="keyword">int</span> uy = q.front().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;move.size(); i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> vx = ux+move[i].first;</span><br><span class="line">                <span class="keyword">int</span> vy = uy+move[i].second;</span><br><span class="line">                <span class="keyword">if</span>(vx&gt;=<span class="number">0</span> <span class="keyword">and</span> vx&lt;m <span class="keyword">and</span> vy&gt;=<span class="number">0</span> <span class="keyword">and</span> vy&lt;n <span class="keyword">and</span> res[vx][vy]==<span class="number">-1</span>)&#123;</span><br><span class="line">                    res[vx][vy] = res[ux][uy]+<span class="number">1</span>;</span><br><span class="line">                    q.push(make_pair(vx,vy));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度$O(V+E)$</p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p><strong>优先选取最后一个被访问到的顶点的邻居</strong></p>
<p>​                  数据结构         空间复杂度  </p>
<p>BFS            queue               O(n)              最短路(边的距离为1)</p>
<p>DFS              stack                树的高度     不具有最短性</p>
<p>DP 有向无环图的最短路</p>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p><strong>恢复现场</strong>    <strong>注意搜索的顺序</strong></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95</a></p>
<p><strong>回溯法</strong>（英语：backtracking）是暴力搜索中的一种。</p>
<p>对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。</p>
<p>回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p>
<ul>
<li><strong>找到一个存在的正确的答案</strong></li>
<li><strong>在尝试了所有可能的分步方法后宣告该问题没有答案</strong></li>
</ul>
<p>在最坏的情况下，回溯法会导致一次复杂度为<strong>指数时间</strong>的计算</p>
<ul>
<li>剪枝：最优性剪枝  可行性剪枝</li>
</ul>
<h4 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h4><p>N=1或N&gt;=4才有解</p>
<p>搜索方式1：按行枚举放置的列数</p>
<p>搜索方式2：按格子枚举放置或者不放置 </p>
<p><a href="https://www.acwing.com/activity/content/code/content/47097/" target="_blank" rel="noopener">https://www.acwing.com/activity/content/code/content/47097/</a></p>
<p><strong>NOTE:</strong> Please don’t use <code>vector&lt;bool&gt; flag</code> to replace <code>vector&lt;int&gt; flag</code> in the following C++ code. In fact, <code>vector&lt;bool&gt;</code> is not a STL container. You should avoid to use it. You can also get the knowledge from <a href="http://stackoverflow.com/questions/17794569/why-is-vectorbool-not-a-stl-container" target="_blank" rel="noopener">here</a> and <a href="http://stackoverflow.com/questions/670308/alternative-to-vectorbool" target="_blank" rel="noopener">here</a>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用flag标志f the column or the diagonal had a queen before, if not, we can put a queen in this position and continue.</span></span><br><span class="line"><span class="comment">// col x=b    b=x   [0,n-1]    </span></span><br><span class="line"><span class="comment">// 45 y=x+b   b=x-y [1-n,n-1]+(n-1)  [0,2n-2]</span></span><br><span class="line"><span class="comment">// 135 y=x-b   b=x+y [0,2n-2]</span></span><br><span class="line"><span class="comment">// 按行枚举放置皇后的列数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;sstring&gt; &gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; nQueens(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; flag_col(n, <span class="number">1</span>), flag_45(<span class="number">2</span> * n - <span class="number">1</span>, <span class="number">1</span>), flag_135(<span class="number">2</span> * n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        solveNQueens(res, nQueens, flag_col, flag_45, flag_135, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveNQueens</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;nQueens, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;flag_col, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;flag_45, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;flag_135, <span class="keyword">int</span> row, <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;<span class="comment">//找到一个存在的正确答案</span></span><br><span class="line">            res.push_back(nQueens);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col != n; ++col)</span><br><span class="line">            <span class="keyword">if</span> (flag_col[col] &amp;&amp; flag_45[row + col] &amp;&amp; flag_135[n - <span class="number">1</span> + col - row]) &#123;</span><br><span class="line">                flag_col[col] = flag_45[row + col] = flag_135[n - <span class="number">1</span> + col - row] = <span class="number">0</span>;</span><br><span class="line">                nQueens[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">                solveNQueens(res, nQueens, flag_col, flag_45, flag_135, row + <span class="number">1</span>, n);</span><br><span class="line">                nQueens[row][col] = <span class="string">'.'</span>;</span><br><span class="line">                flag_col[col] = flag_45[row + col] = flag_135[n - <span class="number">1</span> + col - row] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="comment">// else 没有答案，剪枝</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Partition-to-K-Equal-Sum-Subsets"><a href="#Partition-to-K-Equal-Sum-Subsets" class="headerlink" title="Partition to K Equal Sum Subsets"></a>Partition to K Equal Sum Subsets</h4><p>leetcode 698</p>
<p><a href="https://www.geeksforgeeks.org/partition-set-k-subsets-equal-sum/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/partition-set-k-subsets-equal-sum/</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="图论基本概念"><a href="#图论基本概念" class="headerlink" title="图论基本概念"></a>图论基本概念</h2><p>边：无向边  有向边(更普适，无向边可以等价转换为有向边） </p>
<ul>
<li>只含有向边的图：有向图  </li>
<li>只含无向边的图：无向图</li>
<li>同时包含有向边和无向边的图：混合图 </li>
</ul>
<p>度： 无向图中与顶点v关联的边数</p>
<p>出度，入度：   有向图中的出边总数和入边总数</p>
<p>自环：连接于同一顶点的边</p>
<p>简单图：不包含自环的图</p>
<p>通路（Path）: 由m+1个顶点和m条边交替而成的序列：$\pi = \{v_0,e_1,v_1,e_2,v_2,…,e_m,v_m\} $</p>
<p>且对任何0&lt;i&lt;=m都有$e_i=(v_{i-1},v_i)$,即这些边依次首尾相连</p>
<ul>
<li>通路上的边必须互异，但顶点可能重复</li>
<li>沿途顶点互异的通路，成为<strong>简单通路</strong></li>
<li>对于m&gt;=1的通路，若起止点相同，则称为<strong>环路</strong></li>
<li>不含任何环路的有向图称为<strong>有向无环图</strong></li>
<li>除起止点外，沿途其他点均互异的环路称为<strong>简单环路</strong></li>
<li>经过图中各边一次且恰好一次的环路称为<strong>欧拉环路</strong></li>
<li>经过图中各点一次且恰好一次的环路称为<strong>哈密尔顿环路</strong></li>
</ul>
<p>带权图（边有权重） 无权图</p>
<p>邻接矩阵 邻接表       (v,v)  描述一对顶点之间可能存在的邻接关系</p>
<p>关联矩阵                    (v,e) 描述顶点与边之间可能存在的关联关系</p>
<h2 id="树和图的深度-广度优先遍历"><a href="#树和图的深度-广度优先遍历" class="headerlink" title="树和图的深度/广度优先遍历"></a>树和图的深度/广度优先遍历</h2><h3 id="树的深度优先遍历"><a href="#树的深度优先遍历" class="headerlink" title="树的深度优先遍历"></a>树的深度优先遍历</h3><ul>
<li>访问到一个新的节点时，该节点的子节点一定都是没有访问的，因此简单的递归调用即可实现</li>
</ul>
<p>二叉树的深度优先搜索可分为：</p>
<p>前序遍历：根结点 —-&gt; 左子树 —-&gt; 右子树</p>
<p>中序遍历：左子树—-&gt; 根结点 —-&gt; 右子树</p>
<p>后序遍历：左子树 —-&gt; 右子树 —-&gt; 根结点</p>
<p>图的深度优先搜索按各顶点被访问到的次序类似树的前序遍历；按各顶点访问结束的次序类似树的后序遍历</p>
<h4 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h4><p><a href="https://www.acwing.com/activity/content/problem/content/909/1/" target="_blank" rel="noopener">https://www.acwing.com/activity/content/problem/content/909/1/</a></p>
<p>// dfs返回子树的大小size1,size2,其余为n-size1-size2-1</p>
<h3 id="图的深度优先遍历"><a href="#图的深度优先遍历" class="headerlink" title="图的深度优先遍历"></a>图的深度优先遍历</h3><ul>
<li>访问到一个新的节点时，该节点的相邻节点可能已经访问过，已访问过的节点不用再访问</li>
</ul>
<blockquote>
<p>It may seem arbitrary that <strong>breadth-first search is limited to only one source whereas depth-first search may search from multiple sources</strong>. Although conceptually, breadth-first search could proceed from multiple sources and depth-first search could be limited to one source, our approach reflects how the results of these searches are typically used. <strong>Breadth-first search usually serves to find shortest- path distances (and the associated predecessor subgraph) from a given source. Depth-first search is often a subroutine in another algorithm, as we shall see later in this chapter</strong>. </p>
</blockquote>
<p>时间复杂度$O(V+E)$ </p>
<p><strong>Parenthesis theorem</strong></p>
<p>In any depth-first search of a (directed or undirected) graph $G+(V, E)$, for any two vertices $u$ and $v$ 􏰍, exactly one of the following three conditions holds:  </p>
<p>要么完全包含要么完全不重叠（不存在重叠一部分的情况）</p>
<ul>
<li>the intervals $[u.d, u.f]$ and $[v.d, v.f]$ are entirely disjoint, and neither $u$ nor $v$ 􏰍 is a descendant of the other in the depth-first forest </li>
<li>the interval $[u.d, u.f]$ is contained entirely within the interval $[v.d, v.f]$ ,and $u$ is a descendant of 􏰍$v$ in a depth-first tree, or </li>
<li>the interval $[v.d, v.f]$ is contained entirely within the interval  $[u.d, u.f]$􏰌, and 􏰍$v$  is a descendant of $u$ in a depth-first tree. </li>
</ul>
<p><strong>Classification of edges</strong></p>
<p>We can define four edge types in terms of the depth-first forest $G_\pi$􏰂 produced by a depth-first search on $G$: </p>
<ul>
<li><strong>Tree edges</strong> are edges in the depth-first forest $G_\pi$􏰂. Edge$(u,v)$ is a tree edge if􏰍 $v$ was first discovered by exploring edge$(u, v)$.  </li>
<li><strong>Back edges</strong> are those edges$(u, v)$ connecting a vertex $u$ to an ancestor $v$ 􏰍 in a depth-first tree. We consider self-loops, which may occur in directed graphs, to be back edges. </li>
<li><strong>Forward edges</strong> are those nontree edges$(u, v)$ connecting a vertex $u$ to a descendant 􏰍$v$ in a depth-first tree. </li>
<li><strong>Cross edges</strong> are all other edges. They can go between vertices in the same depth-first tree, as long as one vertex is not an ancestor of the other, or they can go between vertices in different depth-first trees. </li>
</ul>
<p>The DFS algorithm has enough information to classify some edges as it encounters them. The key idea is that when we first explore an edge$(u, v)$, the color of vertex $v$􏰍 tells us something about the edge: </p>
<ol>
<li>WHITE indicates a tree edge, </li>
<li>GRAY indicates a back edge, and </li>
<li>BLACK indicates a forward or cross edge. (edge $(u, v)$ is a forward edge if $u.d &lt; v.d$ and a cross edge if $u.d &gt; v.d$. )</li>
</ol>
<p><strong>无向图</strong>：</p>
<p>An undirected graph may entail some ambiguity in how we classify edges, since $(u, v)$ and $(v， u)$ are really the same edge. In such a case, we classify the edge as the first type in the classification list that applies. Equivalently, we classify the edge according to whichever of $(u, v)$ or $(v， u)$ the search encounters first. </p>
<p><strong>In a depth-first search of an undirected graph G, every edge of G is either a tree edge or a back edge. </strong></p>
<h4 id="Find-Eventual-Safe-States"><a href="#Find-Eventual-Safe-States" class="headerlink" title="Find Eventual Safe States"></a>Find Eventual Safe States</h4><p><a href="https://leetcode.com/problems/find-eventual-safe-states/" target="_blank" rel="noopener">https://leetcode.com/problems/find-eventual-safe-states/</a></p>
<p><a href="https://leetcode.com/problems/find-eventual-safe-states/discuss/119871/Straightforward-Java-solution-easy-to-understand!" target="_blank" rel="noopener">https://leetcode.com/problems/find-eventual-safe-states/discuss/119871/Straightforward-Java-solution-easy-to-understand!</a></p>
<p>value of color represents three states:<br>0:have not been visited<br>1:safe<br>2:unsafe<br>For DFS,we need to do some optimization.When we travel a path,we mark the node with 2 which represents having been visited,and when we encounter a node which results in a cycle,we return false,all node in the path stays 2 and it represents unsafe.And in the following traveling,whenever we encounter a node which points to a node marked with 2,we know it will results in a cycle,so we can stop traveling.On the contrary,when a node is safe,we can mark it with 1 and whenever we encounter a safe node,we know it will not results in a cycle.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">eventualSafeNodes</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(graph == <span class="keyword">null</span> || graph.length == <span class="number">0</span>)  <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> nodeCount = graph.length;</span><br><span class="line">        <span class="keyword">int</span>[] color = <span class="keyword">new</span> <span class="keyword">int</span>[nodeCount];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nodeCount;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(graph, i, color))    res.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> start, <span class="keyword">int</span>[] color)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(color[start] != <span class="number">0</span>)   <span class="keyword">return</span> color[start] == <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        color[start] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> newNode : graph[start])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(graph, newNode, color))    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        color[start] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="noopener">https://leetcode.com/problems/course-schedule/</a></p>
<p><a href="https://leetcode.com/problems/course-schedule-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/course-schedule-ii/</a></p>
<p>BFS： 要想完成拓扑排序，我们每次都应当从入度为0的结点开始遍历。因为只有入度为0的结点才能够成为拓扑排序的起点。<strong>这一改进后的算法与普通的广度优先遍历唯一的区别在于我们应当保存每一个结点对应的入度，并在遍历的每一层选取入度为0的结点开始遍历</strong>（多源BFS）</p>
<p><a href="https://www.jianshu.com/p/3347f54a3187" target="_blank" rel="noopener">https://www.jianshu.com/p/3347f54a3187</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopologicalSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get topological ordering of the input directed graph </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n number of nodes in the graph</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> adjacencyList adjacency list representation of the input directed graph</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> topological ordering of the graph stored in an List&lt;Integer&gt;. </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topologicalSort</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] adjacencyList)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; topoRes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] parent : adjacencyList) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : parent) &#123;</span><br><span class="line">                inDegree[child]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// start from nodes whose indegree are 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) deque.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = deque.poll();</span><br><span class="line">            topoRes.add(curr);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : adjacencyList[curr]) &#123;</span><br><span class="line">                inDegree[child]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[child] == <span class="number">0</span>) &#123;</span><br><span class="line">                    deque.offer(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> topoRes.size() == n ? topoRes : <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DFS  按照访问结束的顺序  逆序输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">        <span class="comment">// 构建图的邻接表</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph(numCourses,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prerequisites.size(); i++)&#123;</span><br><span class="line">            graph[prerequisites[i][<span class="number">1</span>]].push_back(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// topological sort</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visit(numCourses,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>; u&lt;numCourses; u++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[u]==<span class="number">0</span> &amp;&amp; !dfs(graph,visit,res,u))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(),res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visit, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res, <span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        visit[u]=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;graph[u].size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = graph[u][i];</span><br><span class="line">            <span class="keyword">if</span>(visit[v]==<span class="number">0</span>) dfs(graph,visit,res,v); <span class="comment">// 0 树边 递归搜索</span></span><br><span class="line">            <span class="keyword">if</span>(visit[v]==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 1 反向边，存在环   // 2 前向边 交叉边</span></span><br><span class="line">        &#125;</span><br><span class="line">        visit[u]=<span class="number">2</span>;</span><br><span class="line">        res.push_back(u);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><p><strong>注：难点在于抽象问题，建图</strong></p>
<p><a href="https://www.acwing.com/blog/content/27/" target="_blank" rel="noopener">https://www.acwing.com/blog/content/27/</a></p>
<h3 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h3><h4 id="所有边的权重都为正数"><a href="#所有边的权重都为正数" class="headerlink" title="所有边的权重都为正数"></a>所有边的权重都为正数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dijkstra 贪心</span></span><br><span class="line"><span class="comment">--------</span></span><br><span class="line"><span class="comment">朴素：</span></span><br><span class="line"><span class="comment">d[s]=0 </span></span><br><span class="line"><span class="comment">for each v in V-&#123;s&#125;: d[v] = INF</span></span><br><span class="line"><span class="comment">for each v in V: S[v] = False //标志是否已找到离源点的最短路 </span></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"><span class="comment">iterate v次//每次找到一个点到源点的最短路</span></span><br><span class="line"><span class="comment">t&lt;-不在S中的距离最近的点(需要遍历一遍所有点，S[v]=false,且d[v]最小)</span></span><br><span class="line"><span class="comment">S[t]=True</span></span><br><span class="line"><span class="comment">for each v in adj(u)//更新其邻接点到源点的距离,直接更改</span></span><br><span class="line"><span class="comment">    d[v] = min(d[v],d[u]+w_uv)</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line"><span class="comment">堆优化：手写堆</span></span><br><span class="line"><span class="comment">d[s]=0 </span></span><br><span class="line"><span class="comment">for each v in V-&#123;s&#125;: d[v] = INF</span></span><br><span class="line"><span class="comment">Q.push&#123;d[s],s&#125;</span></span><br><span class="line"><span class="comment">while Q is not empty</span></span><br><span class="line"><span class="comment">    u&lt;-extract_min(Q)</span></span><br><span class="line"><span class="comment">    Q.pop()</span></span><br><span class="line"><span class="comment">    for each v in adj(u)//用t更新其邻接点到源点的距离,删除原距离，添加新距离</span></span><br><span class="line"><span class="comment">        if d[v]&gt;d[u]+w_uv</span></span><br><span class="line"><span class="comment">            Q.erase(&#123;d[v],v&#125;)</span></span><br><span class="line"><span class="comment">            d[v] = d[u]+w_uv</span></span><br><span class="line"><span class="comment">            Q.push(&#123;d[v],v&#125;)</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">------</span></span><br><span class="line"><span class="comment">堆优化： STL priority queue// 无法直接删除指定节点</span></span><br><span class="line"><span class="comment">d[s]=0 </span></span><br><span class="line"><span class="comment">for each v in V-&#123;s&#125;: d[v] = INF</span></span><br><span class="line"><span class="comment">for each v in V: S[v] = False //标志是否已找到离源点的最短路 </span></span><br><span class="line"><span class="comment">Q.push&#123;d[s],s&#125;</span></span><br><span class="line"><span class="comment">while Q is not empty</span></span><br><span class="line"><span class="comment">    t&lt;-extract_min(Q)</span></span><br><span class="line"><span class="comment">    Q.pop()</span></span><br><span class="line"><span class="comment">    if s[t]==true</span></span><br><span class="line"><span class="comment">        continue</span></span><br><span class="line"><span class="comment">    s[t] = true</span></span><br><span class="line"><span class="comment">    for each v in adj(u)//用t更新其邻接点到源点的距离,不删除原距离(冗余节点)，添加新距离</span></span><br><span class="line"><span class="comment">        if d[v]&gt;d[u]+w_uv</span></span><br><span class="line"><span class="comment">            d[v] = d[u]+w_uv</span></span><br><span class="line"><span class="comment">            Q.push(&#123;d[v],v&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度$O(N<em>T(getmin)+M</em>T(update))$</p>
<h5 id="朴素Dijkstra"><a href="#朴素Dijkstra" class="headerlink" title="朴素Dijkstra"></a>朴素Dijkstra</h5><p>时间复杂度：$O(N^2)$ 适用于稠密图</p>
<h5 id="堆优化Dijkstra"><a href="#堆优化Dijkstra" class="headerlink" title="堆优化Dijkstra"></a>堆优化Dijkstra</h5><p>时间复杂度: $O(MlogN)$ 适用于稀疏图</p>
<h4 id="存在负权边"><a href="#存在负权边" class="headerlink" title="存在负权边"></a>存在负权边</h4><h5 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">d[s]=0</span></span><br><span class="line"><span class="comment">for each v in V-&#123;s&#125;: d[v] = INF</span></span><br><span class="line"><span class="comment">for |V|-1次  //迭代k次后的dist，一定保证能找到从源点，经过不超过k条边的最短路</span></span><br><span class="line"><span class="comment">    for 所有边 a-&gt;b,w</span></span><br><span class="line"><span class="comment">        dist[b] = min(dist[b],dist[a]+w)  // 松弛操作</span></span><br><span class="line"><span class="comment">for 所有边 a-&gt;b,w</span></span><br><span class="line"><span class="comment">    if dist[b] &gt; dist[a]+w</span></span><br><span class="line"><span class="comment">         存在负环</span></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"><span class="comment">若不存在负环，longest simple path has &lt;=|V|-1条边，循环|V|-1次后，能找到所有最短路，对于所有的边a-&gt;b,w 均有 dist[b]&lt;=dist[a]+w</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(NM)$</p>
<h6 id="Within-K-Stops"><a href="#Within-K-Stops" class="headerlink" title="Within K Stops"></a>Within K Stops</h6><p>There are <code>n</code> cities connected by <code>m</code> flights. Each fight starts from city <code>u</code>and arrives at <code>v</code> with a price <code>w</code>. Now given all the cities and flights, together with starting city <code>src</code> and the destination <code>dst</code>, your task is to find the cheapest price from <code>src</code> to <code>dst</code> with up to <code>k</code>stops. If there is no such route, output <code>-1</code>.</p>
<p><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/discuss/115596/c%2B%2B-8-line-bellman-ford" target="_blank" rel="noopener">https://leetcode.com/problems/cheapest-flights-within-k-stops/discuss/115596/c%2B%2B-8-line-bellman-ford</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//bellman ford.</span></span><br><span class="line">    <span class="comment">//just run it k+1 iterations.</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="keyword">int</span> src, <span class="keyword">int</span> sink, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c(n, <span class="number">1e8</span>);</span><br><span class="line">        c[src] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> z=<span class="number">0</span>; z&lt;=k; z++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C(c);<span class="comment">//备份上一次的结果，保证不发生串联更新</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> e: a)</span><br><span class="line">                c[e[<span class="number">1</span>]] = min(c[e[<span class="number">1</span>]], C[e[<span class="number">0</span>]] + e[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c[sink] == <span class="number">1e8</span> ? <span class="number">-1</span> : c[sink];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​        In the original Bellman-Ford algorithm, <code>C[e[1]] = min(C[e[1]], c[e[0]] + e[2]);</code> or Relaxation as it is called in the CLRS is called (|G.V| -1) times which is the longest possible stops in the whole graph. The proof of Bellman-Ford lies in <a href="https://www.cl.cam.ac.uk/teaching/1516/Algorithms/shortestpath.pdf" target="_blank" rel="noopener">Path-Relaxation Property(Lemma 24.15 in CLRS)</a> .So in this problem we have only “relaxed” for k+1 times. If such a path( shortest path within k stops) truly exists then yes, no problem. If not,, two cases: one, the destination is unreachable from src, which gives infinite distance; case two, a shortest path exists with more than k stops. k+1 times of relaxation may and may not find such a path(this is highly related to how the subvectors inside flights vector are arranged) , so you have to double check that.</p>
<p>​         But notice here you used two vector storing shortest paths, C being the last time’s shortest path, c being the current one. In this way, you cannot successively get two shortest path along the line! This means with k+1 times relaxations you cannot even change c[dest]’s value of infinity if theoretical shortest path has more than k stops. </p>
<h5 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h5><p>时间复杂度：一般$O(M)$ 最坏$O(NM)$</p>
<p>但需要注意的是，在网格图中，spfa算法的效率比较低，如果边权为正，则尽量使用 dijkstra 算法。</p>
<p>用BFS对Bellman-Ford算法的优化,利用了每个点不会更新次数太多的特点</p>
<blockquote>
<p>具体做法是用一个队列保存待松弛的点，然后对于每个出队的点依次遍历每个与他有边相邻的点，如果该点可以松弛并且队列中没有该点则将它加入队列中(只有进行松弛操作的点才会对它的邻接点有影响，也就是说其邻接点才需要松弛操作)，如此迭代直到队列为空。</p>
<p>SPFA 在形式上和宽度优先搜索非常类似，不同的是宽度优先搜索中一个点出了队列就不可能重新进入队列，但是SPFA中一个点可能在出队列之后再次被放入队列，也就是一个点改进过其它的点之后，过了一段时间可能本身被改进，于是再次用来改进其它的点，这样反复迭代下去。设一个点用来作为迭代点对其它点进行改进的平均次数为k，有办法证明对于通常的情况，k在2左右</p>
</blockquote>
<p><a href="https://blog.csdn.net/u013445530/article/details/41761687" target="_blank" rel="noopener">https://blog.csdn.net/u013445530/article/details/41761687</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">不存在负环的情况</span></span><br><span class="line"><span class="comment">d[s]=0 </span></span><br><span class="line"><span class="comment">for each v in V-&#123;s&#125;: d[v] = INF</span></span><br><span class="line"><span class="comment">for each v in V: S[v] = False //标志是否在队列中</span></span><br><span class="line"><span class="comment">Q.push(s)</span></span><br><span class="line"><span class="comment">S[s]=True</span></span><br><span class="line"><span class="comment">while Q is not empty</span></span><br><span class="line"><span class="comment">   u&lt;-Q.front()</span></span><br><span class="line"><span class="comment">   Q.pop()</span></span><br><span class="line"><span class="comment">   S[u]=False</span></span><br><span class="line"><span class="comment">   for each v in adj(u)//更新u的所有邻接点v,若v松弛成功且不队列，则Q.push(v)</span></span><br><span class="line"><span class="comment">       if d[v]&gt;d[u]+w_uv</span></span><br><span class="line"><span class="comment">           d[v]=d[u]+w_uv</span></span><br><span class="line"><span class="comment">           if S[v]==False</span></span><br><span class="line"><span class="comment">              Q.push(v)</span></span><br><span class="line"><span class="comment">              S[v]=True</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">判断是否存在负环</span></span><br><span class="line"><span class="comment">d[s]=0 </span></span><br><span class="line"><span class="comment">for each v in V-&#123;s&#125;: d[v] = INF</span></span><br><span class="line"><span class="comment">for each v in V: S[v] = False //标志是否在队列中</span></span><br><span class="line"><span class="comment">for each v in V: c[v] = 0// 当前最短路边数</span></span><br><span class="line"><span class="comment">for each v in V: </span></span><br><span class="line"><span class="comment">    Q.push(v) </span></span><br><span class="line"><span class="comment">    S[v]=True</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">while Q is not empty</span></span><br><span class="line"><span class="comment">   u&lt;-Q.front()</span></span><br><span class="line"><span class="comment">   Q.pop()</span></span><br><span class="line"><span class="comment">   S[s]=False</span></span><br><span class="line"><span class="comment">   for each v in adj(u)//更新u的所有邻接点v,若v松弛成功且不队列，则Q.push(v)</span></span><br><span class="line"><span class="comment">       if d[v]&gt;d[u]+w_uv</span></span><br><span class="line"><span class="comment">           d[v]=d[u]+w_uv</span></span><br><span class="line"><span class="comment">           c[v]=c[u]+1</span></span><br><span class="line"><span class="comment">           if c[v]&gt;=|V|</span></span><br><span class="line"><span class="comment">               存在负环</span></span><br><span class="line"><span class="comment">           if S[v]==False</span></span><br><span class="line"><span class="comment">              Q.push(v)</span></span><br><span class="line"><span class="comment">              S[v]=True</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="多源汇最短路"><a href="#多源汇最短路" class="headerlink" title="多源汇最短路"></a>多源汇最短路</h3><h4 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h4><p>时间复杂度：$O(N^3)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// d[i][j] 初始化：没有任何中间点的距离值</span></span><br><span class="line"><span class="comment">// d[i][j] 表示只经过1~k作为中间点，从i到j的最短路径</span></span><br><span class="line"><span class="comment">// for (k=1; k&lt;=n; k++)</span></span><br><span class="line"><span class="comment">//    for (i=1; i&lt;=n; i++)</span></span><br><span class="line"><span class="comment">//        for (j=1; j&lt;=n; j++)</span></span><br><span class="line"><span class="comment">//            d[i][j] = min(d[i][j], d[i][k]+d[k][j])</span></span><br></pre></td></tr></table></figure>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>定理：设$G=(V,E)$是一个在边$E$上定义了实数值权重$w$的连通无向图，设集合$A$为$E$的一个子集，且$A$包括在图$G$的某棵最小生成树$T$中，设$(S,V-S)$是图$G$中尊重集合$A$的任意一个切割，又设$(u,v)$是横跨切割$(S,V-S)$的一条轻量级边，则边$(u,v)$对于$A$是安全的。</p>
<p><strong>在kruskal算法中，集合A是森林，其结点是给定图的结点，每次加入到集合A中的安全边永远是权重最小的连接两个不同分量的边</strong></p>
<p><strong>在Prim算法中，集合A则是一棵树，每次加入到A中的安全边永远是连接A和A之外的某个结点的边中权重最小的边</strong></p>
<h3 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稠密图： 朴素版prim  O(n^2)</span></span><br><span class="line">朴素：</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> each v in V-&#123;s&#125;: d[v] = INF</span><br><span class="line">d[s]=<span class="number">0</span> <span class="comment">// for some arbitray s in V</span></span><br><span class="line"><span class="keyword">for</span> each v in V: S[v] = False <span class="comment">//标志是否在连通块的集合中</span></span><br><span class="line">---</span><br><span class="line">iterate v次<span class="comment">//每次找到一个点到源点的最短路</span></span><br><span class="line">t&lt;-不在S中的距离最近的点(需要遍历一遍所有点，S[v]=<span class="literal">false</span>,且d[v]最小)</span><br><span class="line">S[t]=True</span><br><span class="line"><span class="keyword">if</span>(d[t]==INF) <span class="keyword">return</span> INF <span class="comment">// 不连通</span></span><br><span class="line"><span class="keyword">else</span> res += d[t]</span><br><span class="line"><span class="keyword">for</span> each v in adj(u)<span class="comment">//更新其邻接点到**集合**的距离,直接更改</span></span><br><span class="line">    d[v] = min(d[v], w_uv)</span><br><span class="line"><span class="comment">//---------------------------------------------------------------    </span></span><br><span class="line"><span class="comment">// 稀疏图：堆优化版prim  O(mlogn)</span></span><br></pre></td></tr></table></figure>
<h3 id="kruskal-算法"><a href="#kruskal-算法" class="headerlink" title="kruskal 算法"></a>kruskal 算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稀疏图： kruskal算法 O(mlogn)</span></span><br><span class="line"><span class="comment">// 最小生成树</span></span><br><span class="line"><span class="comment">//  无向图 n个点 m条边 挑出n-1条边，使得n个点连通且所有边的权值和最小</span></span><br><span class="line"><span class="comment">//   等价于   n-1条边中最大的边最小</span></span><br><span class="line"><span class="comment">// 将m条边按从小到大排序，依次判断新加入这条边是否和之前的成环，成则舍弃，不成则加进来（用并查集判断）</span></span><br><span class="line"><span class="comment">// O(MlogM)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = find(a), b = find(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><h3 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 染色法 O(n+m) DFS</span></span><br><span class="line"><span class="comment">// 判断一个图是不是二分图 </span></span><br><span class="line"><span class="comment">// 把一个图的所有点分为两个集合,集合内部没有边</span></span><br><span class="line"><span class="comment">// 二分图 &lt;=&gt; 图中不含有奇数环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!color[j]) <span class="comment">// 无向图只有树边和环边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(j, <span class="number">3</span> - c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">if</span> (!color[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfs(i, <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(mn) 实际情况一般远小于O(mn)</span></span><br><span class="line"><span class="comment">// 二分图的匹配：给定一个二分图G，在G的一个子图M中，M的边集&#123;E&#125;中的任意两条边都不依附于同一个顶点，则称M是一个匹配。</span></span><br><span class="line"><span class="comment">// 二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || find(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">if</span> (find(i)) res ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br></pre></td></tr></table></figure>
<h2 id="图的连通"><a href="#图的连通" class="headerlink" title="图的连通"></a>图的连通</h2><p>连通   双连通  强连通 <a href="https://www.cnblogs.com/szy-wlxy/p/4639316.html" target="_blank" rel="noopener">https://www.cnblogs.com/szy-wlxy/p/4639316.html</a></p>
<p>所谓连通与强连通，最大的差别，也是最本质的差别就是前者适用于无向图中，而后者适用于有向图。至于两者的概念是一样的，就是图中有a点、b点，从a点可到达b点，同时从b点可到达a点。（若是有向图必须延方向到达。）    </p>
<ul>
<li>无向图是否连通：dfs,bfs搜索 </li>
<li>Union Find（判断无向图中任意两个点是否连通）</li>
</ul>
<p>在图论中，一个有向图被称为是<strong>强连通的</strong>（strongly connected）当且仅当每一对不相同结点 u 和 v 间既存在从 u 到 v 的路径也存在从 v 到 u 的路径（<strong>u-&gt;v和v-&gt;u路径中可以有重复边</strong>）。有向图的极大强连通子图（这里指点数极大）被称为<strong>强连通分量</strong>（strongly connected component）。</p>
<ul>
<li>传递闭包  floyd算法（和强连通关系） 判断是否为强连通图</li>
<li><a href="https://www.cnblogs.com/mhpp/p/6751723.html#_nav_1" target="_blank" rel="noopener">https://www.cnblogs.com/mhpp/p/6751723.html#_nav_1</a></li>
<li><a href="http://blog.miskcoo.com/2016/07/tarjan-algorithm-strongly-connected-components" target="_blank" rel="noopener">http://blog.miskcoo.com/2016/07/tarjan-algorithm-strongly-connected-components</a></li>
</ul>
<blockquote>
<p>定义DFN(u)为节点u搜索的次序编号(时间戳)，Low(u)为u或u的子树能够追溯到的最早的栈中节点的次序号。由定义可以得出，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; Low(u)=Min</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     DFN(u),</span><br><span class="line">&gt;     Low(v),(u,v)为树枝边，u为v的父节点</span><br><span class="line">&gt;     DFN(v),(u,v)为指向栈中节点的后向边或横叉边 //当前节点的后向边一定在栈中,横叉边则不一定</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>算法伪代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tarjan(u)</span><br><span class="line">&#123;</span><br><span class="line">    DFN[u]=Low[u]=++Index                      // 为节点u设定次序编号和Low初值</span><br><span class="line">    Stack.push(u)                              // 将节点u压入栈中</span><br><span class="line">    for each (u, v) in E                       // 枚举每一条边</span><br><span class="line">        if (v is not visted)               // 如果节点v未被访问过</span><br><span class="line">            tarjan(v)                  // 继续向下找</span><br><span class="line">            Low[u] = min(Low[u], Low[v])</span><br><span class="line">        else if (v in S)                   // 如果节点v还在栈内，用bool数组储存是否在栈内的信息</span><br><span class="line">            Low[u] = min(Low[u], DFN[v])</span><br><span class="line">    if (DFN[u] == Low[u])                      // 如果节点u是强连通分量的根</span><br><span class="line">        repeat</span><br><span class="line">            v = S.pop                  // 将v退栈，为该强连通分量中一个顶点</span><br><span class="line">            print v</span><br><span class="line">        until (u== v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中双连通分量可细分为：点-双连通分量，边-双连通分量。所谓点-双连通分量是指在一个无向图中两点间至少有两条路径，且路径中（不算头尾）的点不同。不同的点-双连通分量最多有一个公共点，这个点必定是“割顶”。提到割顶不得不在这里啰嗦一下，割顶（如下图）就是当删去这个点时，连通块的数量会增加。至于什么叫连通块，可以理解为一个点的集合，若两点间可直接或间接的连接则两点在同一连通块中。</p>
<blockquote>
<p>一个顶点u是割点，当且仅当满足(1)或(2) </p>
<p>(1) u为树根，且u有多于一个子树（按DFS访问有多于一个的子树）</p>
<p> (2) u不为树根，且满足存在(u,v)为树枝边(或称父子边，即u为v在搜索树中的父亲)，使得DFN(u)&lt;=Low(v)。</p>
</blockquote>
<p>至于边-双连通分量是指在一个无向图中两点间至少有两条路径，且路径中的边不同。边-双连通分量中一定没有桥。而桥（如上图）是指当删去这个边时，连通块的数量会增加。</p>
<blockquote>
<p>一条无向边(u,v)是桥，当且仅当(u,v)为树枝边，且满足DFN(u)&lt;Low(v)。</p>
</blockquote>
<ul>
<li>无向图 每个点若干巧克力，任意起始点终点的一条路，拿到最多的巧克力-&gt;找最’大‘的连通分量</li>
<li>有向无环图： 拓扑排序，按逆序动态规划</li>
<li>有向图： 强连通分量 缩点  -&gt; 无环   再按拓扑排序按逆序动态规划</li>
</ul>
<h2 id="Union-Find-Set"><a href="#Union-Find-Set" class="headerlink" title="Union Find Set"></a>Union Find Set</h2><ul>
<li>将两个集合合并</li>
<li>询问两个元素是否在一个集合当中</li>
</ul>
<p>基本原理：</p>
<ul>
<li>每个集合用一棵树表示，树根的编号就是整个集合的编号。每个节点存储它的父节点，f[x]表示x的父节点</li>
<li>问题1：如何判断树根： f[x]==x</li>
<li>问题2： 如何求x的集合编号： while(x!=f[x])  x = f[x]</li>
<li>问题3： f[y]=x</li>
</ul>
<p><strong>时间复杂度分析</strong></p>
<p>Let n denote the overall number of elements (equivalently, the number of MAKE-SET operations). </p>
<p>Let m denote the total number of operations.</p>
<p>Let f denote the number of FIND-SET operations</p>
<ul>
<li>only Trick 1: Smaller into larger (Merge tree with smaller weight into tree with larger weight.)<ul>
<li>Theorem: Cost of all UNION’s is O(m+f lg n).</li>
<li>Height of tree increases only when its size doubles, so height is logarithmic in weight. Thus total cost is O(m + f lg n).</li>
</ul>
</li>
<li>only Trick 2: Path compression<ul>
<li>Total cost of FIND-SET’s is O(m lg n).     （Amortization by potential function.）</li>
<li>If all UNION operations occur before all FIND-SET operations, then total cost is O(m).</li>
</ul>
</li>
<li>with both trick <ul>
<li>We will build a simple disjoint-union data structure that, in an amortized sense, performs significantly better than Θ(lg n) per op., even better than Θ(lg lg n), Θ(lg lg lg n), etc., but not quite Θ(1). </li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Union Find 规范写法：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Union_Find</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Union_Find (<span class="keyword">int</span> N) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            f.push_back(i);</span><br><span class="line">            sz.push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootA = Find(A);</span><br><span class="line">        <span class="keyword">int</span> rootB = Find(B);</span><br><span class="line">        <span class="keyword">if</span> (rootA == rootB) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (sz[rootA] &lt; sz[rootB]) &#123;</span><br><span class="line">            f[rootA] = rootB;</span><br><span class="line">            sz[rootB] += sz[rootA];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f[rootB] = rootA;</span><br><span class="line">            sz[rootA] += sz[rootB];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p != f[p]) &#123;</span><br><span class="line">            f[p] = Find(f[p]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[p];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> s : sz)</span><br><span class="line">            res = max(res, s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sz;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-islands/</a></p>
<h1 id="区间和-最值查询"><a href="#区间和-最值查询" class="headerlink" title="区间和/最值查询"></a>区间和/最值查询</h1><p>整个数组给定不变，在线给定查询，多次查询给定区间[left,right)，返回sum ———累加</p>
<h3 id="Sparse-Table算法-数组给定不变"><a href="#Sparse-Table算法-数组给定不变" class="headerlink" title="Sparse_Table算法 (数组给定不变)"></a>Sparse_Table算法 (数组给定不变)</h3><p>整个数组给定不变，在线给定查询，多次查询给定区间[left,right)，返回min/max</p>
<p><a href="https://www.cnblogs.com/yyxayz/p/4109390.html" target="_blank" rel="noopener">https://www.cnblogs.com/yyxayz/p/4109390.html</a></p>
<p>Sparse_Table算法，是一个快速求区间最值的离线算法，预处理时间复杂度O（n*log(n)），查询O(1)，所以是一个很快速的算法，当然这个问题用线段树同样能够解决。</p>
<p>多次查询给定区间[left,right)，返回max/min ——— 动态规划   倍增状态</p>
<ul>
<li><p>预处理：</p>
<p>设数组$maxn[i][j]$ 表示给定的数组从下标i开始，长度为2^j的区间最大值(最小值一样)也就是arr[i]——arr[i+2^j-1]这个区间的最大值。于是我们可以写出这样一个动态转移方程$maxn[i][j] = max(maxn[i][j-1], maxn[i-2^{j-1}][j-1])$</p>
<p>其实就是把区间$[i,i+2^j-1]$分成两段，一段是$[i,i+2^{j-1}-1]$和$[i+2^{j-1},i+2^j-1]$<strong>(一直记住二维数组后面一维表示的是区间的长度2^j)</strong></p>
<p>那么对于$maxn[i][j]$当j等于0，也就是区间长度为1的最大值显然就有$maxn[i][0]=arr[i]$;</p>
</li>
<li><p>查询：</p>
<p>注意到我们的最值数组存的都是区间长度为2^k(k=0,1,2,3…..)次方的最值</p>
<p>所以对于区间[a,b] 我们肯定要划分为两个区间长度是$2^x$, $ 2^y$的区间才可以直接利用我们得到的最值数组来求最值嘛 这里有两个未知数不好求，我们可以直接取k，对于k满足a+2^k-1=b  k=log2(b-a+1) 那么区间a,b的最大值就是$max(maxn[a][k], maxn[b-2^k+1][k])$</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getbestarr</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//n为给定的数组的长度  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="keyword">int</span> tem = (<span class="keyword">int</span>)<span class="built_in">floor</span>(log2((<span class="keyword">double</span>)n));<span class="comment">//因为区间的最长长度是2^tem==n嘛  </span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)  </span><br><span class="line">        minn[i][<span class="number">0</span>]= maxn[i][<span class="number">0</span>] = arr[i];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tem;j++) <span class="comment">//下标从1开始  </span></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">             maxn[i][j] = max(maxn[i][j<span class="number">-1</span>],maxn[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);  <span class="comment">//最大值  </span></span><br><span class="line">             minn[i][j] = min(minn[i][j<span class="number">-1</span>],minn[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);  <span class="comment">//最小值  </span></span><br><span class="line">        &#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">bool</span> getwhat)</span><span class="comment">//getwhat表示你是想取最大还是最小  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="keyword">int</span> k = log2(b-a+<span class="number">1</span>);  <span class="comment">// 四舍五入</span></span><br><span class="line">   <span class="keyword">if</span>(getwhat)  </span><br><span class="line">   		<span class="keyword">return</span> max(maxn[a][k],maxn[b-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);  </span><br><span class="line">   <span class="keyword">else</span>  </span><br><span class="line">     	<span class="keyword">return</span> min(minn[a][k],minn[b-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线段树-数组可变"><a href="#线段树-数组可变" class="headerlink" title="线段树 (数组可变)"></a>线段树 (数组可变)</h3><p><strong>线段树（区间维护）</strong></p>
<p>Query1:  range sum/min/max in  [i,j]</p>
<p>Query2: update value at index i  to val</p>
<p><a href="https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/</a></p>
<p><a href="https://leetcode.com/problems/range-sum-query-mutable/" target="_blank" rel="noopener">https://leetcode.com/problems/range-sum-query-mutable/</a></p>
<p>整个数组给定，且可在线更改，在线查询区间sum/min/max</p>
<blockquote>
<p>We have an array arr[0 . . . n-1]. We should be able to</p>
<p><strong>1</strong> Find the sum of elements from index l to r where 0 &lt;= l &lt;= r &lt;= n-1</p>
<p><strong>2</strong> Change value of a specified element of the array to a new value x. We need to do arr[i] = x where 0 &lt;= i &lt;= n-1.</p>
</blockquote>
<ul>
<li>A <strong>simple solution</strong> is to run a loop from l to r and calculate sum of elements in given range. To update a value, simply do arr[i] = x. The first operation takes O(n) time and second operation takes O(1) time.</li>
<li><strong>Another solution</strong> is to create another array and store sum from start to i at the ith index in this array. Sum of a given range can now be calculated in O(1) time, but update operation takes O(n) time now. This works well if the number of query operations are large and very few updates.</li>
<li>What if the number of query and updates are equal? <strong>Can we perform both the operations in O(log n) time once given the array?</strong> We can use a Segment Tree to do both operations in O(Logn) time.</li>
</ul>
<p><strong>Representation of Segment trees</strong> </p>
<p><strong>1.</strong> Leaf Nodes are the elements of the input array.</p>
<p> <strong>2.</strong> Each internal node represents some merging of the leaf nodes. The merging may be different for different problems. For this problem, merging is sum of leaves under a node.</p>
<p>An array representation of tree is used to represent Segment Trees. For each node at index $i$, the left child is at index $2i$, right child at $2i+1$ and the parent is at $i/2$ (下标从1开始)</p>
<blockquote>
<p>Heap : compelete binary tree</p>
<p>Segment trees: full binary tree</p>
</blockquote>
<p><strong>Construction of Segment Tree from given array</strong><br>We start with a segment arr[0 . . . n-1]. and every time we divide the current segment into two halves(if it has not yet become a segment of length 1), and then call the same procedure on both halves, and for each such segment, we store the sum in the corresponding node.<br>All levels of the constructed segment tree will be completely filled except the last level. Also, the tree will be a <a href="https://www.geeksforgeeks.org/binary-tree-set-3-types-of-binary-tree/" target="_blank" rel="noopener">Full Binary Tree</a> because we always divide segments in two halves at every level. Since the constructed tree is always a full binary tree with n leaves, there will be n-1 internal nodes. So total number of nodes will be 2*n – 1. Note that this does not include dummy nodes.</p>
<p><strong>What is total size of array representing segment tree?</strong><br>If n is a power of 2, then there are no dummy nodes. So size of segment tree is 2n-1 (n leaf nodes and n-1) internal nodes. If n is not a power of 2, then size of tree will be 2<em>x – 1 where x is smallest of 2 greater than n. For example, when n = 10, then size of array representing segment tree is 2</em>16-1 = 31.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    Node* l;</span><br><span class="line">    Node* r;</span><br><span class="line">    <span class="keyword">int</span> st,ed; <span class="comment">// 左闭 右闭</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    Node(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> st, <span class="keyword">int</span> ed) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;st = st; <span class="keyword">this</span>-&gt;ed = ed; <span class="keyword">this</span>-&gt;op = op;</span><br><span class="line">        <span class="keyword">if</span>(st == ed)&#123; <span class="comment">// 叶子节点</span></span><br><span class="line">            l = <span class="literal">NULL</span>; r = <span class="literal">NULL</span>; val = nums[st];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l = <span class="keyword">new</span> Node(nums,st,(st+ed)/<span class="number">2</span>);</span><br><span class="line">            r = <span class="keyword">new</span> Node(nums,((st+ed)/<span class="number">2</span>)+<span class="number">1</span>,ed);</span><br><span class="line">            val = l-&gt;val + r-&gt;val;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// getSum 区间查询</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(Node* now, <span class="keyword">int</span> st, <span class="keyword">int</span> ed)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (now-&gt;st &gt;=st <span class="keyword">and</span> now-&gt;ed &lt;= ed) &#123;<span class="comment">// now完全属于[l,r] 返回now.sum 否则返回左边+右边（如果存在且有交集）</span></span><br><span class="line">        <span class="keyword">return</span> now-&gt;val;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 此时now 一定有交集</span></span><br><span class="line">        <span class="keyword">if</span>(now-&gt;l != <span class="literal">NULL</span> <span class="keyword">and</span> now-&gt;l-&gt;ed &gt;= st) sum += getSum(now-&gt;l, st, ed);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;r != <span class="literal">NULL</span> <span class="keyword">and</span> now-&gt;r-&gt;st &lt;= ed) sum += getSum(now-&gt;r, st, ed);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// update 单点修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Node* now, <span class="keyword">int</span> index, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (now-&gt;st == now-&gt;ed)&#123; <span class="comment">// 叶子节点</span></span><br><span class="line">        now-&gt;val = val;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt;= now-&gt;l-&gt;ed)&#123;</span><br><span class="line">            update(now-&gt;l,index,val);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            update(now-&gt;r,index,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据左右子树重新计算now-&gt;val</span></span><br><span class="line">        now-&gt;val = now-&gt;l-&gt;val + now-&gt;r-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Time Complexity:</strong><br>Time Complexity for tree construction is O(n). There are total 2n-1 nodes, and value of every node is calculated only once in tree construction.</p>
<p>Time complexity to query is O(Logn). To query a sum, <strong>we process at most four nodes at every level and number of levels is O(Logn)</strong>.</p>
<p>The time complexity of update is also O(Logn). To update a leaf value, we process one node at every level and number of levels is O(Logn).</p>
<p>升级版：</p>
<p>Query1 : range sum/min/max in [i,j]   </p>
<p>Query2: update value in [i,j) to val    ———————————— 懒标记</p>
<h1 id="在线算法-amp-离线算法"><a href="#在线算法-amp-离线算法" class="headerlink" title="在线算法 &amp; 离线算法"></a>在线算法 &amp; 离线算法</h1><p><strong>在线算法：在计算机科学中，一个在线算法是指它可以以序列化的方式一个个的处理输入，也就是说在开始时并不需要已经知道所有的输入。</strong></p>
<p><strong>离线算法：在开始时就需要知道问题的所有输入数据，而且在解决一个问题后就要立即输出结果。例如，选择排序在排序前就需要知道所有待排序元素，然而插入排序就不必了。</strong></p>
<h2 id="最近公共祖先离线算法"><a href="#最近公共祖先离线算法" class="headerlink" title="最近公共祖先离线算法"></a>最近公共祖先离线算法</h2><p><a href="https://www.cnblogs.com/JVxie/p/4854719.html" target="_blank" rel="noopener">https://www.cnblogs.com/JVxie/p/4854719.html</a></p>
<p>tarjan算法（DFS+Union Find）离线算法 O(N+Q)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Tarjan(u)<span class="comment">//marge和find为并查集合并函数和查找函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">for</span> <span class="title">each</span><span class="params">(u,v)</span>    <span class="comment">//访问所有u子节点v</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Tarjan(v);        <span class="comment">//继续往下遍历</span></span><br><span class="line">        marge(u,v);    <span class="comment">//合并v到u上</span></span><br><span class="line">        标记v被访问过;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">for</span> <span class="title">each</span><span class="params">(u,e)</span>    <span class="comment">//访问所有和u有询问关系的e</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        如果e被访问过;</span><br><span class="line">        u,e的最近公共祖先为find(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/ywcpig/article/details/52336496" target="_blank" rel="noopener">https://blog.csdn.net/ywcpig/article/details/52336496</a></p>
<p>转换为RMQ问题，用Sparse Table（简称ST）算法解决。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>建立常识性的时间概念：</p>
<p>一般笔记本电脑的CPU主频两级为GHZ，也就是说，每秒可以处理<strong>10^9次</strong>基本运算。</p>
<p>One day：24<em>3600 = 25</em>4000 = 10^5 sec</p>
<p>One century : 100<em>365 = 3</em>10^4 = 3*10^9 sec</p>
<p>三生三世：10^10 sec</p>
<p>Debug 的时候如果代码跑的慢具体定位到某一部分，并确定该部分有没有更好的时间复杂度的算法。如果是因为整体数据量大，如机器学习中的问题，则可切分小数据集测试代码的正确性。 </p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>二维vector: </p>
<p>Vector 中主要维持两个变量： 数组地址  数组长度  （数组存储在连续空间）</p>
<p>二维vector中维持的数组中存储的为一维vector实例  （二维vector的内容存储并不连续）</p>
<p>vector   rbegin   rend      reverse</p>
<h1 id="Tutorials"><a href="#Tutorials" class="headerlink" title="Tutorials"></a>Tutorials</h1><p><a href="https://www.topcoder.com/community/competitive-programming/tutorials/" target="_blank" rel="noopener">https://www.topcoder.com/community/competitive-programming/tutorials/</a></p>
<p><a href="https://yangshun.github.io/tech-interview-handbook/" target="_blank" rel="noopener">https://yangshun.github.io/tech-interview-handbook/</a></p>
<p><a href="https://www.acwing.com/" target="_blank" rel="noopener">https://www.acwing.com/</a></p>
<p><a href="https://oi-wiki.org/ds/" target="_blank" rel="noopener">https://oi-wiki.org/ds/</a></p>
<p><a href="http://courses.csail.mit.edu/iap/interview/index.php" target="_blank" rel="noopener">http://courses.csail.mit.edu/iap/interview/index.php</a></p>
<p><a href="https://www.geeksforgeeks.org/" target="_blank" rel="noopener">https://www.geeksforgeeks.org</a></p>
<p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/recitation-notes/" target="_blank" rel="noopener">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2015/recitation-notes/</a></p>
<p><a href="https://www.nowcoder.com/study/vod/1041" target="_blank" rel="noopener">https://www.nowcoder.com/study/vod/1041</a></p>
<p><a href="https://techdevguide.withgoogle.com/" target="_blank" rel="noopener">https://techdevguide.withgoogle.com/</a></p>
<h2 id="算法Youtube-channel"><a href="#算法Youtube-channel" class="headerlink" title="算法Youtube channel"></a>算法Youtube channel</h2><p>Back To Back SWE <a href="https://www.youtube.com/channel/UCmJz2DV1a3yfgrR7GqRtUUA" target="_blank" rel="noopener">https://www.youtube.com/channel/UCmJz2DV1a3yfgrR7GqRtUUA</a></p>
<p>HackerRank <a href="https://www.youtube.com/channel/UCOf7UPMHBjAavgD0Qw5q5ww" target="_blank" rel="noopener">https://www.youtube.com/channel/UCOf7UPMHBjAavgD0Qw5q5ww</a></p>
<p>花花酱 <a href="https://space.bilibili.com/9880352/" target="_blank" rel="noopener">https://space.bilibili.com/9880352/</a></p>
<p>CS Dojo <a href="https://www.youtube.com/channel/UCxX9wt5FWQUAAz4UrysqK9A" target="_blank" rel="noopener">https://www.youtube.com/channel/UCxX9wt5FWQUAAz4UrysqK9A</a></p>
<p>Tuschar Roy <a href="https://www.youtube.com/user/tusharroy2525" target="_blank" rel="noopener">https://www.youtube.com/user/tusharroy2525</a></p>
<p>GeeksForGeeks <a href="https://www.youtube.com/channel/UC0RhatS1pyxInC00YKjjBqQ" target="_blank" rel="noopener">https://www.youtube.com/channel/UC0RhatS1pyxInC00YKjjBqQ</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/12/c++/" rel="next" title="C++ learning">
                <i class="fa fa-chevron-left"></i> C++ learning
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/12/python/" rel="prev" title="python learning">
                python learning <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">lizzy llq</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C-语法基础知识"><span class="nav-number">1.</span> <span class="nav-text">C++语法基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0-语法基础"><span class="nav-number">1.1.</span> <span class="nav-text">0. 语法基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#指针-amp-引用"><span class="nav-number">1.1.1.</span> <span class="nav-text">指针 &amp; 引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for循环（范围循环）"><span class="nav-number">1.1.2.</span> <span class="nav-text">for循环（范围循环）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STL"><span class="nav-number">1.2.</span> <span class="nav-text">STL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#STL综述"><span class="nav-number">1.2.1.</span> <span class="nav-text">STL综述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector"><span class="nav-number">1.2.2.</span> <span class="nav-text">vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-number">1.2.3.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-map"><span class="nav-number">1.2.4.</span> <span class="nav-text">set map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#set"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#map"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unordered-set"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">unordered_set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unordered-map"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">unordered_map</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heap"><span class="nav-number">1.2.5.</span> <span class="nav-text">heap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Algorithm"><span class="nav-number">1.2.6.</span> <span class="nav-text">Algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sort函数"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">sort函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#n-th-element"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">n-th element</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#transform-函数"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">transform 函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iterator"><span class="nav-number">1.2.7.</span> <span class="nav-text">iterator</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Array"><span class="nav-number">2.</span> <span class="nav-text">Array</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#排序算法"><span class="nav-number">2.1.</span> <span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#归并排序"><span class="nav-number">2.1.1.</span> <span class="nav-text">归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#逆序对的数量"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">逆序对的数量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速排序"><span class="nav-number">2.1.2.</span> <span class="nav-text">快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Patrition"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">Patrition</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#位序为k的元素"><span class="nav-number">2.1.2.1.1.</span> <span class="nav-text">位序为k的元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sort-colors"><span class="nav-number">2.1.2.1.2.</span> <span class="nav-text">sort colors</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Wiggle-Sort-II"><span class="nav-number">2.1.2.1.3.</span> <span class="nav-text">Wiggle Sort II</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Majority-Element-众数"><span class="nav-number">2.2.</span> <span class="nav-text">Majority Element 众数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shuffle算法"><span class="nav-number">2.3.</span> <span class="nav-text">shuffle算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Brute-force-不断取出抽样"><span class="nav-number">2.3.1.</span> <span class="nav-text">Brute force(不断取出抽样)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fisher-Yates-Algorithm-洗牌算法"><span class="nav-number">2.3.2.</span> <span class="nav-text">Fisher-Yates Algorithm(洗牌算法)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ksum问题"><span class="nav-number">2.4.</span> <span class="nav-text">Ksum问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2sum"><span class="nav-number">2.4.1.</span> <span class="nav-text">2sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-sum"><span class="nav-number">2.4.2.</span> <span class="nav-text">3 sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ksum问题-降解为2sum问题"><span class="nav-number">2.4.3.</span> <span class="nav-text">ksum问题(降解为2sum问题)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Combination-Sum-II"><span class="nav-number">2.4.4.</span> <span class="nav-text">Combination Sum II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Combination-Sum-III"><span class="nav-number">2.4.5.</span> <span class="nav-text">Combination Sum III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Combination-Sum"><span class="nav-number">2.4.6.</span> <span class="nav-text">Combination Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Path-sum3"><span class="nav-number">2.4.7.</span> <span class="nav-text">Path sum3</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高精度"><span class="nav-number">2.5.</span> <span class="nav-text">高精度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前缀和与差分"><span class="nav-number">2.6.</span> <span class="nav-text">前缀和与差分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#子区间的和-子矩阵的和"><span class="nav-number">2.6.1.</span> <span class="nav-text">子区间的和/ 子矩阵的和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#差分-差分矩阵"><span class="nav-number">2.6.2.</span> <span class="nav-text">差分/ 差分矩阵</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Two-pointers-双指针"><span class="nav-number">2.7.</span> <span class="nav-text">Two pointers  双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reverse-Words-in-a-String"><span class="nav-number">2.7.1.</span> <span class="nav-text">Reverse Words in a String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Longest-Substring-Without-Repeating-Characters"><span class="nav-number">2.7.2.</span> <span class="nav-text">Longest Substring Without Repeating Characters</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#离散化"><span class="nav-number">2.8.</span> <span class="nav-text">离散化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#采样"><span class="nav-number">2.9.</span> <span class="nav-text">采样</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#蓄水池采样"><span class="nav-number">2.9.1.</span> <span class="nav-text">蓄水池采样</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加权随机采样"><span class="nav-number">2.9.2.</span> <span class="nav-text">加权随机采样</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#In-place"><span class="nav-number">2.10.</span> <span class="nav-text">In place</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#First-Missing-Positive"><span class="nav-number">2.10.1.</span> <span class="nav-text">First Missing Positive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rotate-array"><span class="nav-number">2.10.2.</span> <span class="nav-text">rotate array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rotate-image"><span class="nav-number">2.10.3.</span> <span class="nav-text">rotate image</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Binary-Search"><span class="nav-number">3.</span> <span class="nav-text">Binary Search</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#二分搜索位置-单调"><span class="nav-number">3.1.</span> <span class="nav-text">二分搜索位置 (单调)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二分答案-（满足-不满足）"><span class="nav-number">3.2.</span> <span class="nav-text">二分答案  （满足|不满足）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最大值最小化-最小值最大化"><span class="nav-number">3.2.1.</span> <span class="nav-text">最大值最小化/最小值最大化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Largest-Sum-of-Averages"><span class="nav-number">3.2.2.</span> <span class="nav-text">Largest Sum of Averages</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Median-of-two-sorted-arrays"><span class="nav-number">3.2.3.</span> <span class="nav-text">Median of two sorted arrays</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#perfect-square"><span class="nav-number">3.2.4.</span> <span class="nav-text">perfect square</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Smallest-good-base"><span class="nav-number">3.2.5.</span> <span class="nav-text">Smallest good base</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linked-List"><span class="nav-number">4.</span> <span class="nav-text">Linked List</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#用数组模拟链表"><span class="nav-number">4.1.</span> <span class="nav-text">用数组模拟链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Floyd-Cycle-detection-algorithm"><span class="nav-number">4.2.</span> <span class="nav-text">Floyd Cycle detection algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Find-the-Duplicate-Number"><span class="nav-number">4.2.1.</span> <span class="nav-text">Find the Duplicate Number</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reverse-Linked-List-In-Place"><span class="nav-number">4.3.</span> <span class="nav-text">Reverse Linked List  (In Place)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#栈-和-队列"><span class="nav-number">5.</span> <span class="nav-text">栈 和 队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#用数组模拟栈和队列"><span class="nav-number">5.1.</span> <span class="nav-text">用数组模拟栈和队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单调栈和单调队列"><span class="nav-number">5.2.</span> <span class="nav-text">单调栈和单调队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单调栈"><span class="nav-number">5.2.1.</span> <span class="nav-text">单调栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Largest-Rectangle-in-Histogram"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">Largest Rectangle in Histogram</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Trapping-Rain-Water"><span class="nav-number">5.2.1.2.</span> <span class="nav-text">Trapping Rain Water</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sum-of-Subarray-Minimums-Maximums"><span class="nav-number">5.2.1.3.</span> <span class="nav-text">Sum of Subarray Minimums/Maximums</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#叶值的最小代价生成树"><span class="nav-number">5.2.1.4.</span> <span class="nav-text">叶值的最小代价生成树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#132-pattern"><span class="nav-number">5.2.1.5.</span> <span class="nav-text">132 pattern</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单调队列"><span class="nav-number">5.3.</span> <span class="nav-text">单调队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#max-sliding-window"><span class="nav-number">5.3.1.</span> <span class="nav-text">max sliding window</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最大子序和-长度不超过M"><span class="nav-number">5.3.2.</span> <span class="nav-text">最大子序和(长度不超过M)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shortest-Subarray-with-Sum-at-Least-K"><span class="nav-number">5.3.3.</span> <span class="nav-text">Shortest Subarray with Sum at Least K</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#迭代与递归"><span class="nav-number">6.</span> <span class="nav-text">迭代与递归</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#汉诺塔"><span class="nav-number">6.1.</span> <span class="nav-text">汉诺塔</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#约瑟夫环"><span class="nav-number">6.2.</span> <span class="nav-text">约瑟夫环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表-递归-非递归"><span class="nav-number">6.3.</span> <span class="nav-text">链表  递归  非递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树-递归-非递归"><span class="nav-number">6.4.</span> <span class="nav-text">树  递归  非递归</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Binary-Tree-Upside-Down"><span class="nav-number">6.4.0.1.</span> <span class="nav-text">Binary Tree Upside Down</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Increasing-Order-Search-Tree"><span class="nav-number">6.4.0.2.</span> <span class="nav-text">Increasing Order Search Tree</span></a></li></ol></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#Hash"><span class="nav-number">7.</span> <span class="nav-text">Hash</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#模拟哈希"><span class="nav-number">7.1.</span> <span class="nav-text">模拟哈希</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String-1"><span class="nav-number">8.</span> <span class="nav-text">String</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#strStr"><span class="nav-number">8.1.</span> <span class="nav-text">strStr()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#暴力搜索"><span class="nav-number">8.1.1.</span> <span class="nav-text">暴力搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KMP算法"><span class="nav-number">8.1.2.</span> <span class="nav-text">KMP算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sliding-window-algorithm"><span class="nav-number">8.2.</span> <span class="nav-text">Sliding window algorithm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string-hash"><span class="nav-number">8.3.</span> <span class="nav-text">string hash</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自然溢出"><span class="nav-number">8.3.1.</span> <span class="nav-text">自然溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单Hash方法"><span class="nav-number">8.3.2.</span> <span class="nav-text">单Hash方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#公式"><span class="nav-number">8.3.3.</span> <span class="nav-text">公式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash素数的选取"><span class="nav-number">8.3.4.</span> <span class="nav-text">Hash素数的选取</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串转化"><span class="nav-number">8.4.</span> <span class="nav-text">字符串转化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Tree"><span class="nav-number">9.</span> <span class="nav-text">Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Balanced-Binary-Tree"><span class="nav-number">9.1.</span> <span class="nav-text">Balanced Binary Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCA-Lowest-Common-Ancestor"><span class="nav-number">9.2.</span> <span class="nav-text">LCA(Lowest Common Ancestor)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LCA-在线算法"><span class="nav-number">9.2.1.</span> <span class="nav-text">LCA 在线算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉搜索树的最近公共父节点"><span class="nav-number">9.2.2.</span> <span class="nav-text">二叉搜索树的最近公共父节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最深叶节点的最近公共父节点"><span class="nav-number">9.2.3.</span> <span class="nav-text">最深叶节点的最近公共父节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#完全二叉树的最近公共父节点"><span class="nav-number">9.2.4.</span> <span class="nav-text">完全二叉树的最近公共父节点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#堆-优先队列"><span class="nav-number">10.</span> <span class="nav-text">堆 优先队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#用数组模拟堆"><span class="nav-number">10.1.</span> <span class="nav-text">用数组模拟堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#merge-k-sorted-list"><span class="nav-number">10.2.</span> <span class="nav-text">merge k sorted list</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Trie树"><span class="nav-number">11.</span> <span class="nav-text">Trie树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#字典树"><span class="nav-number">11.1.</span> <span class="nav-text">字典树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串统计"><span class="nav-number">11.1.1.</span> <span class="nav-text">字符串统计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP合并"><span class="nav-number">11.1.2.</span> <span class="nav-text">IP合并</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Trie树-1"><span class="nav-number">11.2.</span> <span class="nav-text">Trie树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Trie-图（ac-自动机）"><span class="nav-number">11.3.</span> <span class="nav-text">Trie 图（ac 自动机）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Math"><span class="nav-number">12.</span> <span class="nav-text">Math</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数论"><span class="nav-number">12.1.</span> <span class="nav-text">数论</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#取模-取余"><span class="nav-number">12.1.0.1.</span> <span class="nav-text">取模 取余</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#质数"><span class="nav-number">12.1.1.</span> <span class="nav-text">质数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#质数的判定"><span class="nav-number">12.1.1.1.</span> <span class="nav-text">质数的判定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分解质因数"><span class="nav-number">12.1.1.2.</span> <span class="nav-text">分解质因数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#筛质数"><span class="nav-number">12.1.1.3.</span> <span class="nav-text">筛质数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#约数"><span class="nav-number">12.1.2.</span> <span class="nav-text">约数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#约数个数-amp-约数之和"><span class="nav-number">12.1.2.1.</span> <span class="nav-text">约数个数 &amp; 约数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最大公约数-最小公倍数-欧几里得算法"><span class="nav-number">12.1.2.2.</span> <span class="nav-text">最大公约数 最小公倍数 (欧几里得算法)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#欧拉函数"><span class="nav-number">12.1.3.</span> <span class="nav-text">欧拉函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#欧拉定理-费马定理"><span class="nav-number">12.1.3.1.</span> <span class="nav-text">欧拉定理 费马定理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速幂"><span class="nav-number">12.1.4.</span> <span class="nav-text">快速幂</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#乘法逆元的定义"><span class="nav-number">12.1.4.0.1.</span> <span class="nav-text">乘法逆元的定义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展欧几里得算法"><span class="nav-number">12.1.5.</span> <span class="nav-text">扩展欧几里得算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线性同余方程"><span class="nav-number">12.1.5.1.</span> <span class="nav-text">线性同余方程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中国剩余定理"><span class="nav-number">12.1.6.</span> <span class="nav-text">中国剩余定理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高斯消元"><span class="nav-number">12.1.7.</span> <span class="nav-text">高斯消元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合计数"><span class="nav-number">12.1.8.</span> <span class="nav-text">组合计数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bit-Manipulation"><span class="nav-number">13.</span> <span class="nav-text">Bit Manipulation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#补码"><span class="nav-number">13.1.</span> <span class="nav-text">补码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#左移右移"><span class="nav-number">13.2.</span> <span class="nav-text">左移右移</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异或"><span class="nav-number">13.3.</span> <span class="nav-text">异或</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#single-Number"><span class="nav-number">13.3.1.</span> <span class="nav-text">single Number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#single-Number-ii"><span class="nav-number">13.3.2.</span> <span class="nav-text">single Number ii</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#single-Number-iii"><span class="nav-number">13.3.3.</span> <span class="nav-text">single Number iii</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#给定范围的重复与缺失问题"><span class="nav-number">13.3.4.</span> <span class="nav-text">给定范围的重复与缺失问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Count-set-bits-in-an-integer-正整数"><span class="nav-number">13.4.</span> <span class="nav-text">Count set bits in an integer(正整数)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Number-Complement"><span class="nav-number">13.5.</span> <span class="nav-text">Number Complement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bitmap-Bitset"><span class="nav-number">13.6.</span> <span class="nav-text">Bitmap Bitset</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Partition-Equal-Subset-Sum"><span class="nav-number">13.6.1.</span> <span class="nav-text">Partition Equal Subset Sum</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#贪心"><span class="nav-number">14.</span> <span class="nav-text">贪心</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#排序"><span class="nav-number">14.1.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合并果子-huffman"><span class="nav-number">14.2.</span> <span class="nav-text">合并果子  huffman</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#区间问题"><span class="nav-number">14.3.</span> <span class="nav-text">区间问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#离线区间merge"><span class="nav-number">14.3.1.</span> <span class="nav-text">离线区间merge</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#区间选点-最大的不相交区间的数量"><span class="nav-number">14.3.2.</span> <span class="nav-text">区间选点|最大的不相交区间的数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#区间分组"><span class="nav-number">14.3.3.</span> <span class="nav-text">区间分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#区间覆盖"><span class="nav-number">14.3.4.</span> <span class="nav-text">区间覆盖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Maximum-Length-of-Pair-Chain"><span class="nav-number">14.3.5.</span> <span class="nav-text">Maximum Length of Pair Chain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#区间重叠-扫描线算法"><span class="nav-number">14.3.6.</span> <span class="nav-text">区间重叠 扫描线算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态维护区间"><span class="nav-number">14.3.7.</span> <span class="nav-text">动态维护区间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Jump-Game2"><span class="nav-number">14.4.</span> <span class="nav-text">Jump Game2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态规划"><span class="nav-number">15.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线性DP"><span class="nav-number">15.1.</span> <span class="nav-text">线性DP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数字三角形"><span class="nav-number">15.1.1.</span> <span class="nav-text">数字三角形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Longest-common-subsequence-substring"><span class="nav-number">15.1.2.</span> <span class="nav-text">Longest  common subsequence/substring</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Edit-Distance"><span class="nav-number">15.1.3.</span> <span class="nav-text">Edit Distance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Longest-palindromic-subsequence"><span class="nav-number">15.1.4.</span> <span class="nav-text">Longest palindromic subsequence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Longest-palindromic-substring"><span class="nav-number">15.1.5.</span> <span class="nav-text">Longest palindromic substring</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Longest-increasing-subsequence"><span class="nav-number">15.1.6.</span> <span class="nav-text">Longest increasing subsequence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Increasing-Triplet-Subsequence"><span class="nav-number">15.1.7.</span> <span class="nav-text">Increasing Triplet Subsequence</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#背包问题"><span class="nav-number">15.2.</span> <span class="nav-text">背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#01背包"><span class="nav-number">15.2.1.</span> <span class="nav-text">01背包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#完全背包"><span class="nav-number">15.2.2.</span> <span class="nav-text">完全背包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#coin-change"><span class="nav-number">15.2.2.1.</span> <span class="nav-text">coin change</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多重背包"><span class="nav-number">15.2.3.</span> <span class="nav-text">多重背包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#混合背包"><span class="nav-number">15.2.4.</span> <span class="nav-text">混合背包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二维费用背包"><span class="nav-number">15.2.5.</span> <span class="nav-text">二维费用背包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分组背包"><span class="nav-number">15.2.6.</span> <span class="nav-text">分组背包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#区间DP"><span class="nav-number">15.3.</span> <span class="nav-text">区间DP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#石子合并"><span class="nav-number">15.3.1.</span> <span class="nav-text">石子合并</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计数类DP"><span class="nav-number">15.4.</span> <span class="nav-text">计数类DP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#整数划分"><span class="nav-number">15.4.1.</span> <span class="nav-text">整数划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#coin-change2"><span class="nav-number">15.4.2.</span> <span class="nav-text">coin change2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Combination-Sum-IV"><span class="nav-number">15.4.3.</span> <span class="nav-text">Combination Sum IV</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数位统计DP"><span class="nav-number">15.5.</span> <span class="nav-text">数位统计DP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#计数问题"><span class="nav-number">15.5.1.</span> <span class="nav-text">计数问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#No-Nine"><span class="nav-number">15.5.2.</span> <span class="nav-text">No Nine</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#鸡蛋问题"><span class="nav-number">15.6.</span> <span class="nav-text">鸡蛋问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#股票问题"><span class="nav-number">15.7.</span> <span class="nav-text">股票问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最大子区间求和"><span class="nav-number">15.8.</span> <span class="nav-text">最大子区间求和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最大子区间求和-1"><span class="nav-number">15.8.1.</span> <span class="nav-text">最大子区间求和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最大子区间求积"><span class="nav-number">15.8.2.</span> <span class="nav-text">最大子区间求积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Maximum-Sum-Circular-Subarray"><span class="nav-number">15.8.3.</span> <span class="nav-text">Maximum Sum Circular Subarray</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最大子矩阵求和"><span class="nav-number">15.8.4.</span> <span class="nav-text">最大子矩阵求和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两个不重叠子区间最大和"><span class="nav-number">15.8.5.</span> <span class="nav-text">两个不重叠子区间最大和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#固定长度，k个不重叠子区间最大和"><span class="nav-number">15.8.6.</span> <span class="nav-text">固定长度，k个不重叠子区间最大和</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#搜索与图论"><span class="nav-number">16.</span> <span class="nav-text">搜索与图论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BFS"><span class="nav-number">16.1.</span> <span class="nav-text">BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多源BFS"><span class="nav-number">16.1.1.</span> <span class="nav-text">多源BFS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DFS"><span class="nav-number">16.2.</span> <span class="nav-text">DFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回溯"><span class="nav-number">16.2.1.</span> <span class="nav-text">回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#N皇后问题"><span class="nav-number">16.2.1.1.</span> <span class="nav-text">N皇后问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Partition-to-K-Equal-Sum-Subsets"><span class="nav-number">16.2.1.2.</span> <span class="nav-text">Partition to K Equal Sum Subsets</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图论基本概念"><span class="nav-number">16.3.</span> <span class="nav-text">图论基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树和图的深度-广度优先遍历"><span class="nav-number">16.4.</span> <span class="nav-text">树和图的深度/广度优先遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#树的深度优先遍历"><span class="nav-number">16.4.1.</span> <span class="nav-text">树的深度优先遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#树的重心"><span class="nav-number">16.4.1.1.</span> <span class="nav-text">树的重心</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的深度优先遍历"><span class="nav-number">16.4.2.</span> <span class="nav-text">图的深度优先遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Find-Eventual-Safe-States"><span class="nav-number">16.4.2.1.</span> <span class="nav-text">Find Eventual Safe States</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拓扑排序"><span class="nav-number">16.5.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最短路"><span class="nav-number">16.6.</span> <span class="nav-text">最短路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单源最短路"><span class="nav-number">16.6.1.</span> <span class="nav-text">单源最短路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#所有边的权重都为正数"><span class="nav-number">16.6.1.1.</span> <span class="nav-text">所有边的权重都为正数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#朴素Dijkstra"><span class="nav-number">16.6.1.1.1.</span> <span class="nav-text">朴素Dijkstra</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#堆优化Dijkstra"><span class="nav-number">16.6.1.1.2.</span> <span class="nav-text">堆优化Dijkstra</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#存在负权边"><span class="nav-number">16.6.1.2.</span> <span class="nav-text">存在负权边</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Bellman-Ford"><span class="nav-number">16.6.1.2.1.</span> <span class="nav-text">Bellman-Ford</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Within-K-Stops"><span class="nav-number">16.6.1.2.1.1.</span> <span class="nav-text">Within K Stops</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SPFA算法"><span class="nav-number">16.6.1.2.2.</span> <span class="nav-text">SPFA算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多源汇最短路"><span class="nav-number">16.6.2.</span> <span class="nav-text">多源汇最短路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Floyd算法"><span class="nav-number">16.6.2.1.</span> <span class="nav-text">Floyd算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最小生成树"><span class="nav-number">16.7.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#prim算法"><span class="nav-number">16.7.1.</span> <span class="nav-text">prim算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kruskal-算法"><span class="nav-number">16.7.2.</span> <span class="nav-text">kruskal 算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二分图"><span class="nav-number">16.8.</span> <span class="nav-text">二分图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#染色法"><span class="nav-number">16.8.1.</span> <span class="nav-text">染色法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匈牙利算法"><span class="nav-number">16.8.2.</span> <span class="nav-text">匈牙利算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图的连通"><span class="nav-number">16.9.</span> <span class="nav-text">图的连通</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Union-Find-Set"><span class="nav-number">16.10.</span> <span class="nav-text">Union Find Set</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#区间和-最值查询"><span class="nav-number">17.</span> <span class="nav-text">区间和/最值查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Sparse-Table算法-数组给定不变"><span class="nav-number">17.0.1.</span> <span class="nav-text">Sparse_Table算法 (数组给定不变)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线段树-数组可变"><span class="nav-number">17.0.2.</span> <span class="nav-text">线段树 (数组可变)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在线算法-amp-离线算法"><span class="nav-number">18.</span> <span class="nav-text">在线算法 &amp; 离线算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#最近公共祖先离线算法"><span class="nav-number">18.1.</span> <span class="nav-text">最近公共祖先离线算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#时间复杂度"><span class="nav-number">19.</span> <span class="nav-text">时间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Q-amp-A"><span class="nav-number">19.1.</span> <span class="nav-text">Q&amp;A</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Tutorials"><span class="nav-number">20.</span> <span class="nav-text">Tutorials</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#算法Youtube-channel"><span class="nav-number">20.1.</span> <span class="nav-text">算法Youtube channel</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lizzy llq</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
