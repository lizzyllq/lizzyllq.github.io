<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="计算机基础计算机系统计算机系统：硬件，软件，指令系统(硬件与软件的界面，硬件能识别的二进制指令集合) 硬件：输入设备/输出设备/外存储器     内存储器   cpu 软件： 应用软件  系统软件(操作系统) 中间件(提供系统软件和应用软件之间链接的软件) 软件 = 程序 + 文档 计算机语言计算机语言：程序员与计算机沟通的语言，描述解决问题的方法和相关数据 ​">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ learning">
<meta property="og:url" content="http://yoursite.com/2019/11/12/c++/index.html">
<meta property="og:site_name" content="Forward">
<meta property="og:description" content="计算机基础计算机系统计算机系统：硬件，软件，指令系统(硬件与软件的界面，硬件能识别的二进制指令集合) 硬件：输入设备/输出设备/外存储器     内存储器   cpu 软件： 应用软件  系统软件(操作系统) 中间件(提供系统软件和应用软件之间链接的软件) 软件 = 程序 + 文档 计算机语言计算机语言：程序员与计算机沟通的语言，描述解决问题的方法和相关数据 ​">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-11-12T08:10:09.093Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ learning">
<meta name="twitter:description" content="计算机基础计算机系统计算机系统：硬件，软件，指令系统(硬件与软件的界面，硬件能识别的二进制指令集合) 硬件：输入设备/输出设备/外存储器     内存储器   cpu 软件： 应用软件  系统软件(操作系统) 中间件(提供系统软件和应用软件之间链接的软件) 软件 = 程序 + 文档 计算机语言计算机语言：程序员与计算机沟通的语言，描述解决问题的方法和相关数据 ​">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/11/12/c++/">





  <title>C++ learning | Forward</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Forward</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/12/c++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lizzy llq">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Forward">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++ learning</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-12T15:58:30+08:00">
                2019-11-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h2 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h2><p>计算机系统：硬件，软件，<strong>指令系统</strong>(硬件与软件的界面，<strong>硬件能识别的二进制指令集合</strong>)</p>
<p>硬件：输入设备/输出设备/外存储器     内存储器   cpu</p>
<p>软件： 应用软件  系统软件(操作系统) 中间件(提供系统软件和应用软件之间链接的软件)</p>
<p><strong>软件 = 程序 + 文档</strong></p>
<h2 id="计算机语言"><a href="#计算机语言" class="headerlink" title="计算机语言"></a>计算机语言</h2><p>计算机语言：程序员与计算机沟通的语言，描述解决问题的方法和相关数据</p>
<p>​                       机器语言(二进制代码)  汇编语言(助记符，抽象层次并没有提高)  高级语言(类似英语单词，语句)</p>
<p>程序设计方法：面向过程  面向对象  泛型</p>
<p>面向对象：对象  类（抽象）  封装(安全易用)  消息通信  继承  多态(同样的消息作用在不同对象有可能引起不同的行为)</p>
<p>c++程序的开发过程：算法设计 源程序编辑  编译 连接  测试 调试  执行</p>
<p>源程序   =翻译》 目标程序(二进制的机器语言程序)  =连接(eg 连接程序库)》 可执行程序</p>
<p>翻译程序：汇编程序(翻译汇编语言)   编译程序  解释程序(边翻译边执行)   </p>
<p>c++(编译)    java(半编译半解释, java虚拟机)   Python(解释)</p>
<h2 id="信息在计算机中的表示与存储"><a href="#信息在计算机中的表示与存储" class="headerlink" title="信息在计算机中的表示与存储"></a>信息在计算机中的表示与存储</h2><p>计算： 算数运算  逻辑运算</p>
<p>计算机内部的信息： 控制信息  数据信息(数值信息：整数  实数，非数值信息：字符数据 逻辑数据)</p>
<p>信息的存储单位： 位bit  字节 Byte  (1KB=1024B  1MB=1024KB  1GB=1024MB)</p>
<p>进制 : 十进制  八进制  十六进制 </p>
<p>负数(补码)：零的表示为1       符号位可作为数值参与运算</p>
<p><strong>一个数减去一个数和加上它的补数效果一样</strong></p>
<p>！！数据有表示范围，只能保证在范围内的运算正确</p>
<p>小数：定点方式(特别大的数和特别小的数没法表示)  浮点方式($N=M*2^E$)</p>
<p>字符数据： 编码  ASCII(7位二进制数，最多可表示$2^7$个字符)</p>
<h1 id="数据和基本运算"><a href="#数据和基本运算" class="headerlink" title="数据和基本运算"></a>数据和基本运算</h1><p>c++字符集：大小写英文字母  数字字符  特殊字符</p>
<p>词法记号：关键字(预定义单词) 标志符(程序员声明的单词) 文字(直接使用符号表示的数据) 分隔符 运算符 空白符</p>
<p>标志符命名规则：以大小写字母或下划线开始，由大小写字母或下划线或数字构成，对大小写敏感，不能是关键字或操作符</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>计算机的最基本功能：数据处理</p>
<p>数据：变量  常量</p>
<p>常量：在程序运行过程中其值始终不可改变的值，直接使用文字表示的值为常量/ 符号常量</p>
<p>整数常量：十进制(若干0~9的数字，但不可以0开头)    八进制(前缀为0)   十六进制(前缀为0x)</p>
<p>​                    默认为int    后缀U或u: unsigned   L或l: long    LL或ll: long long </p>
<p>​                    负数 前面加-</p>
<p>浮点数常量：默认为double   后缀F或f为float</p>
<p>​                      一般形式 12.5  -12.5         </p>
<p>​                       指数形式  0.345E+2   -34.4E-3   整数部分和小数部分可以省略其一</p>
<p>字符常量：单引号括起来的字符       有些字符无法在屏幕显示，用转义字符表示</p>
<p>字符串常量：双引号括起来的字符</p>
<p>符号常量：const 数据类型说明符 常量名 = 常量值 或  数据类型说明符  const  常量名 = 常量值</p>
<p>​                  符号常量在定义时一定要进行初始化，在程序中间不能修改值</p>
<p>为了存储数据，需要预先为这些数据分配内存空间变量的定义就是在给变量命名的时候分配内存空间</p>
<p>整数类型：short         int(默认signed)/ unsigned int           long          long long</p>
<p>实数类型:  float     double     long double </p>
<p>​                    (浮点数不是一个准确的值，要比较两个浮点数是否相等，应看两数之差是否足够小)</p>
<p>字符类型:  char(单引号 容纳单个字符的编码，实质上存储的也为整数：字符的ascii码)</p>
<p>字符串类型：有字符串常量(双引号)，基本类型中没有字符串变量</p>
<p>​                      用字符数组(末尾添加’\0’作为结束标记)  或 STL中的string类 存储</p>
<p>布尔类型: true  false</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>基本算数运算符：+ - * /(若整数相除，结果取整)     %(取余，操作数为整数)</p>
<p>​                               优先级：先乘除，后加减，同级从左至右</p>
<p>​                                自增++   自减—</p>
<p>赋值运算符： =   (赋值表达式的值为赋值运算符左边对象被赋值后的值，类型为赋值运算符左边对象的类型)</p>
<p>复合赋值运算符(10种)： +=    -=   *=   /=    %=    &lt;&lt;=    &gt;&gt;=    &amp;=  ^=  |=</p>
<p>逗号运算符：表达式1,表达式2     (先求解表达式1，后求解表达式2， 最终结果为表达式2的值)</p>
<p>关系运算符：&lt;  &lt;= &gt; &gt;=  (优先级高)           ==  !=  (优先级低)       结果为bool类型</p>
<p>逻辑运算符： (优先级从高到低)    !     &amp;&amp;   ||    结果为bool类型       短路特性</p>
<p>条件运算符：表达式1  ?  表达式2: 表达式3     (表达式1必须为bool类型)</p>
<p>sizeof运算符:   sizeof(类型名)      sizeof(表达式)    返回</p>
<p>位运算符:  ~   &amp;     |    ^（与0异或保持原值，与1异或取反）</p>
<p>移位运算符：&lt;&lt; (低位补0，高位舍弃)    &gt;&gt; 低位舍弃，高位：无符号数补0，有符号数补符号位</p>
<p>​                      &lt;\<1 相当于乘2(若符号位变化，说明在*2的含义下该运算溢出)>&gt; 1相当于除2</1></p>
<p>运算优先级</p>
<p>类型转换：一些二元运算符(算数运算符, 关系运算符, 逻辑运算符,位运算符,  赋值运算符)要求两个操作数类型一     致，若不一致，会隐含的转换；   显示转换：类型转换操作符&lt;类型说明符&gt;(表达式)      static_cast</p>
<h2 id="输入-输出"><a href="#输入-输出" class="headerlink" title="输入/输出"></a>输入/输出</h2><p>cin 预定义的标准输入流对象       &gt;&gt; 预定义的提取运算符</p>
<p>cout 预定义的标准输出流对象     &lt;&lt; 预定义的插入运算符</p>
<p>操纵符：dec   hex   oct     ws提取空白符    endl    ends插入空字符     setsprecision(int)设置浮点数的小数位数      </p>
<p>​                setw(int)设置域宽</p>
<h2 id="选择结构-循环结构"><a href="#选择结构-循环结构" class="headerlink" title="选择结构/循环结构"></a>选择结构/循环结构</h2><p>if                          else if                    else</p>
<p>swith  case   default   break</p>
<p>for(; ;)       for(声明:表达式)范围for循环，用于遍历容器          while           do while</p>
<p>break   continue</p>
<h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>typedef 已有类型名   别名</p>
<p>枚举类型    enum   数据合法性检验   ： enum 枚举类型名  {枚举常量}</p>
<p>enum Weekday {SUN, MON, TUE, WED, THU, FRI, SAT}    默认值0 1 2 3 4 5 6</p>
<p>auto 编译器根据初始值自动推断变量的类型</p>
<p>decltype  定义一个变量与某一表达式的类型相同，但并不用该表达式初始化变量 eg: decltype(i)  j = 2</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数： 程序的功能模块</p>
<h2 id="函数定义-函数调用"><a href="#函数定义-函数调用" class="headerlink" title="函数定义  函数调用"></a>函数定义  函数调用</h2><p>函数定义   形参(不分配空间，形实结合才分配空间)</p>
<p>若函数定义不在当前文件或在当前函数之后，函数调用之前需要函数原型声明</p>
<p>嵌套调用     用栈保存当前现场和返回地址 </p>
<p>递归(函数直接或间接调用自身)   递归深入  递归终止条件</p>
<p>随机函数  int rand(void) 所需头文件<cstdlib>  求出并返回一个伪随机数</cstdlib></p>
<p>随机数种子   void srand(unsigned int seed)       所需头文件&lt;cstdlib  为rand()产生一序列伪随机数设置起始点</p>
<h2 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h2><p>值传递：  单向传递</p>
<p>指针传递  </p>
<p>引用传递：双向传递  （传递的数据安全性：不希望双向传递时，常引用）</p>
<p><strong>引用</strong>是标志符的别名，定义一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象 ，并且不可以再指向别的对象，引用可以作为形参，形实结合时，对形参进行初始化，不分配内存</p>
<p>含有可变参数的函数：</p>
<ul>
<li>若所有实参的类型相同：传递一个名为initializer_list的标准库类型，头文件<initializer_list></initializer_list></li>
<li>若不同：编写可变参数的模板  </li>
</ul>
<p>带<strong>默认参数</strong>的函数值</p>
<ul>
<li>可预先设置默认的参数值，有默认参数的形参必须在参数列表的最右边，调用时形实结合的次序为从左到右</li>
<li>如果一个函数有原型声明，且原型声明在定义之前，则默认参数值在函数声明中给出</li>
<li>如果只有函数的定义，或函数定义在前，则默认参数值可以在函数定义给出</li>
</ul>
<p><strong>函数重载</strong></p>
<ul>
<li>c++允许功能相近的函数在相同的作用域内以相同函数名声明，从而形成重载：形参类型不同，形参个数不同</li>
</ul>
<h2 id="内联函数-constexpr函数"><a href="#内联函数-constexpr函数" class="headerlink" title="内联函数  constexpr函数"></a>内联函数  constexpr函数</h2><p>内联函数：逻辑上是一个函数，实际运行不是    inline    在编译时在调用处用函数体进行替换，节省了参数传递、控制转移等开销</p>
<p>内联函数体不能有循环语句和swith语句，内联函数的定义必须在内联函数第一次调用前，对内联函数不能进行异常接口声明     （inline是对编译器的一个建议）</p>
<p>constexpr函数：常量表达式函数，可以用来初始化常量</p>
<p>contexpr修饰的函数，在其所有参数都是contexpr时，一定返回constexpr</p>
<p>常数初始化   编译时能确定</p>
<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><p>面向对象的基本特点：抽象  封装  继承 多态</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>设计类就是设计类型：</p>
<ul>
<li>此类型的”合法值“是什么</li>
<li>此类型该有什么样的函数和操作符</li>
<li>新类型的对象如何创建和销毁</li>
<li>如何进行对象的初始化和赋值</li>
<li>对象作为函数的参数如何以值传递</li>
<li>谁将使用此类型的对象成员</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	公有成员，外部接口</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	私有成员</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        保护型成员</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以为数据成员设置类内初始值，用于初始化数据成员</p>
<p><strong>类成员的访问控制</strong></p>
<ul>
<li>public: 任何外部函数都可以访问public的数据和函数</li>
<li>private: 只允许本类中的函数访问，如果紧跟在类名称的后面声明私有成员，则关键字private可省略</li>
<li>protected：与private类似，其差别体现在继承与派生时对派生类的影响不同</li>
</ul>
<p>类的成员函数</p>
<ul>
<li>在类中声明函数原型</li>
<li>可以在类外给出函数体实现，并在函数名前使用类名加以限定</li>
<li>也可以直接在类中给出函数体，形成内联函数成员</li>
<li>允许声明重载函数和带默认参数值的函数</li>
</ul>
<p>内联成员函数</p>
<ul>
<li>未来提高运行时的效率，对于较简单的函数可以声明为内联形式</li>
<li>内联函数体不要有复杂结构(如循环语句和switch语句)</li>
<li>在类中声明内联成员函数的方式：将函数体放在类的声明中    或   使用inline关键字</li>
</ul>
<h2 id="构造函数-析构函数"><a href="#构造函数-析构函数" class="headerlink" title="构造函数 析构函数"></a>构造函数 析构函数</h2><p>构造函数：在对象被创建时使用特定的值构造对象，将对象初始化为一个特定的初始状态</p>
<p>构造函数的形式</p>
<ul>
<li>函数名与类名相同</li>
<li>不能定义返回值类型，也不能有return语句</li>
<li>可以有形式参数，也可以没有</li>
<li>可以是内联函数</li>
<li>可以重载</li>
<li>可以带默认参数值</li>
</ul>
<p>构造函数在对象创建时自动调用</p>
<p>默认构造函数：调用时不需要实参的构造函数</p>
<ul>
<li>参数表为空的构造函数</li>
<li>全部参数都有默认值的构造函数</li>
</ul>
<p>！！！参数表为空的构造函数 和 全部参数都有默认值的构造函数 如在类中同时出现  会产生<strong>编译错误</strong>，不是合法的参数重载形式</p>
<p><strong>隐含的默认构造函数</strong></p>
<p>如果程序中未定义构造函数，编译器将自动生成一个默认构造函数</p>
<ul>
<li>参数列表为空，不为数据成员设置初始值</li>
<li>如果类内定义了成员的初始值，则使用类内定义的初始值</li>
<li>如果没有定义类内的初始值，则以默认的方式初始化</li>
<li>基本类型的数据默认初始化的值是不确定的</li>
</ul>
<p>如果程序中已定义构造函数，默认情况下编译器不再自动生成一个默认构造函数，<strong>如果此时依然希望编译器隐含生成默认构造函数，可以使用      类名()=default    声明</strong></p>
<p><strong>初始化列表</strong>：对类的数据成员初始化，首选用初始化列表，比在函数体中用赋值表达式效率要高一些</p>
<p>委托构造函数  c++11</p>
<p>委托构造函数使用类的其他构造函数执行初始化过程    有助于保持代码的一致性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS): </span><br><span class="line">hour(newH), minute(newM), second(newS)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Clock(): Clock(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>复制构造函数</strong>：由一个已经存在的对象初始化一个新对象</p>
<p>复制构造函数是一种特殊的构造函数，形参为本类对象的常引用</p>
<p>调用复制构造函数的三种情况：</p>
<ul>
<li>定义一个对象时，以本类的另一个对象作为初始值</li>
<li>如果函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象</li>
<li>如果函数的返回值是类的对象，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数</li>
</ul>
<p>如果在程序中没有定义复制构造函数，编译器会自动产生一个默认的复制构造函数：实现两个对象数据成员之间的一一对应复制 ，但 eg:当类中的数据成员包含指针时，默认的复制构造函数（浅层复制）不够用</p>
<p>如果不希望对象被复制构造</p>
<ul>
<li><p>c++98做法：将复制构造函数声明为private,并且不提供函数的实现</p>
</li>
<li><p>c++11做法：用  =delete 指示编译器不生成默认的复制构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	类名(<span class="keyword">const</span> 类名&amp; p) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p><strong>析构函数</strong>:完成对象被删除前的一些清理工作，当对象的生存期结束的时候，系统自动调用析构函数</p>
<p>如果在程序中没有定义析构函数，编译器会自动产生一个默认的析构函数，其函数体为空</p>
<p>析构函数的原型：~类名()      析构函数没有参数，没有返回类型</p>
<h2 id="类的组合-UML"><a href="#类的组合-UML" class="headerlink" title="类的组合  UML"></a>类的组合  UML</h2><p>组合的概念：</p>
<ul>
<li>类中的成员是另一个类的对象</li>
<li>可以在已有抽象的基础上实现更复杂的抽象</li>
</ul>
<p>组合类的构造函数：不仅要对本类中的基本类型成员数据初始化，也要对对象成员初始化</p>
<p>定义形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类名::类名(对象成员需要的形参,本类成员形参):</span><br><span class="line">     对象<span class="number">1</span>(参数),对象<span class="number">2</span>(参数),...  <span class="comment">// 初始化次序按成员在类体中声明的次序，未在初始化列表中出现的对象成员，用对应类的默认构造函数初始化</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 函数体其他语句      </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前向引用声明</p>
<ul>
<li>类应该先声明后使用</li>
<li>如果需要在某一个类的声明之前，引用该类，则应进行前向引用声明  (两个类互相引用的情况)</li>
<li>前向引用声明只为程序引入一个标志符，但具体声明在其他地方</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span> <span class="comment">//前向引用声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">         <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(B b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(A a)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>在提供一个完整的类声明之前，不能声明该类的对象，也不能在内联函数成员中使用该类的对象</li>
<li>当使用前向引用声明时，只能使用被声明的符号，而不能涉及类的任何细节</li>
</ul>
<p>UML语言</p>
<p>事物  关系  图</p>
<p>依赖  关联  聚合  继承</p>
<h2 id="结构体-联合体"><a href="#结构体-联合体" class="headerlink" title="结构体 联合体"></a>结构体 联合体</h2><p>结构体是一种特殊的类，与类唯一的区别：</p>
<ul>
<li>类的缺省访问权限：private</li>
<li>结构体的缺省访问权限: public</li>
</ul>
<p>什么时候用结构体而不用类</p>
<ul>
<li>定义主要用来保存数据，而没有什么操作的类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名称&#123;</span></span><br><span class="line">       公有成员</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">       保护型成员</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       私有成员</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果一个结构体的全部数据成员都是公共成员，没有用户定义的构造函数，没有基类和虚函数：这个结构体的变量可用下面的语法形式初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名 变量名 = &#123;成员数据<span class="number">1</span>初值, 成员数据<span class="number">1</span>初值,...&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>联合体</p>
<ul>
<li>成员共用同一组内存单元// 按最多字节数的数据分配空间</li>
<li>任何两个成员不会同时有效</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> 结构体名称&#123;</span><br><span class="line">       公有成员</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">       保护型成员</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       私有成员</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>枚举类：强类型的枚举   c++11</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> 枚举类型名:</span>底层类型&#123;枚举值列表&#125;; <span class="comment">//默认底层类型为int</span></span><br></pre></td></tr></table></figure>
<p>优势：</p>
<ul>
<li><p>强作用域</p>
<p>使用Type的枚举值General    Type::General</p>
</li>
<li><p>转换限制</p>
<p>枚举类对象不可以和整形隐式的互换</p>
</li>
<li><p>可以指定底层类型</p>
</li>
</ul>
<h1 id="数据的共享与保护"><a href="#数据的共享与保护" class="headerlink" title="数据的共享与保护"></a>数据的共享与保护</h1><p>变量和对象定义在不同的位置（函数体内，类体内，函数原型参数表内，所有函数和类之外），其作用域，可见性，生存期都不同</p>
<h2 id="标志符作用域和可见性"><a href="#标志符作用域和可见性" class="headerlink" title="标志符作用域和可见性"></a>标志符作用域和可见性</h2><p>作用域分类： 由小到大</p>
<ul>
<li>函数原型作用域</li>
</ul>
<p>​       函数原型中的参数；其作用域始于”(“,结束于”)”</p>
<ul>
<li><p>局部作用域（块作用域）</p>
<p>函数定义中的形参，在块中声明的标志符；其作用域自声明处起，限于块中</p>
</li>
<li><p>类作用域</p>
<p>类的成员具有类作用域，其范围包括类体和成员函数体，在类作用域以外访问类的成员：</p>
<ul>
<li>静态成员：通过类名或者该类的对象名，对象引用访问</li>
<li>非静态成员：通过该类的对象名，对象引用，对象指针访问</li>
</ul>
</li>
<li><p>文件作用域</p>
<p>不在前述各个作用域出现的声明具有文件作用域；其作用域始于声明点，结束于文件尾</p>
</li>
<li><p>命名空间作用域</p>
</li>
</ul>
<hr>
<p>可见性：表示从内层作用域向外层作用域看能看见什么，如果标志符在某处可见，就可以在该处引用此标志符</p>
<ul>
<li>如果某个标志符在外层中声明且在内层中没有统一标志符的声明，则该标志符在内层可见</li>
<li>对于两个嵌套的作用域，如果在内层作用域声明了和外层作用域同名的标志符，则外层作用域的标志符在内层不可见</li>
</ul>
<h2 id="对象的生存期"><a href="#对象的生存期" class="headerlink" title="对象的生存期"></a>对象的生存期</h2><p>静态生存期：与程序的运行期相同；在文件作用域声明的对象具有这种生存期，在函数内部声明静态生存期对象要用关键字static</p>
<p>动态生存期：开始于程序执行到声明点时，结束语命名该标志符的作用域结束处；块作用域中生命的，没有用static修饰的对象是动态生存期的对象（局部生存期对象）</p>
<h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><p>静态数据成员</p>
<ul>
<li>用static声明，为该类的所有对象共享，具有静态生存期</li>
<li>声明在类体内，但必须在类外定义和初始化，用::来指明所属的类</li>
</ul>
<p>静态函数成员:主要用于处理该类的静态数据，不能用来直接访问非静态数据，只能通过对象来访问非静态数据</p>
<h2 id="类的友元"><a href="#类的友元" class="headerlink" title="类的友元"></a>类的友元</h2><p>friend</p>
<ul>
<li>友元是c++提供的一种破坏数据封装和数据隐藏的机制（隐藏和效率的平衡）</li>
<li>通过将一个模块声明为另一个模块的友元，一个模块能引用另一个模块中被隐藏的信息</li>
<li>可以声明友元函数或友元类</li>
<li>为了确保数据的完整性，以及数据封装和隐藏的原则，慎用</li>
</ul>
<p>友元函数：</p>
<ul>
<li>在类中声明由关键字friend修饰的非成员函数，在其函数体中通过传递的对象参数访问private和protected成员</li>
<li>访问对象中的成员必须通过对象名</li>
</ul>
<p>友元类</p>
<ul>
<li><p>将友元类名在另一个类中用friend修饰声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> 类名;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>若一个类是另一个类的友元，则此类的所有成员都能访问对方类的私有成员</p>
</li>
<li>类的友元关系是单向的</li>
</ul>
<h2 id="共享数据的保护"><a href="#共享数据的保护" class="headerlink" title="共享数据的保护"></a>共享数据的保护</h2><p>const  常类型</p>
<ul>
<li><p>常对象：必须进行初始化，不能被更新    const 类名 对象名;</p>
</li>
<li><p>常成员：用const修饰的类成员，常数据成员，常函数成员</p>
<ul>
<li><p>常数据成员：不能被修改，同时它只能在构造函数的初始化列表中赋值，不能在函数体中初始化，不能被非常成员函数访问</p>
</li>
<li><p>常成员函数不更新对象的数据成员，常对象只能调用其常成员函数，常成员函数不能调用非常成员函数，可以访问常数据成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类型说明符 函数名(参数表) <span class="keyword">const</span>; <span class="comment">// const是函数类型的一个组成部分；声明，实现部分都要带const</span></span><br><span class="line"><span class="comment">// const 可用于参与对重载函数的区分</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>常引用：被引用的对象不能被更新    construction 类型说明符 &amp; 引用名</p>
<p>既可以提高参数传递的效率，同时保证实参的安全性</p>
</li>
<li><p>常数组：数组元素不能被更新  const 数组名[大小]</p>
</li>
<li><p>常指针：指向常量的指针</p>
</li>
</ul>
<h2 id="多文件结构和预编译命令"><a href="#多文件结构和预编译命令" class="headerlink" title="多文件结构和预编译命令"></a>多文件结构和预编译命令</h2><p>编译预处理</p>
<p>c++程序的一版组织结构：</p>
<ul>
<li>一个工程一般可以划分为多个源文件，如<ul>
<li>类声明文件(.h文件)</li>
<li>类实现文件(.cpp文件)</li>
<li>类的使用文件(main()所在的.cpp文件)</li>
</ul>
</li>
<li>利用工程来组合各个文件</li>
</ul>
<hr>
<p>外部变量</p>
<ul>
<li>除了在定义它的源文件中可以使用外，还能被其他文件使用</li>
<li>文件作用域中定义的变量默认情况下是外部变量</li>
<li>在其他文件中如果需要使用，需要用extern关键字声明</li>
</ul>
<p>外部函数</p>
<ul>
<li>在所有类之外声明的函数(非成员函数)，都是具有文件作用域的</li>
<li>这样的函数都快可以在不同的编译单元中被调用</li>
<li>只要在调用之前使用引用性声明（声明函数原型）即可</li>
</ul>
<p>将变量和函数限制在编译单元内：在匿名命名空间中定义的变量和函数，都不会暴露给其他的编译单元</p>
<hr>
<p><strong>标准c++库</strong>是一个极为灵活并可扩展的可重用的软件模块的集合，在逻辑上分为6种类型：</p>
<ul>
<li>输入/输出类</li>
<li>容器类和抽象数据类型</li>
<li>存储管理类</li>
<li>算法</li>
<li>错误处理</li>
<li>运行环境支持</li>
</ul>
<hr>
<p>编译预处理</p>
<p>#include 包含指令 : 将一个源文件嵌入到当前源文件中该点处</p>
<ul>
<li>#include &lt;文件名&gt;  按标准方式搜索，文件位于c++系统目录的include子目录下</li>
<li>#include “文件名”  首先在当前目录中搜索，若没有则再按标准方式搜索</li>
</ul>
<p>#define 宏定义指令</p>
<ul>
<li>定义符号常量，很多情况被const取代</li>
<li>定义带参数宏，被内联函数取代</li>
</ul>
<p>#undef 删除由#define定义的宏，使之不再起作用</p>
<p>条件编译指令  #if    (#elif)    (#else)   #endif</p>
<p>#ifdef 标志符  （如果标志符经#define定义过，且未经#undef删除，防止重复定义）</p>
<p>#ifndef 标志符 </p>
<h1 id="数组-指针-字符串"><a href="#数组-指针-字符串" class="headerlink" title="数组 指针 字符串"></a>数组 指针 字符串</h1><h2 id="数组的定义与初始化"><a href="#数组的定义与初始化" class="headerlink" title="数组的定义与初始化"></a>数组的定义与初始化</h2><p>数组是具有一定顺序关系的若干相同类型变量的集合体，组成数组的变量称为该数组的元素</p>
<p>数组的定义：类型说明符 数组名[常量表达式][常量表达式]…;</p>
<p>数组名的构成方法和一般变量名相同</p>
<p>数组元素在内存中顺次存放，他们的地址是连续的，元素间物理位置的相邻，对应着逻辑次序的相邻</p>
<ul>
<li>数组名是数组首元素的内存地址</li>
<li>数组名是一个常量，不能被赋值</li>
</ul>
<hr>
<p>一维数组的初始化</p>
<ul>
<li><p>列出全部元素的初始值   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出部分元素的初始值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>二维数组的初始化</p>
<ul>
<li><p>列出全部元素的初始值  【列出全部元素的初始值时，第一维下标可省略】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> a[][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出部分元素的初始值 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果不做任何初始化，局部作用域的非静态数组中会存在垃圾数据，static数组中的数据默认初始化为0</p>
<p>如果只对部分元素初始化，剩下的未显示初始化的元素会自动被初始化为0</p>
<h2 id="数组作为函数的参数"><a href="#数组作为函数的参数" class="headerlink" title="数组作为函数的参数"></a>数组作为函数的参数</h2><ul>
<li>数组元素作为实参，与单个变量一样</li>
<li>数组名作为参数，形参实参都应是数组名，类型要一样，传送的是数组首地址，对形参数组的改变会直接影响到实参数组</li>
</ul>
<h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><p>定义对象数组： 类名 数组名[元素个数];</p>
<p>访问对象数组： 数组名[下标].成员名</p>
<p>对象数组的初始化： Point a[2] = {Point(1,2), Point(3,4)};</p>
<p>如果没有为数组元素指定显示初始值，数组元素便使用默认值初始化（调用默认构造函数） Point a[2];</p>
<p><strong>数组元素的构造与析构</strong></p>
<ul>
<li>构造数组时，元素所属的类为声明构造函数，则采用默认构造函数</li>
<li>各元素对象的初值要求为相同的值时，可以声明具有默认形参值的构造函数</li>
<li>各元素对象的初值要求为不同的值时，需要声明带形参的构造函数</li>
<li>当数组中的每一个对象被删除时，系统都要调用一次析构函数</li>
</ul>
<p>基于范围的for循环   c++11</p>
<p>自动遍历整个容器</p>
<h2 id="指针的定义与运算"><a href="#指针的定义与运算" class="headerlink" title="指针的定义与运算"></a>指针的定义与运算</h2><p>内存空间的访问方式</p>
<ul>
<li>通过变量名访问</li>
<li>通过地址访问</li>
</ul>
<p>指针：内存地址，用于间接访问内存单元（必须是程序运行期间合法获得的）</p>
<p>指针变量：用于存放地址的变量 </p>
<p>指针变量初始化:   数据类型* 指针名 = 初始地址;</p>
<ul>
<li>用变量地址作为初值时，该变量必须在指针初始化之前已经声明过，且变量类型应和指针类型一致</li>
<li>可以用一个已有的合法的指针去初始化另一个指针变量</li>
<li>不要用内部非静态变量的地址去初始化static指针</li>
</ul>
<p>指针变量的赋值： 指针名 = 地址;</p>
<ul>
<li><p>地址中存放的数据类型与指针类型必须相符，向指针变量赋值的必须是指针常量或变量，不能是普通整数</p>
<p>如：通过地址运算符&amp;求得已定义的变量和对象的起始地址，动态内存分配成功时返回的地址</p>
</li>
<li><p>但整数0可以赋给指针，表示空指针  | c++11中使用nullptr表达更准确，类型安全的空指针</p>
</li>
<li><p>允许定义或声明指向void类型的指针，该指针可以被赋予任何类型对象的地址   void* general; </p>
<p>void指针可以容纳地址，但不能去访问地址，必须转化为具体类型的指针才能访问地址</p>
</li>
</ul>
<p>指向常量的指针： const 数据类型* 指针名</p>
<ul>
<li>不能通过指向常量的指针改变所指对象的值，但指针本身可以改变，可以指向另外的对象</li>
</ul>
<p>指针常量： 数据类型*  const 指针名</p>
<ul>
<li>指针本身的值不能被改变</li>
</ul>
<p>指针的运算</p>
<ul>
<li>算数运算：与整数的加减运算，++,  —<ul>
<li>指针p加上n或减去n:指针当前指向位置的前方或后方第n个数据(取决于指针指向的数据类型)的起始位置</li>
<li>只有当指针指向连续存储的同类型数据时，指针与整数的加减运算和自增减运算才有意义</li>
</ul>
</li>
<li>关系运算<ul>
<li>指向相同类型数据的指针之间可以进行各种关系运算</li>
<li>指向不同类型数据的指针之间以及指针与一般整数变量之间的关系运算是无意义的</li>
<li>指针可以和0之间进行等于或不等于的关系运算</li>
</ul>
</li>
</ul>
<p>floor()  向下取整</p>
<p>floor(x+0.5)  四舍五入</p>
<p>floor(x*100+0.5)/100  保留小数点后两位数</p>
<h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], *pa;</span><br><span class="line">pa = &amp;a[<span class="number">0</span>];<span class="comment">// 或 pa=a;</span></span><br><span class="line"><span class="comment">// a[i], *(pa+i), *(a+i), pa[i]都是等效的</span></span><br></pre></td></tr></table></figure>
<p>指针数组：数组的元素是指针类型</p>
<p>二维数组 等价于  一维指针数组  （实际存储有差别）</p>
<h2 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h2><p>以指针作为函数参数</p>
<ul>
<li>需要数据双向传递时（引用也可达到此效果）    (入口参数，出口参数)</li>
<li>需要传递一组数据，只传首地址效率高 （vector的引用）     指向常量的指针</li>
</ul>
<p>最小授权原则</p>
<p>指针类型的函数：函数的返回类型是指针类型</p>
<ul>
<li>不要将非静态的局部地址作为函数的返回值   （非法地址）</li>
<li>在子函数中通过动态内存分配取得的内存地址返回给主函数是合法有效的，但是内存分配和释放不在同一级别，要注意不能忘记释放，避免内存泄漏</li>
</ul>
<p><strong>指向函数的指针</strong>  (函数名其实就是函数的地址)</p>
<p>函数指针指向的是程序代码存储区    数据类型 (*函数指针名)(参数表);</p>
<p>函数指针的典型用途：实现函数回调</p>
<ul>
<li><p>通过函数指针调用的函数</p>
<ul>
<li>例如将函数的指针作为参数传递给一个函数，使得在处理相似时间的时候可以灵活的使用不同的方法</li>
</ul>
</li>
<li><p>调用者不关心谁是被调用者</p>
<ul>
<li>需知道存在一个具有特定原型和限制条件的被调用函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>(*func)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> func(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="对象指针"><a href="#对象指针" class="headerlink" title="对象指针"></a>对象指针</h2><p>用来容纳对象地址的指针</p>
<p>通过指针访问对象成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;getx(); <span class="comment">// (*ptr).getx()</span></span><br></pre></td></tr></table></figure>
<p>this指针</p>
<ul>
<li>隐含于类的每一个非静态成员函数中</li>
<li>指出成员函数所操作的对象<ul>
<li>当通过一个对象调用成员函数时，系统现将该对象的地址赋给this指针，然后调用成员函数，成员函数对对象数据进行操作时，就隐含使用了this指针</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fred</span>;</span> <span class="comment">//前向引用声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Barney</span> &#123;</span></span><br><span class="line">    Fred * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fred</span> &#123;</span></span><br><span class="line">    Barney y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态内存分配和释放"><a href="#动态内存分配和释放" class="headerlink" title="动态内存分配和释放"></a>动态内存分配和释放</h2><p>new 类型名T (初始化参数列表)   // 调用构造函数</p>
<ul>
<li>在程序执行期间，申请用于存放T类型对象的内存空间，并依据初始值列表赋以初值</li>
<li>成功：返回T类型的指针，指向新分配的内存</li>
<li>失败：跑出异常</li>
</ul>
<p>delete 指针p</p>
<ul>
<li>释放指针p所指向的内存</li>
<li>p必须是new操作的返回值</li>
</ul>
<p>分配和释放动态数组</p>
<ul>
<li>分配 new 类型名T[数组长度]<ul>
<li>数组长度可以是任何整数类型表达式，在运行时计算</li>
</ul>
</li>
<li>释放  delete[] 数组名p<ul>
<li>释放指针p所指向的数组</li>
<li>p必须是new分配得到的数组首地址</li>
</ul>
</li>
</ul>
<p>分配和释放多维数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>(*fp)[<span class="number">3</span>];</span><br><span class="line">fp = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">// fp+1 跨越一整行</span></span><br><span class="line"><span class="keyword">delete</span>[] fp;</span><br></pre></td></tr></table></figure>
<p>智能指针 c++11</p>
<ul>
<li>unique_ptr  不允许多个指针共享资源，可以用标准库中的move函数转移指针</li>
<li>share_ptr 多个指针共享资源</li>
<li>weak_ptr 可复制shared_ptr, 但其构造或者释放对资源不产生影响</li>
</ul>
<p>将动态数组封装为一个类</p>
<p>vector</p>
<ul>
<li>封装任何类型的动态数组，自动创建和删除</li>
<li>数组下标越界检查</li>
</ul>
<h2 id="对象复制与移动"><a href="#对象复制与移动" class="headerlink" title="对象复制与移动"></a>对象复制与移动</h2><p>浅层复制 ：实现对象间数据元素的一一对应复制</p>
<p>深层复制：当被复制的对象数据成员是指针类型时，不是复制该指针成员本身，而是将指针所指对象进行复制</p>
<p>移动构造   （不需要副本）c++11</p>
<ul>
<li>将源对象的资源控制权全部交给目标对象</li>
</ul>
<p>移动构造函数</p>
<ul>
<li>当临时对象在复制后，就不再被利用了，我们完全可以把临时对象的资源直接移动，这样就避免了多余的复制操作</li>
</ul>
<p>例如当函数返回含有指针成员的对象</p>
<ul>
<li><p>A:使用深层复制构造函数</p>
<ul>
<li>返回时临时构造临时对象，动态分配将临时对象返回到主调函数，然后删除临时对象</li>
</ul>
</li>
<li><p>B:使用移动构造函数</p>
<ul>
<li><p>将要返回的局部对象转移到主调函数，省去了构造和删除临时对象的过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className(className &amp;&amp; 对象名);</span><br><span class="line"><span class="comment">// &amp;&amp;为右值引用，即将消亡的值为右值，函数返回的临时变量为右值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串常量</p>
<ul>
<li>双引号括起来，如”program”</li>
<li>各字符连续，顺序存放，每个字符占一个字节，以’\0’结尾，相当于隐含创建的字符常量数组</li>
<li>“program”出现在表达式中，表示这一char数组的首地址</li>
<li>首地址可以赋给char常量指针：const char* STRING1 = “program”;</li>
</ul>
<p>c风格字符串：用字符数组存储字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">8</span>] = &#123;<span class="string">'p'</span>,<span class="string">'r'</span>,<span class="string">'o'</span>,<span class="string">'g'</span>,<span class="string">'r'</span>,<span class="string">'a'</span>,<span class="string">'m'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="comment">// char str[8] = "program";</span></span><br><span class="line"><span class="comment">// char str[] = "program";</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行连接，拷贝，比较等操作，都需要显示调用库函数</li>
<li>当字符串长度很不确定时，需要用new动态创建字符数组，最后用delete释放</li>
<li>字符串实际长度大于为它分配的空间时，会产生数组下标越界的错误</li>
</ul>
<p>string类：封装起来的字符数组</p>
<p>输入整行字符串: getline    (#include\<string>) 从标准输入设备键盘读取一串字符串，并以指定的结束符结束</string></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getline(<span class="built_in">cin</span>,s);</span><br><span class="line">getline(<span class="built_in">cin</span>,s,<span class="string">','</span>);</span><br></pre></td></tr></table></figure>
<h1 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h1><h2 id="继承的基本概念与语法"><a href="#继承的基本概念与语法" class="headerlink" title="继承的基本概念与语法"></a>继承的基本概念与语法</h2><p>继承和派生是同一过程从不同角度看</p>
<ul>
<li>保持已有类(基类)的特性而构造新类(派生类)的过程称为继承</li>
<li>在已有类的基础上新增自己的特性而产生新类的过程称为派生</li>
<li>直接参与派生出某类的基类称为直接基类</li>
<li>基类的基类甚至更高层的基类称为简介基类</li>
</ul>
<p>继承的目的：实现设计与代码的重用</p>
<p>派生的目的：当新的问题出现，原有程序无法解决或不能完全解决时，需要对原有程序进行改造</p>
<p>单继承：派生类只从一个直接基类继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span> 继承方式 基类名&#123;</span><br><span class="line">    成员声明;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 派生类名:</span> 继承方式<span class="number">1</span> 基类名<span class="number">1</span>, 继承方式<span class="number">2</span> 基类名<span class="number">2</span>,...&#123;</span><br><span class="line">    成员声明;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>派生类的构成：</p>
<ul>
<li>吸收基类成员<ul>
<li>默认情况下派生类包含了基类除构造和析构函数之外的所有成员</li>
<li>c++11 规定可以用using语句继承基类的构造函数</li>
</ul>
</li>
<li>改造基类成员<ul>
<li>如果派生类声明了一个和某基类成员同名的新成员，派生的新成员就隐藏或覆盖了外层同名成员</li>
</ul>
</li>
<li>添加新的成员<ul>
<li>派生类增加新成员使派生类在功能上有所发展</li>
</ul>
</li>
</ul>
<h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><p>不同继承方式的影响主要体现在</p>
<ul>
<li>派生类成员对基类成员的访问权限</li>
<li>通过派生类对象对基类成员的访问权限</li>
</ul>
<p><strong>三种继承方式</strong></p>
<ul>
<li>public 公有继承<ul>
<li>继承的访问控制<ul>
<li>基类的public和protected成员：访问属性在派生类中保持不变</li>
<li>基类的private成员：不可直接访问</li>
</ul>
</li>
<li>访问权限<ul>
<li>派生类的成员函数：可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员</li>
<li>通过派生类的对象：只能访问public成员</li>
</ul>
</li>
</ul>
</li>
<li>private 私有继承<ul>
<li>继承的访问控制<ul>
<li>基类的public和protected成员：访问属性在派生类中变为private</li>
<li>基类的private成员：不可直接访问</li>
</ul>
</li>
<li>访问权限<ul>
<li>派生类的成员函数：可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员</li>
<li>通过派生类的对象：不能直接访问从基类继承的任何成员</li>
</ul>
</li>
</ul>
</li>
<li>Protected 保护型继承<ul>
<li>继承的访问控制<ul>
<li>基类的public和protected成员：访问属性在派生类中变为protected</li>
<li>基类的private成员：不可直接访问</li>
</ul>
</li>
<li>访问权限<ul>
<li>派生类的成员函数：可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员</li>
<li>基类的private成员：不可直接访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>protected成员的特点和作用</p>
<ul>
<li>对建立其所在类对象的模块来说，它和private成员性质相同</li>
<li>对于其派生类来说，它与public成员的性质相同</li>
<li>既实现了数据隐藏，又方便继承，实现代码重用</li>
</ul>
<h2 id="基类与派生类类型转换"><a href="#基类与派生类类型转换" class="headerlink" title="基类与派生类类型转换"></a>基类与派生类类型转换</h2><p>类型转换</p>
<ul>
<li>公有派生类对象可以被当做基类的对象使用，反之则不然<ul>
<li>派生类的对象可以隐含转换为基类对象</li>
<li>派生类的指针可以因哈转换为基类的指针</li>
</ul>
</li>
<li>通过基类对象名，指针只能使用从基类继承的成员</li>
</ul>
<p><strong>不要重新定义继承而来的非虚函数</strong></p>
<h2 id="派生类的构造与析构"><a href="#派生类的构造与析构" class="headerlink" title="派生类的构造与析构"></a>派生类的构造与析构</h2><p>派生类的构造函数</p>
<p>默认情况下</p>
<ul>
<li>基类的构造函数不被继承</li>
<li>派生类需要定义自己的构造函数</li>
</ul>
<p>c++11 </p>
<ul>
<li>可以使用using语句继承基类构造函数</li>
<li>但是只能初始化从基类继承的成员  using B::B;</li>
</ul>
<p>若不继承基类的构造函数</p>
<ul>
<li>派生类新增成员：派生类定义构造函数初始化</li>
<li>继承来的成员：自动调用基类构造函数进行初始化</li>
<li>派生类的构造函数需要给基类的构造函数传递参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未在初始化列表中出现的基类，对象成员，用对应类的默认构造函数初始化</span></span><br><span class="line">派生类名::派生类名(基类需要的形参，本类成员需要的形参):基类名(参数表),本类成员初始化列表</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 其他初始化;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数的执行顺序</p>
<ul>
<li>调用基类构造函数<ul>
<li>顺序按照它们被继承时声明的顺序 从左向右 </li>
</ul>
</li>
<li>对初始化类表中的成员进行初始化<ul>
<li>顺序按照它们在类中定义的顺序</li>
<li>对象成员在初始化时自动调用其所属类的构造函数:由初始化列表提供参数</li>
</ul>
</li>
<li>执行派生类的构造函数体中的内容</li>
</ul>
<p><strong>派生类的复制构造函数</strong></p>
<p>若派生类没有声明复制构造函数</p>
<ul>
<li>编译器会在需要时生成一个隐含的复制构造函数</li>
<li>先调用基类的复制构造函数</li>
<li>再为派生类新增的成员执行复制</li>
</ul>
<p>若派生类定义复制构造函数</p>
<ul>
<li>一般都要为基类的复制构造函数传递参数</li>
<li>复制构造函数只能接受一个参数，既用来初始化派生类定义的成员，也将被传递给基类的复制构造函数</li>
<li>基类的复制构造函数形参是基类对象的引用，实参可以使派生类对象的引用</li>
</ul>
<p>派生类的析构函数</p>
<ul>
<li>析构函数不被继承，派生类如果需要，要自行声明析构函数</li>
<li>声明方法与吴继承关系时的类的析构函数相同</li>
<li>不需要显示的调用基类的析构函数，系统会自动隐式调用</li>
<li>先执行派生类析构函数的函数体，再调用基类的析构函数</li>
<li>析构的顺序和构造的顺序相反</li>
</ul>
<h2 id="派生类成员的标识与访问"><a href="#派生类成员的标识与访问" class="headerlink" title="派生类成员的标识与访问"></a>派生类成员的标识与访问</h2><p>当派生类中与基类中有相同成员时</p>
<ul>
<li>若无特别限定，则通过派生类对象使用的是派生类中的同名成员</li>
<li>如果要通过派生类对象访问基类中被隐藏的同名成员，应使用基类名和作用域操作符::来限定</li>
</ul>
<p>二义性问题</p>
<ul>
<li>如果从不同基类继承了同名成员，但在派生类中没有定义同名成员<ul>
<li>解决方法一：类名限定访问同名成员</li>
<li>解决方法二(函数成员)：在派生类中定义同名函数，函数体中根据需要调用基类中的同名成员</li>
</ul>
</li>
</ul>
<p><strong>虚基类</strong></p>
<ul>
<li>需要解决的问题：当派生类从多个基类继承，而这些基类又有共同基类，则在访问此共同基类中的成员时，将产生冗余，并有可能因冗余带来不一致性</li>
<li>虚基类声明：以virtual说明基类继承方式</li>
<li>作用：主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题，为最远的派生类提供唯一的基类成员，而不重复产生多次复制</li>
<li>注意：在第一级继承时就要将共同基类设计为虚基类</li>
</ul>
<p>虚基类及其派生类的构造函数</p>
<ul>
<li>建立对象时所指定的类称为最远派生类</li>
<li>虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的</li>
<li>在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数中的成员初始化列表中为虚基类的构造函数列出参数，如果没有列出，则表示调用该虚基类的默认构造函数</li>
<li>在建立对象时，只有最远派生类的构造函数调用虚基类的构造函数，其他类对虚基类的构造函数的调用被忽略</li>
</ul>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>操作接口具有表现不同形态的能力</p>
<p>编译时的绑定    函数重载(静态的多态，编译时绑定)</p>
<p>运行时的绑定</p>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>定义操作符函数</p>
<ul>
<li>c++几乎可以重载全部的运算符，而且只能重载c++已有的</li>
<li>不能重载的运算符    .    .*      ::      ?:</li>
<li>重载过后，运算符的优先级和结合性不变</li>
</ul>
<p>将运算符重载为类的非静态成员函数 (左操作数必须是类的对象)</p>
<ul>
<li>双目运算符 单目运算符</li>
<li>参数个数=原操作数个数-1 ，后置++,—除外(相比前置多一个int类型形参以示区分，重载)</li>
</ul>
<p>将运算符重载为非成员函数</p>
<ul>
<li>函数的形参代表依照自左至右次序排列各操作数</li>
<li>参数个数=原操作数个数 ，后置++,—除外(相比前置多一个int类型形参以示区分，重载)</li>
<li>至少应该有一个自定义类型的参数</li>
<li>如果在运算符的重载函数中需要操作某类对象的私有成员，可以将此函数声明为该类的友元</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数类型 <span class="keyword">operator</span> 运算符(形参)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重载&lt;&lt;插入运算符</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>多态行为的基础：基类声明虚函数，派生类声明一个函数覆盖该虚函数（覆盖要求：函数签名【函数名 参数列表 返回值类型 const】完全一致）</p>
<ul>
<li>同名函数前加 virtual 关键字，类体定义在外面（在里面是内联函数，对内联函数的处理是静态的）</li>
<li>运行时的动态绑定</li>
<li>虚函数必须是非静态的成员函数（属于对象，而不是整个类的）</li>
<li>构造函数不能是虚函数，析构函数可以是虚函数</li>
<li>派生类中的虚函数会隐藏基类中同名函数的所有其他重载形式，需要用类名才能调用</li>
</ul>
<p><strong>虚析构函数</strong></p>
<ul>
<li>如果你打算允许其他人通过基类指针调用对象的析构函数，就需要让基类的析构函数为虚函数，否则执行delete的结果是不确定的</li>
</ul>
<p>虚表</p>
<ul>
<li>每个多态类有一个虚表(virtual table)</li>
<li>虚表中有当前类的各个虚函数的入口地址</li>
<li>每个对象有一个指向当前类的虚表的指针 (虚指针 vptr)</li>
</ul>
<p>动态绑定的实现</p>
<ul>
<li>构造函数中为对象的虚指针赋值</li>
<li>通过多态类型的指针或引用调用成员函数时，通过虚指针找到虚表，进而找到所调用的虚函数的入口地址</li>
<li>通过该入口地址调用这个虚函数</li>
</ul>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>纯虚函数</p>
<ul>
<li>纯虚函数是一个在基类中声明的虚函数，它在基类中没有定义具体的操作内容，要求各派生类根据实际需要定义自己的版本</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 函数类型 函数名(参数表)=<span class="number">0</span>; <span class="comment">// 表示没有函数体</span></span><br></pre></td></tr></table></figure>
<p>带有纯虚函数的类称为抽象类：规范整个类家族的统一对外接口    （不能够实例化）</p>
<h2 id="override-final"><a href="#override-final" class="headerlink" title="override final"></a>override final</h2><p>c++11 override  显式地函数覆盖</p>
<p>final  不希望被继承 发展  （在类的声明和函数声明末尾加关键字 final）</p>
<h1 id="模板与群体数据"><a href="#模板与群体数据" class="headerlink" title="模板与群体数据"></a>模板与群体数据</h1><h1 id="泛型程序设计与c-标准模板库"><a href="#泛型程序设计与c-标准模板库" class="headerlink" title="泛型程序设计与c++标准模板库"></a>泛型程序设计与c++标准模板库</h1><h1 id="流类库-输入-输出"><a href="#流类库-输入-输出" class="headerlink" title="流类库  输入/输出"></a>流类库  输入/输出</h1><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/01/generative-models/" rel="next" title="Generative models">
                <i class="fa fa-chevron-left"></i> Generative models
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/12/算法基础/" rel="prev" title="Algorithm & Data Structure">
                Algorithm & Data Structure <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">lizzy llq</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#计算机基础"><span class="nav-number">1.</span> <span class="nav-text">计算机基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#计算机系统"><span class="nav-number">1.1.</span> <span class="nav-text">计算机系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算机语言"><span class="nav-number">1.2.</span> <span class="nav-text">计算机语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信息在计算机中的表示与存储"><span class="nav-number">1.3.</span> <span class="nav-text">信息在计算机中的表示与存储</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据和基本运算"><span class="nav-number">2.</span> <span class="nav-text">数据和基本运算</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本数据类型"><span class="nav-number">2.1.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运算符"><span class="nav-number">2.2.</span> <span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入-输出"><span class="nav-number">2.3.</span> <span class="nav-text">输入/输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择结构-循环结构"><span class="nav-number">2.4.</span> <span class="nav-text">选择结构/循环结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义类型"><span class="nav-number">2.5.</span> <span class="nav-text">自定义类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-number">3.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数定义-函数调用"><span class="nav-number">3.1.</span> <span class="nav-text">函数定义  函数调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的参数传递"><span class="nav-number">3.2.</span> <span class="nav-text">函数的参数传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内联函数-constexpr函数"><span class="nav-number">3.3.</span> <span class="nav-text">内联函数  constexpr函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类与对象"><span class="nav-number">4.</span> <span class="nav-text">类与对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类和对象"><span class="nav-number">4.1.</span> <span class="nav-text">类和对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数-析构函数"><span class="nav-number">4.2.</span> <span class="nav-text">构造函数 析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的组合-UML"><span class="nav-number">4.3.</span> <span class="nav-text">类的组合  UML</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体-联合体"><span class="nav-number">4.4.</span> <span class="nav-text">结构体 联合体</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据的共享与保护"><span class="nav-number">5.</span> <span class="nav-text">数据的共享与保护</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#标志符作用域和可见性"><span class="nav-number">5.1.</span> <span class="nav-text">标志符作用域和可见性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的生存期"><span class="nav-number">5.2.</span> <span class="nav-text">对象的生存期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的静态成员"><span class="nav-number">5.3.</span> <span class="nav-text">类的静态成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的友元"><span class="nav-number">5.4.</span> <span class="nav-text">类的友元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#共享数据的保护"><span class="nav-number">5.5.</span> <span class="nav-text">共享数据的保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多文件结构和预编译命令"><span class="nav-number">5.6.</span> <span class="nav-text">多文件结构和预编译命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组-指针-字符串"><span class="nav-number">6.</span> <span class="nav-text">数组 指针 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的定义与初始化"><span class="nav-number">6.1.</span> <span class="nav-text">数组的定义与初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组作为函数的参数"><span class="nav-number">6.2.</span> <span class="nav-text">数组作为函数的参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象数组"><span class="nav-number">6.3.</span> <span class="nav-text">对象数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针的定义与运算"><span class="nav-number">6.4.</span> <span class="nav-text">指针的定义与运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针与数组"><span class="nav-number">6.5.</span> <span class="nav-text">指针与数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针与函数"><span class="nav-number">6.6.</span> <span class="nav-text">指针与函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象指针"><span class="nav-number">6.7.</span> <span class="nav-text">对象指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态内存分配和释放"><span class="nav-number">6.8.</span> <span class="nav-text">动态内存分配和释放</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象复制与移动"><span class="nav-number">6.9.</span> <span class="nav-text">对象复制与移动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串"><span class="nav-number">6.10.</span> <span class="nav-text">字符串</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#继承与派生"><span class="nav-number">7.</span> <span class="nav-text">继承与派生</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#继承的基本概念与语法"><span class="nav-number">7.1.</span> <span class="nav-text">继承的基本概念与语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承方式"><span class="nav-number">7.2.</span> <span class="nav-text">继承方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基类与派生类类型转换"><span class="nav-number">7.3.</span> <span class="nav-text">基类与派生类类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#派生类的构造与析构"><span class="nav-number">7.4.</span> <span class="nav-text">派生类的构造与析构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#派生类成员的标识与访问"><span class="nav-number">7.5.</span> <span class="nav-text">派生类成员的标识与访问</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多态"><span class="nav-number">8.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#运算符重载"><span class="nav-number">8.1.</span> <span class="nav-text">运算符重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚函数"><span class="nav-number">8.2.</span> <span class="nav-text">虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象类"><span class="nav-number">8.3.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#override-final"><span class="nav-number">8.4.</span> <span class="nav-text">override final</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模板与群体数据"><span class="nav-number">9.</span> <span class="nav-text">模板与群体数据</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#泛型程序设计与c-标准模板库"><span class="nav-number">10.</span> <span class="nav-text">泛型程序设计与c++标准模板库</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#流类库-输入-输出"><span class="nav-number">11.</span> <span class="nav-text">流类库  输入/输出</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#异常处理"><span class="nav-number">12.</span> <span class="nav-text">异常处理</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lizzy llq</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
